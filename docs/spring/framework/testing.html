<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Testing</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style type="text/css">
body {
	font-family: 'Malgun Gothic', '맑은 고딕', dotum, '돋움', sans-serif
}
</style>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3LG0R87MZJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-3LG0R87MZJ');
</script>
<script data-ad-client="ca-pub-6001719113094141" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script type="text/javascript">
function addBlockSwitches() {
	for (var primary of document.querySelectorAll('.primary')) {
		var switchItem = createSwitchItem(primary, createBlockSwitch(primary));
		switchItem.item.classList.add("selected");
		var title = primary.querySelector('.title')
		title.remove();
	}
	for (var secondary of document.querySelectorAll('.secondary')) {
		var primary = findPrimary(secondary);
		if (primary === null) {
			console.error("Found secondary block with no primary sibling");
		}
		else {
			var switchItem = createSwitchItem(secondary, primary.querySelector('.switch'));
			switchItem.content.classList.add("hidden");
			primary.append(switchItem.content);
			secondary.remove();
		}
	}
}

function createElementFromHtml(html) {
	var template = document.createElement('template');
    template.innerHTML = html;
    return template.content.firstChild;
}

function createBlockSwitch(primary) {
    var blockSwitch = createElementFromHtml('<div class="switch"></div>');
    primary.prepend(blockSwitch)
	return blockSwitch;
}

function findPrimary(secondary) {
	var candidate = secondary.previousElementSibling;
	while (candidate != null && !candidate.classList.contains('primary')) {
		candidate = candidate.previousElementSibling;
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	var blockName = block.querySelector('.title').textContent;
	var content = block.querySelectorAll('.content').item(0);
	var colist = block.querySelector('.colist')
	if (colist != null) {
		content.append();
	}
	var item = createElementFromHtml('<div class="switch--item">' + blockName + '</div>');
	item.dataset.blockName = blockName;
	content.dataset.blockName = blockName;
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

function globalSwitch() {
	document.querySelectorAll(".switch--item").forEach(function(item) {
		var blockId = blockIdForSwitchItem(item);
		var handler = function(event) {
			selectedText = event.target.textContent;
			window.localStorage.setItem(blockId, selectedText);
			for (var switchItem of document.querySelectorAll(".switch--item")) {
				if (blockIdForSwitchItem(switchItem) === blockId && switchItem.textContent === selectedText) {
					select(switchItem);
				}
			}
		}
		item.addEventListener("click", handler);
		if (item.textContent === window.localStorage.getItem(blockId)) {
			select(item);
		}
	});
}

function select(selected) {
	for (var child of selected.parentNode.children) {
		child.classList.remove("selected");
	}
	selected.classList.add("selected");
	for (var child of selected.parentNode.parentNode.children) {
		if (child.classList.contains("content")) {
			if (selected.dataset.blockName === child.dataset.blockName) {
				child.classList.remove("hidden");
			}
			else {
				child.classList.add("hidden");
			}
		}
	}	
}

function blockIdForSwitchItem(item) {
	idComponents = []
	for (var switchItem of item.parentNode.querySelectorAll(".switch--item")) {
		idComponents.push(switchItem.textContent.toLowerCase());
	}
	return idComponents.sort().join("-")
}

window.onload = function() {
	addBlockSwitches();
	globalSwitch();
};
</script>

</head>
<body id="testing" class="book toc2 toc-left">
<div id="header">
<h1>Testing</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#testing-introduction">Introduction to Spring Testing</a></li>
<li><a href="#unit-testing">Unit Testing</a>
<ul class="sectlevel2">
<li><a href="#mock-objects">Mock Objects</a>
<ul class="sectlevel3">
<li><a href="#mock-objects-env">Environment</a></li>
<li><a href="#mock-objects-jndi">JNDI</a></li>
<li><a href="#mock-objects-servlet">Servlet API</a></li>
<li><a href="#mock-objects-web-reactive">Spring Web Reactive</a></li>
</ul>
</li>
<li><a href="#unit-testing-support-classes">Unit Testing Support Classes</a>
<ul class="sectlevel3">
<li><a href="#unit-testing-utilities">General Testing Utilities</a></li>
<li><a href="#unit-testing-spring-mvc">Spring MVC Testing Utilities</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#integration-testing">Integration Testing</a>
<ul class="sectlevel2">
<li><a href="#integration-testing-overview">Overview</a></li>
<li><a href="#integration-testing-goals">Goals of Integration Testing</a>
<ul class="sectlevel3">
<li><a href="#testing-ctx-management">Context Management and Caching</a></li>
<li><a href="#testing-fixture-di">Dependency Injection of Test Fixtures</a></li>
<li><a href="#testing-tx">Transaction Management</a></li>
<li><a href="#testing-support-classes">Support Classes for Integration Testing</a></li>
</ul>
</li>
<li><a href="#integration-testing-support-jdbc">JDBC Testing Support</a></li>
<li><a href="#integration-testing-annotations">Annotations</a>
<ul class="sectlevel3">
<li><a href="#integration-testing-annotations-spring">Spring Testing Annotations</a>
<ul class="sectlevel4">
<li><a href="#spring-testing-annotation-bootstrapwith"><code>@BootstrapWith</code></a></li>
<li><a href="#spring-testing-annotation-contextconfiguration"><code>@ContextConfiguration</code></a></li>
<li><a href="#spring-testing-annotation-webappconfiguration"><code>@WebAppConfiguration</code></a></li>
<li><a href="#spring-testing-annotation-contexthierarchy"><code>@ContextHierarchy</code></a></li>
<li><a href="#spring-testing-annotation-activeprofiles"><code>@ActiveProfiles</code></a></li>
<li><a href="#spring-testing-annotation-testpropertysource"><code>@TestPropertySource</code></a></li>
<li><a href="#spring-testing-annotation-dynamicpropertysource"><code>@DynamicPropertySource</code></a></li>
<li><a href="#spring-testing-annotation-dirtiescontext"><code>@DirtiesContext</code></a></li>
<li><a href="#spring-testing-annotation-testexecutionlisteners"><code>@TestExecutionListeners</code></a></li>
<li><a href="#spring-testing-annotation-recordapplicationevents"><code>@RecordApplicationEvents</code></a></li>
<li><a href="#spring-testing-annotation-commit"><code>@Commit</code></a></li>
<li><a href="#spring-testing-annotation-rollback"><code>@Rollback</code></a></li>
<li><a href="#spring-testing-annotation-beforetransaction"><code>@BeforeTransaction</code></a></li>
<li><a href="#spring-testing-annotation-aftertransaction"><code>@AfterTransaction</code></a></li>
<li><a href="#spring-testing-annotation-sql"><code>@Sql</code></a></li>
<li><a href="#spring-testing-annotation-sqlconfig"><code>@SqlConfig</code></a></li>
<li><a href="#spring-testing-annotation-sqlmergemode"><code>@SqlMergeMode</code></a></li>
<li><a href="#spring-testing-annotation-sqlgroup"><code>@SqlGroup</code></a></li>
</ul>
</li>
<li><a href="#integration-testing-annotations-standard">Standard Annotation Support</a></li>
<li><a href="#integration-testing-annotations-junit4">Spring JUnit 4 Testing Annotations</a>
<ul class="sectlevel4">
<li><a href="#integration-testing-annotations-junit4-ifprofilevalue"><code>@IfProfileValue</code></a></li>
<li><a href="#integration-testing-annotations-junit4-profilevaluesourceconfiguration"><code>@ProfileValueSourceConfiguration</code></a></li>
<li><a href="#integration-testing-annotations-junit4-timed"><code>@Timed</code></a></li>
<li><a href="#integration-testing-annotations-junit4-repeat"><code>@Repeat</code></a></li>
</ul>
</li>
<li><a href="#integration-testing-annotations-junit-jupiter">Spring JUnit Jupiter Testing Annotations</a>
<ul class="sectlevel4">
<li><a href="#integration-testing-annotations-junit-jupiter-springjunitconfig"><code>@SpringJUnitConfig</code></a></li>
<li><a href="#integration-testing-annotations-junit-jupiter-springjunitwebconfig"><code>@SpringJUnitWebConfig</code></a></li>
<li><a href="#integration-testing-annotations-testconstructor"><code>@TestConstructor</code></a></li>
<li><a href="#integration-testing-annotations-nestedtestconfiguration"><code>@NestedTestConfiguration</code></a></li>
<li><a href="#integration-testing-annotations-junit-jupiter-enabledif"><code>@EnabledIf</code></a></li>
<li><a href="#integration-testing-annotations-junit-jupiter-disabledif"><code>@DisabledIf</code></a></li>
</ul>
</li>
<li><a href="#integration-testing-annotations-meta">Meta-Annotation Support for Testing</a></li>
</ul>
</li>
<li><a href="#testcontext-framework">Spring TestContext Framework</a>
<ul class="sectlevel3">
<li><a href="#testcontext-key-abstractions">Key Abstractions</a>
<ul class="sectlevel4">
<li><a href="#_testcontext"><code>TestContext</code></a></li>
<li><a href="#_testcontextmanager"><code>TestContextManager</code></a></li>
<li><a href="#_testexecutionlistener"><code>TestExecutionListener</code></a></li>
<li><a href="#_context_loaders">Context Loaders</a></li>
</ul>
</li>
<li><a href="#testcontext-bootstrapping">Bootstrapping the TestContext Framework</a></li>
<li><a href="#testcontext-tel-config"><code>TestExecutionListener</code> Configuration</a>
<ul class="sectlevel4">
<li><a href="#testcontext-tel-config-registering-tels">Registering <code>TestExecutionListener</code> Implementations</a></li>
<li><a href="#testcontext-tel-config-automatic-discovery">Automatic Discovery of Default <code>TestExecutionListener</code> Implementations</a></li>
<li><a href="#testcontext-tel-config-ordering">Ordering <code>TestExecutionListener</code> Implementations</a></li>
<li><a href="#testcontext-tel-config-merging">Merging <code>TestExecutionListener</code> Implementations</a></li>
</ul>
</li>
<li><a href="#testcontext-application-events">Application Events</a></li>
<li><a href="#testcontext-test-execution-events">Test Execution Events</a>
<ul class="sectlevel4">
<li><a href="#testcontext-test-execution-events-exception-handling">Exception Handling</a></li>
<li><a href="#testcontext-test-execution-events-async">Asynchronous Listeners</a></li>
</ul>
</li>
<li><a href="#testcontext-ctx-management">Context Management</a>
<ul class="sectlevel4">
<li><a href="#testcontext-ctx-management-xml">Context Configuration with XML resources</a></li>
<li><a href="#testcontext-ctx-management-groovy">Context Configuration with Groovy Scripts</a></li>
<li><a href="#testcontext-ctx-management-javaconfig">Context Configuration with Component Classes</a></li>
<li><a href="#testcontext-ctx-management-mixed-config">Mixing XML, Groovy Scripts, and Component Classes</a></li>
<li><a href="#testcontext-ctx-management-initializers">Context Configuration with Context Initializers</a></li>
<li><a href="#testcontext-ctx-management-inheritance">Context Configuration Inheritance</a></li>
<li><a href="#testcontext-ctx-management-env-profiles">Context Configuration with Environment Profiles</a></li>
<li><a href="#testcontext-ctx-management-property-sources">Context Configuration with Test Property Sources</a></li>
<li><a href="#testcontext-ctx-management-dynamic-property-sources">Context Configuration with Dynamic Property Sources</a></li>
<li><a href="#testcontext-ctx-management-web">Loading a <code>WebApplicationContext</code></a></li>
<li><a href="#testcontext-ctx-management-caching">Context Caching</a></li>
<li><a href="#testcontext-ctx-management-ctx-hierarchies">Context Hierarchies</a></li>
</ul>
</li>
<li><a href="#testcontext-fixture-di">Dependency Injection of Test Fixtures</a></li>
<li><a href="#testcontext-web-scoped-beans">Testing Request- and Session-scoped Beans</a></li>
<li><a href="#testcontext-tx">Transaction Management</a>
<ul class="sectlevel4">
<li><a href="#testcontext-tx-test-managed-transactions">Test-managed Transactions</a></li>
<li><a href="#testcontext-tx-enabling-transactions">Enabling and Disabling Transactions</a></li>
<li><a href="#testcontext-tx-rollback-and-commit-behavior">Transaction Rollback and Commit Behavior</a></li>
<li><a href="#testcontext-tx-programmatic-tx-mgt">Programmatic Transaction Management</a></li>
<li><a href="#testcontext-tx-before-and-after-tx">Running Code Outside of a Transaction</a></li>
<li><a href="#testcontext-tx-mgr-config">Configuring a Transaction Manager</a></li>
<li><a href="#testcontext-tx-annotation-demo">Demonstration of All Transaction-related Annotations</a></li>
</ul>
</li>
<li><a href="#testcontext-executing-sql">Executing SQL Scripts</a>
<ul class="sectlevel4">
<li><a href="#testcontext-executing-sql-programmatically">Executing SQL scripts programmatically</a></li>
<li><a href="#testcontext-executing-sql-declaratively">Executing SQL scripts declaratively with @Sql</a></li>
</ul>
</li>
<li><a href="#testcontext-parallel-test-execution">Parallel Test Execution</a></li>
<li><a href="#testcontext-support-classes">TestContext Framework Support Classes</a>
<ul class="sectlevel4">
<li><a href="#testcontext-junit4-runner">Spring JUnit 4 Runner</a></li>
<li><a href="#testcontext-junit4-rules">Spring JUnit 4 Rules</a></li>
<li><a href="#testcontext-support-classes-junit4">JUnit 4 Support Classes</a></li>
<li><a href="#testcontext-junit-jupiter-extension">SpringExtension for JUnit Jupiter</a></li>
<li><a href="#testcontext-junit-jupiter-di">Dependency Injection with <code>SpringExtension</code></a></li>
<li><a href="#testcontext-junit-jupiter-nested-test-configuration"><code>@Nested</code> test class configuration</a></li>
<li><a href="#testcontext-support-classes-testng">TestNG Support Classes</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#spring-mvc-test-framework">MockMvc</a>
<ul class="sectlevel3">
<li><a href="#spring-mvc-test-server">Overview</a>
<ul class="sectlevel4">
<li><a href="#spring-mvc-test-server-static-imports">Static Imports</a></li>
<li><a href="#spring-mvc-test-server-setup-options">Setup Choices</a></li>
<li><a href="#spring-mvc-test-server-setup-steps">Setup Features</a></li>
<li><a href="#spring-mvc-test-server-performing-requests">Performing Requests</a></li>
<li><a href="#spring-mvc-test-server-defining-expectations">Defining Expectations</a></li>
<li><a href="#spring-mvc-test-async-requests">Async Requests</a></li>
<li><a href="#spring-mvc-test-vs-streaming-response">Streaming Responses</a></li>
<li><a href="#spring-mvc-test-server-filters">Filter Registrations</a></li>
<li><a href="#spring-mvc-test-vs-end-to-end-integration-tests">MockMvc vs End-to-End Tests</a></li>
<li><a href="#spring-mvc-test-server-resources">Further Examples</a></li>
</ul>
</li>
<li><a href="#spring-mvc-test-server-htmlunit">HtmlUnit Integration</a>
<ul class="sectlevel4">
<li><a href="#spring-mvc-test-server-htmlunit-why">Why HtmlUnit Integration?</a></li>
<li><a href="#spring-mvc-test-server-htmlunit-mah">MockMvc and HtmlUnit</a></li>
<li><a href="#spring-mvc-test-server-htmlunit-webdriver">MockMvc and WebDriver</a></li>
<li><a href="#spring-mvc-test-server-htmlunit-geb">MockMvc and Geb</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#spring-mvc-test-client">Testing Client Applications</a>
<ul class="sectlevel3">
<li><a href="#spring-mvc-test-client-static-imports">Static Imports</a></li>
<li><a href="#spring-mvc-test-client-resources">Further Examples of Client-side REST Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#testing-resources">Further Resources</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>이 chapter에서는 통합 테스트에 대한 Spring의 지원과 단위 테스트에 대한 모범 사례를 다룹니다.
Spring 팀은 TDD(테스트 주도 개발)를 지지합니다.
Spring 팀은 IoC(inversion of control)를 올바르게 사용하면 확실히 단위 테스트와 통합 테스트가 더 쉬워진다는 것을 발견했습니다.
(class에 setter method와 적절한 constructor가 있으면 테스트에서 연결할 필요없이 쉽게 연결할 수 있다는 점에서 service locator registry 와 유사한 구조 설정)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing-introduction">Introduction to Spring Testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>테스트는 enterprise software 개발의 필수적인 부분입니다.
이 chapter에서는 <a href="#unit-testing">단위 테스트</a>와 <a href="#integration-testing">통합 테스트</a>를 위한 Spring Framework의 지원의 장점이 IoC 원칙에 의해 추가된 이점을 중점적으로 다룹니다.
(enterprise에서의 철저한 테스트 처리는 이 reference menual의 범위를 벗어납니다.)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="unit-testing">Unit Testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Dependency injection은 기존 Java EE 개발보다 코드가 container에 덜 의존하도록 해야 합니다.
application을 구성하는 POJO는 JUnit 또는 TestNG 테스트에서 테스트 할 수 있어야 하며 Spring이나 다른 container없이 <code>new</code> operator를 사용하여 인스턴스화 된 객체가 있어야 합니다.
코드를 분리하여 테스트 하기 위해 (다른 중요한 테스트 기법과 연계하여) <a href="#mock-objects">mock objects</a>를 사용할 수 있습니다.
Spring에 대한 architecture 권장사항을 따르는 경우 codebase의 깔끔한 계층화 및 component화를 통해 더 쉽게 단위 테스트를 수행할 수 있습니다.
예를 들어 단위 테스트를 실행하는 동안 persistent data에 접근할 필요없이 DAO 또는 repository interface를 stubbing 또는 mocking 하여 service layer를 테스트할 수 있습니다.</p>
</div>
<div class="paragraph">
<p>설정할 runtime infrastructure가 없기 때문에 실제 단위 테스트는 일반적으로 매우 빠르게 실행됩니다.
개발 방식에 단위 테스트를 도입하면 생산성을 높일 수 있습니다.
Ioc 기반 application을 위한 효과적인 단위 테스트 작성을 돕기 위해 testing chapter의 이 section이 필요하지 않을 수 있습니다.
단, 특정 단위 테스트 시나리오의 경우 Spring Framework는 이 chapter에서 설명하는 mock object와 testing support class를 제공합니다.</p>
</div>
<div class="sect2">
<h3 id="mock-objects">Mock Objects</h3>
<div class="paragraph">
<p>Spring 은 mock 처리를 위한 다수의 package를 포함하고 있습니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#mock-objects-env">Environment</a></p>
</li>
<li>
<p><a href="#mock-objects-jndi">JNDI</a></p>
</li>
<li>
<p><a href="#mock-objects-servlet">Servlet API</a></p>
</li>
<li>
<p><a href="#mock-objects-web-reactive">Spring Web Reactive</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="mock-objects-env">Environment</h4>
<div class="paragraph">
<p><code>org.springframework.mock.env</code> package는 <code>Environment</code> 및 <code>PropertySource</code> 추상화의 mock 구현을 포함하고 있습니다.
(<a href="core.html#beans-definition-profiles">Bean Definition Profiles</a> 및 <a href="core.html#beans-property-source-abstraction"><code>PropertySource</code> Abstraction</a> 참조)
<code>MockEnvironment</code> and <code>MockPropertySource</code> 는 환경별 특성에 따라 달라지는 코드에 대한 out-of-container 테스트를 개발하는데 유용합니다.</p>
</div>
</div>
<div class="sect3">
<h4 id="mock-objects-jndi">JNDI</h4>
<div class="paragraph">
<p><code>org.springframework.mock.jndi</code> package는 test suite 또는 stand-alone application을 위한 간단한 JNDI 환경을 구성하는데 사용할 수 있는 JNDI SPI의 일부 구현이 표함되어 있습니다.
예를 들어 JDBC <code>DataSource</code> instance가 Java EE container에서와 같이 테스트 코드에서 동일한 JNDI 이름에 바인딩되면 수정없이 테스트 시나리오에서 application 코드와 구성을 모두 재사용할 수 있습니다.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>org.springframework.mock.jndi</code> package의 mock JNDI 지원은 <a href="https://github.com/h-thurow/Simple-JNDI">Simple-JNDI</a>와 같은 third party의 완전한 솔루션을 위해 Spring Framework 5.2에서 공식적으로 deprecated되었습니다.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mock-objects-servlet">Servlet API</h4>
<div class="paragraph">
<p><code>org.springframework.mock.web</code> package는 web context, controller, filter를 테스트하는데 유용한 Servlet API mock object를 포함하고 있습니다.
이 mock object는 Spring의 Web MVC framework 사용을 대상으로 하며 일반적으로 dynamic mock object (<a href="http://easymock.org/">EasyMock</a> 같은) 또는 alternative Servlet API mock object(<a href="http://www.mockobjects.com">MockObjects</a> 같은) 보다 더 사용하기 편리합니다.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring Framework 5.0부터 <code>org.springframework.mock.web</code> 의 mock object는 Servlet 4.0 API를 기반으로 합니다.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring MVC Test framework는 Spring MVC를 위한 integration testing framework를 제공하기 위해 mock Servlet API object를 기반으로 합니다.
<a href="#spring-mvc-test-framework">MockMvc</a>를 참조하세요.</p>
</div>
</div>
<div class="sect3">
<h4 id="mock-objects-web-reactive">Spring Web Reactive</h4>
<div class="paragraph">
<p><code>org.springframework.mock.http.server.reactive</code> package는 WebFlux application에 사용하는 <code>ServerHttpRequest</code> 및 <code>ServerHttpResponse</code> 의 mock 구현을 포함하고 있습니다.
<code>org.springframework.mock.web.server</code> package는 mock request 및 response object에 대한 mock <code>ServerWebExchange</code> 를 포함하고 있습니다.</p>
</div>
<div class="paragraph">
<p><code>MockServerHttpRequest</code> 및 <code>MockServerHttpResponse</code> 는 둘다 서버별 구현 및 동작을 공유하는 같은 abstract 기반 class에서 extend 되었습니다.
예를 들어 mock request는 생성된 후에는 변경할 수 없지만 <code>ServerHttpRequest</code> 로부터 <code>mutate()</code> method를 사용하여 수정된 instance를 만들 수 있습니다.</p>
</div>
<div class="paragraph">
<p>mock response가 write contract를 올바르게 구현하고 completion handle( <code>Mono&lt;Void&gt;</code> )을 반환하기 위해 기본적으로 <code>cache().then()</code> 와 함께 <code>Flux</code> 를 사용하여 data를 버퍼링하고 테스트에서 assertion을 사용할 수 있게 합니다.
application은 custom write function을 설정할 수 있습니다. (예를 들면 infinite stream 테스트)</p>
</div>
<div class="paragraph">
<p><a href="#webtestclient">[webtestclient]</a> 는 HTTP server없이 WebFlux application을 테스트하기 위한 지원을 제공하기 위해 mock request 및 response를 기반으로 합니다.
client는 또한 실행중인 server와 end-to-end 테스트에도 사용할 수 있습니다.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unit-testing-support-classes">Unit Testing Support Classes</h3>
<div class="paragraph">
<p>Spring에는 단위 테스트에 도움이 될 수 있는 여러 class가 포함되어 있습니다.
두 가지 범주로 나뉩니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#unit-testing-utilities">General Testing Utilities</a></p>
</li>
<li>
<p><a href="#unit-testing-spring-mvc">Spring MVC Testing Utilities</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="unit-testing-utilities">General Testing Utilities</h4>
<div class="paragraph">
<p><code>org.springframework.test.util</code> package에는 단위 및 통합 테스트에 사용하기 위한 몇 가지 범용 유틸리티가 포함되어 있습니다.</p>
</div>
<div class="paragraph">
<p><code>ReflectionTestUtils</code> 은 reflection 기반 utility method의 모음입니다.
constant value를 변경하거나, non-<code>public</code> field를 설정하거나 non-<code>public</code> setter method를 호출하거나 non-<code>public</code> configuration을 호출하거나 application code를 다음과 같이 lifecycle callback method를 호출해야 하는 테스트 시나리오에서 이러한 method를 사용할 수 있습니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>domain entity의 propery에 대한 <code>public</code> setter method 와 달리 <code>private</code> or <code>protected</code> field access를 허용하는 ORM framework (JPA 와 Hibernate 같은)</p>
</li>
<li>
<p><code>private</code> 또는 <code>protected</code> field, setter method, configuration method에 대한 dependency injection을 제공하는 Spring 의 annotation 지원 (<code>@Autowired</code>, <code>@Inject</code> 및 <code>@Resource</code> 같은)</p>
</li>
<li>
<p>lifecycle callback method를 위한 <code>@PostConstruct</code> 및 <code>@PreDestroy</code> annotation 사용</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/util/AopTestUtils.html"><code>AopTestUtils</code></a>은 AOP 관련 utility method의 모음입니다.
이 method를 사용하여 하나 이상의 Spring proxy 뒤에 숨겨진 기본 대상 object에 대한 참조를 얻을 수 있습니다.
예를 들어 EasyMock 또는 Mockito와 같은 라이브러리를 사용하여 bean을 dynamic mock을 구성하고 Spring proxy로 wrapping 된 경우 기본 mock에 직접 access해 예상을 구성하고 검증을 수행해야 할 수 있습니다.
Spring의 core AOP utility에 대해서는 <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/aop/support/AopUtils.html"><code>AopUtils</code></a> 및 <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/aop/framework/AopProxyUtils.html"><code>AopProxyUtils</code></a>를 참조하세요.</p>
</div>
</div>
<div class="sect3">
<h4 id="unit-testing-spring-mvc">Spring MVC Testing Utilities</h4>
<div class="paragraph">
<p><code>org.springframework.test.web</code> package는 JUnit, TestNG 또는 다른 testing framework와 결함해 Spring MVC <code>ModelAndView</code> objects와 함께 단위 테스트 하는데 사용할 수 있는 <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/web/ModelAndViewAssert.html"><code>ModelAndViewAssert</code></a>를 포함하고 있습니다.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Unit testing Spring MVC Controllers</div>
Spring MVC <code>Controller</code> class를 POJO로 단위 테스트하려면 <code>MockHttpServletRequest</code>, <code>MockHttpSession</code> Spring의 <a href="#mock-objects-servlet">Servlet API mocks</a> 등이 결합된 <code>ModelAndViewAssert</code> 를 사용합니다.
Spring MVC에 대한 <code>WebApplicationContext</code> configuration과 함께 Spring MVC 및 REST <code>Controller</code> class의 통합 테스트를 하려면 <a href="#spring-mvc-test-framework">Spring MVC Test Framework</a>을 사용하세요.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="integration-testing">Integration Testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>이 section(이 chapter의 나머지 대부분)은 Spring application에 대한 통합 테스트를 다룹니다.
여기에는 다음 항목이 포함됩니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#integration-testing-overview">Overview</a></p>
</li>
<li>
<p><a href="#integration-testing-goals">Goals of Integration Testing</a></p>
</li>
<li>
<p><a href="#integration-testing-support-jdbc">JDBC Testing Support</a></p>
</li>
<li>
<p><a href="#integration-testing-annotations">Annotations</a></p>
</li>
<li>
<p><a href="#testcontext-framework">Spring TestContext Framework</a></p>
</li>
<li>
<p><a href="#spring-mvc-test-framework">MockMvc</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="integration-testing-overview">Overview</h3>
<div class="paragraph">
<p>application server에 배포하거나 enterprise infrastructure에 연결하지 않고도 일부 통합 테스트를 수행할 수 있어야 합니다.
이렇게 하면 다음과 같은 사항을 테스트할 수 있습니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring IoC container context의 올바른 연결</p>
</li>
<li>
<p>JDBC 또는 ORM 도구를 사용한 Data access. 여기에는 SQL statement의 정확성, Hibernate queryt, JPA entity mapping 등이 포함될 수 있습니다.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Framework는 <code>spring-test</code> module에서 통합 테스트를 위한 first-class support를 제공합니다.
실제 JAR file의 이름에는 release version이 포함될 수 있으며 어디에서 얻느냐에 따라 긴 <code>org.springframework.test</code> 형식일 수 있습니다. (<a href="core.html#dependency-management">section on Dependency Management</a> 설명 참조)
이 library에는 Spring container와의 통합 테스트를 위한 유용한 class가 포함된 <code>org.springframework.test</code> package가 포함되어 있습니다.
이 테스트는 application server 또는 기타 배포 환경에 의존하지 않습니다.
이러한 테스트는 단위 테스트보다 실행 속도가 느리지만 application server에 대한 배포에 의존하는 동등한 Selenium 테스트 또는 원격 테스트보다 훨씬 빠릅니다.</p>
</div>
<div class="paragraph">
<p>단위 및 통합 테스트 지원은 annotation 기반 <a href="#testcontext-framework">Spring TestContext Framework</a> 형태로 제공됩니다.
이 TestContext framework는 사용 중인 실제 test framework와 무관하며, 이를 통해 JUnit, TestNG 등 다양한 환경에서 테스트를 계측할 수 있습니다.</p>
</div>
</div>
<div class="sect2">
<h3 id="integration-testing-goals">Goals of Integration Testing</h3>
<div class="paragraph">
<p>Spring의 통합 테스트 지원에는 다음과 같은 주요 목표가 있습니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>테스트 간 <a href="#testing-ctx-management">Spring IoC container caching</a>을 관리</p>
</li>
<li>
<p><a href="#testing-fixture-di">Dependency Injection of test fixture instances</a> 제공</p>
</li>
<li>
<p>통합 테스트에 적합한 <a href="#testing-tx">transaction management</a> 제공</p>
</li>
<li>
<p>통합 테스트 작성 시 개발자를 지원하는 <a href="#testing-support-classes">Spring-specific base class</a> 제공</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>다음 몇 section에서는 각 목표를 설명하고 구현 및 구성 세부 정보에 대한 링크를 제공합니다.</p>
</div>
<div class="sect3">
<h4 id="testing-ctx-management">Context Management and Caching</h4>
<div class="paragraph">
<p>Spring TestContext Framework는 Spring <code>ApplicationContext</code> intance 및 <code>WebApplicationContext</code> instance의 일관된 로드와 해당 context의 caching을 제공합니다.
startup time이 이슈가 될 수 있기 때문에 로드된 context의 caching에 대한 지원은 중요합니다.
Spring 자체의 overhead 때문이 아니라 Spring container에 의해 인스턴스화 된 객체가 인스턴스화 하는데 시간이 걸리기 때문입니다.
예를 들어 50 ~ 100개의 Hibernate mapping file이 있는 프로젝트는 mapping file을 로드하는데 10 ~ 20초가 걸릴 수 있으며 모든 test fixture에서 모든 테스트를 실행하기 전에 해당 비용이 발생하면 전체 테스트 실행이 느려지고 개발자 생산성이 감소합니다.</p>
</div>
<div class="paragraph">
<p>test class는 일반적으로 XML 또는 Groovy configuration metadata에 대한 resource location 배열 (종종 classpath에 있음) 또는 application을 구성하는데 사용되는 component class 배열을 선언합니다.
이러한 location 또는 class는 product 배포를 위해 <code>web.xml</code> 또는 다른 configuration file에 지정된 것과 동일하거나 유사합니다.</p>
</div>
<div class="paragraph">
<p>기본적으로 한번 로드되면 구성된 <code>ApplicationContext</code> 는 각 테스트에 재사용됩니다.
따라서 설정 비용은 test suite 당 한번만 발생하며 후속 테스트 실행이 훨씬 빠릅니다.
이 멕락에서 &#8220;test suite&#8221; 라는 용어는 동일한 JVM에서 실행되는 모든 테스트를 의미합니다.
예를 들어 모든 테스트는 주어진 project 또는 module에 대해 Ant, Maven 또는 Gradle에서 실행됩니다.
테스트가 application context를 손상 시키고 다시 로드해야 하는 경우 (예를 들면 bean 정의 또는 application object의 상태를 수정한 경우) TestContext framework를 구성하여 다음을 실행하기 전에 구성을 다시 로드하고 application context를 다시 빌드할 수 있습니다.</p>
</div>
<div class="paragraph">
<p>TestContext framework를 사용한 <a href="#testcontext-ctx-management">Context Management</a> 및 <a href="#testcontext-ctx-management-caching">Context Caching</a>을 참조하세요.</p>
</div>
</div>
<div class="sect3">
<h4 id="testing-fixture-di">Dependency Injection of Test Fixtures</h4>
<div class="paragraph">
<p>TextContext framework가 application context를 로드할 때 선택적으로 dependency injection을 사용하여 test class의 instance를 구성할 수 있습니다.
이는 application context에서 사전 구성된 bean을 사용하여 test fixture를 설정하는 편리한 메커니즘을 제공합니다.
여기에서 강력한 이점은 다양한 테스트 시나리오 (예: spring-managed object graph, transactional proxy, <code>DataSource</code> instance 등을 구성하는 경우)에서 application context를 재사용 할 수 있으므로 개별 테스트 케이스에 대해 복잡한 test fixture 설정을 복제할 필요가 없다는 것입니다.</p>
</div>
<div class="paragraph">
<p>예를 들어 <code>Title</code> domain entity에 대한 data access logic 구현 class ( <code>HibernateTitleRepository</code> )가 있는 시나리오를 생각해보십시오.
다음 영역을 테스트하는 통합 테스트를 작성하려고 합니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring configuration : 기본적으로 <code>HibernateTitleRepository</code> bean 구성과 관련된 모든 것이 정확하고 존재합니까?</p>
</li>
<li>
<p>Hibernate mapping file configuration: 모든 것이 올바르게 맵핑되고 올바른 지연 로딩 설정이 제자리에 있습니까?</p>
</li>
<li>
<p><code>HibernateTitleRepository</code> logic  : 이 class의 구성된 인스턴스가 예상대로 작동합니까?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#testcontext-fixture-di">TestContext framework</a>를 사용하여 test fixture의 dependency injection을 참조하세요.</p>
</div>
</div>
<div class="sect3">
<h4 id="testing-tx">Transaction Management</h4>
<div class="paragraph">
<p>실제 database에 access하는 테스트의 일반적인 문제 중 하나는 지속성 저장소의 상태에 미치는 영향입니다.
개발 database를 사용하는 경우에도 상태 변경은 향후 테스트에 영향을 미칠 수 있습니다.
또한 영구 데이터 insert, update와 같은 작업은 transaction 외부에서 수행 (또는 확인) 할 수 없습니다.</p>
</div>
<div class="paragraph">
<p>TestContext framework는 이 문제를 해결합니다.
기본적으로 framework는 각 테스트에 대해 transaction을 만들고 rollback합니다.
transcation의 존재를 가정할 수 있는 코드를 작성할 수 있습니다.
테스트에서 transaction으로 proxy 된 object를 호출하면 구성된 transaction semantic에 따라 올바르게 동작합니다.
또한 테스트를 위해 관리되는 transaction 내에서 실행되는 동안 테스트 method가 선택한 테이블의 내용을 삭제하면 transaction이 기본적으로 rollback되고 database는 테스트 실행 이전으로 돌아갑니다.
transaction 지원은 테스트의 application context에 정의된 <code>PlatformTransactionManager</code> bean을 사용하여 테스트에 제공됩니다.</p>
</div>
<div class="paragraph">
<p>transaction을 commit 하려면 (비정상적이지만 때로는 특정 테스트가 database를 채우거나 수정하려는 경우 유용함) <a href="#integration-testing-annotations"><code>@Commit</code></a> annotation을 사용하여 transaction이 commit 되도록 TestContext framework에 지시할 수 있습니다.</p>
</div>
<div class="paragraph">
<p><a href="#testcontext-tx">TestContext framework</a>로 transaction management를 참조하세요.</p>
</div>
</div>
<div class="sect3">
<h4 id="testing-support-classes">Support Classes for Integration Testing</h4>
<div class="paragraph">
<p>Spring TestContext Framework는 통합 테스트 작성을 단순화하는 여러 <code>abstract</code> 지원 class를 제공합니다.
이러한 기본 test class는 test framework에 대한 잘 정의된 hook과 편리한 instance variable 및 method를 제공하여 다음에 엑세스 할 수 있습니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ApplicationContext</code>, 명시적인 bean 검색을 수행하거나 전체 context의 상태를 테스트합니다.</p>
</li>
<li>
<p><code>JdbcTemplate</code>, SQL 문을 실행하여 데이터베이스를 쿼리합니다. 이러한 쿼리를 사용하여 데이터베이스 관련 application 코드 실행 전후에 데이터베이스 상태를 확인할 수 있으며 Spring은 이러한 쿼리가 application 코드와 동일한 transaction 범위에서 실행되도록 합니다.
ORM 도구와 함께 사용하는 경우 <a href="#testcontext-tx-false-positives">오탐지</a>를 피해야 합니다.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>또한 project에 특정한 instance variable 및 method를 사용하여 application 전체의 사용자 지정 superclass를 만들 수도 있습니다.</p>
</div>
<div class="paragraph">
<p><a href="#testcontext-support-classes">TestContext framework</a>에 대한 지원 class를 참조하세요.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="integration-testing-support-jdbc">JDBC Testing Support</h3>
<div class="paragraph">
<p><code>org.springframework.test.jdbc</code> package에는 표준 dastabase 테스트 시나리오를 단순화하기 위한 JDBC 관련 utility function인 <code>JdbcTestUtils</code> 가 포함되어 있습니다.
특히 <code>JdbcTestUtils</code> 은 다음과 같은 static utility method를 제공합니다.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>countRowsInTable(..)</code>: 주어진 테이블의 행 수를 계산합니다.</p>
</li>
<li>
<p><code>countRowsInTableWhere(..)</code>: 제공된 <code>WHERE</code> 절을 사용하여 주어진 테이블의 행 수를 계산합니다.</p>
</li>
<li>
<p><code>deleteFromTables(..)</code>: 지정된 테이블에서 모든 행을 삭제합니다.</p>
</li>
<li>
<p><code>deleteFromTableWhere(..)</code>: 제공된 <code>WHERE</code> 절을 사용하여 주어진 테이블에서 행을 삭제합니다.</p>
</li>
<li>
<p><code>dropTables(..)</code>: 지정된 테이블을 삭제합니다.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="#testcontext-support-classes-junit4"><code>AbstractTransactionalJUnit4SpringContextTests</code></a> 및 <a href="#testcontext-support-classes-testng"><code>AbstractTransactionalTestNGSpringContextTests</code></a>는 앞서 언급한 <code>JdbcTestUtils</code> 의 method를 위임한 편리한 method를 제공합니다.</p>
</div>
<div class="paragraph">
<p><code>spring-jdbc</code> module은 데이터베이스와 상호 작용하는 통합 테스트에서 사용할 수 있는 embedded database 구성 및 실행을 지원합니다.
자세한 내용은 <a href="data-access.html#jdbc-embedded-database-support">Embedded Database 지원</a> 및 <a href="data-access.html#jdbc-embedded-database-dao-testing">Embedded Database로 dasta access logic 테스트하기</a>를 참조하세요.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="integration-testing-annotations">Annotations</h3>
<div class="paragraph">
<p>이 section은 Spring application을 테스트 할 때 사용할 수 있는 annotation을 다룹니다.
여기에는 다음 항목이 포함됩니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#integration-testing-annotations-spring">Spring Testing Annotations</a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-standard">Standard Annotation Support</a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit4">Spring JUnit 4 Testing Annotations</a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit-jupiter">Spring JUnit Jupiter Testing Annotations</a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-meta">Meta-Annotation Support for Testing</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="integration-testing-annotations-spring">Spring Testing Annotations</h4>
<div class="paragraph">
<p>Spring Framework는 TestContext framework와 함께 단위 및 통합 테스트에서 사용할 수 있는 다음과 같은 Spring 관련 annotation set을 제공합니다.
default attribute, attribute alias 및 기타 세부 사항을 포함한 추가 정보는 해당 javadoc을 참조하세요.</p>
</div>
<div class="paragraph">
<p>Spring의 test annotation에는 다음이 포함됩니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#spring-testing-annotation-bootstrapwith"><code>@BootstrapWith</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-contextconfiguration"><code>@ContextConfiguration</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-webappconfiguration"><code>@WebAppConfiguration</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-contexthierarchy"><code>@ContextHierarchy</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-activeprofiles"><code>@ActiveProfiles</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-testpropertysource"><code>@TestPropertySource</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-dynamicpropertysource"><code>@DynamicPropertySource</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-dirtiescontext"><code>@DirtiesContext</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-testexecutionlisteners"><code>@TestExecutionListeners</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-recordapplicationevents"><code>@RecordApplicationEvents</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-commit"><code>@Commit</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-rollback"><code>@Rollback</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-beforetransaction"><code>@BeforeTransaction</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-aftertransaction"><code>@AfterTransaction</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-sql"><code>@Sql</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-sqlconfig"><code>@SqlConfig</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-sqlmergemode"><code>@SqlMergeMode</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-sqlgroup"><code>@SqlGroup</code></a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-bootstrapwith"><code>@BootstrapWith</code></h5>
<div class="paragraph">
<p><code>@BootstrapWith</code> 는 Spring TestContext Framework가 bootstrap되는 방법을 구성하는데 사용할 수 있는 class-level annotation 입니다.
특히 <code>@BootstrapWith</code> 를 사용하여 custom <code>TestContextBootstrapper</code> 를 지정합니다.
자세한 내용은 <a href="#testcontext-bootstrapping">bootstrapping the TestContext framework</a> section을 참조하세요.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-contextconfiguration"><code>@ContextConfiguration</code></h5>
<div class="paragraph">
<p><code>@ContextConfiguration</code> 은 통합 테스트를 위해 <code>ApplicationContext</code> 를 로드하고 구성하는 방법을 결정하는데 사용되는 class-level metadata를 정의합니다.
특히 <code>@ContextConfiguration</code> 는 context를 로드하는데 사용되는 application context resource <code>locations</code> 또는 component <code>classes</code> 를 선언합니다.</p>
</div>
<div class="paragraph">
<p>Resource locations은 일반적으로 XML configuration file 또는 Groovy script이며 component class는 일반적으로 <code>@Configuration</code> class입니다.
그러나 resource locastion은 file system의 file 및 script를 참조할 수도 있으며 component class는 <code>@Component</code> classes, <code>@Service</code> classes 등이 될 수 있습니다.
자세한 내용은 <a href="#testcontext-ctx-management-javaconfig-component-classes">Component Classes</a>를 참조하세요.</p>
</div>
<div class="paragraph">
<p>다음 예제는 xml file을 참조하는 <code>@ContextConfiguration</code> annotation을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration("/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class XmlApplicationContextTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>XML file을 참조합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration("/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class XmlApplicationContextTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>XML file을 참조합니다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>다음 예제는 class를 참조하는 <code>@ContextConfiguration</code> annotation을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration(classes = TestConfig.class) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigClassApplicationContextTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>class를 참조합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration(classes = [TestConfig::class]) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigClassApplicationContextTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>class를 참조합니다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>대안으로 resource location 또는 component class를 선언하는 것 외에 <code>@ContextConfiguration</code> 를 사용하여 <code>ApplicationContextInitializer</code> class를 선언할 수 있습니다.
다음 예는 이러한 경우를 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration(initializers = CustomContextIntializer.class) <i class="conum" data-value="1"></i><b>(1)</b>
class ContextInitializerTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration(initializers = [CustomContextIntializer::class]) <i class="conum" data-value="1"></i><b>(1)</b>
class ContextInitializerTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Declaring an initializer class.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>선택적으로 <code>@ContextConfiguration</code> 를 사용하여 <code>ContextLoader</code> strategy를 선언할 수도 있습니다.
그러나 default loader가 <code>initializers</code> 및 resource <code>locations</code> 또는 component <code>classes</code> 를 지원하므로 일반적으로 loader를 명시적으로 구성할 필요가 없습니다.</p>
</div>
<div class="paragraph">
<p>다음 예제에서는 location과 loader를 모두 사용합니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration(locations = "/test-context.xml", loader = CustomContextLoader.class) <i class="conum" data-value="1"></i><b>(1)</b>
class CustomLoaderXmlApplicationContextTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>location과 custom loader를 모두 구성합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration("/test-context.xml", loader = CustomContextLoader::class) <i class="conum" data-value="1"></i><b>(1)</b>
class CustomLoaderXmlApplicationContextTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>location과 custom loader를 모두 구성합니다.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@ContextConfiguration</code> 는 resource location 또는 configuration class의 상속은 물론 superclass 또는 enclosing class에 의해 선언된 context initializer를 제공합니다.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>자세한 내용은 <a href="#testcontext-ctx-management">Context Management</a>, <a href="#testcontext-junit-jupiter-nested-test-configuration"><code>@Nested</code> test class configuration</a>, 및 <code>@ContextConfiguration</code> javadoc을 참조하세요.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-webappconfiguration"><code>@WebAppConfiguration</code></h5>
<div class="paragraph">
<p><code>@WebAppConfiguration</code>  은 통합 테스트를 위해 로드된 <code>ApplicationContext</code> 가 <code>WebApplicationContext</code> 여야 함을 선언하는데 사용할 수 있는 class-level annotation 입니다.
<code>@WebAppConfiguration</code> 이 test class에 존재하기만 하면 web application의 root(resource base path)에 대한 <code>"file:src/main/webapp"</code> default value를 사용하여 <code>WebApplicationContext</code> 가 테스트용으로 로드됩니다.
resource base path는 테스트의 <code>WebApplicationContext</code> 에 대한 <code>ServletContext</code> 역할을 하는 <code>MockServletContext</code> 를 만드는데 사용됩니다.</p>
</div>
<div class="paragraph">
<p>다음 예는 <code>@WebAppConfiguration</code> annotation을 사용하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@WebAppConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class WebAppTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@WebAppConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class WebAppTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@WebAppConfiguration</code> annotation.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>기본 값을 재정의 하려면 implicit <code>value</code> attribute를 사용하여 다른 base resource path를 지정할 수 있습니다.
<code>classpath:</code> 및 <code>file:</code> resource prefix가 지원됩니다.
resource prefix가 제공되지 않으면 path는 file system resource로 간주됩니다.
다음 예는 classpath resource를 지정하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@WebAppConfiguration("classpath:test-web-resources") <i class="conum" data-value="1"></i><b>(1)</b>
class WebAppTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>classpath resource 지정.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@WebAppConfiguration("classpath:test-web-resources") <i class="conum" data-value="1"></i><b>(1)</b>
class WebAppTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>classpath resource 지정.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@WebAppConfiguration</code> 는 single test class 또는 test class hierarchy 내에서 <code>@ContextConfiguration</code> 와 함께 사용해야 합니다.
자세한 내용은 <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html"><code>@WebAppConfiguration</code></a> javadoc을 참조하세요.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-contexthierarchy"><code>@ContextHierarchy</code></h5>
<div class="paragraph">
<p><code>@ContextHierarchy</code> 는 통합 테스트를 위한 <code>ApplicationContext</code> instance의 hierarchy를 정의하는데 사용되는 class-level annotation 입니다.
<code>@ContextHierarchy</code> 는 하나 이상의 <code>@ContextConfiguration</code> instances 목록으로 선언되어야 하며, 각 instance는 context hierarchy의 level을 정의합니다.
다음 예는 single test class내에서 <code>@ContextHierarchy</code> 의 사용을 보여줍니다. (<code>@ContextHierarchy</code> 는 test class hierarchy 내에서도 사용할 수 있음):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextHierarchy({
    @ContextConfiguration("/parent-config.xml"),
    @ContextConfiguration("/child-config.xml")
})
class ContextHierarchyTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextHierarchy(
    ContextConfiguration("/parent-config.xml"),
    ContextConfiguration("/child-config.xml"))
class ContextHierarchyTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@WebAppConfiguration
@ContextHierarchy({
    @ContextConfiguration(classes = AppConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})
class WebIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@WebAppConfiguration
@ContextHierarchy(
        ContextConfiguration(classes = [AppConfig::class]),
        ContextConfiguration(classes = [WebConfig::class]))
class WebIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>test class hierarchy 내에서 지정된 level에 대한 context hierarchy 구성을 병합하거나 재정의해야하는 경우 class hierarchy의 각 해당 level에서 <code>@ContextConfiguration</code> 의 <code>name</code> attribute에 동일한 값을 제공하여 해당 level의 name을 명시적으로 지정해야 합니다.
추가 예제는 <a href="#testcontext-ctx-management-ctx-hierarchies">Context Hierarchies</a> 및 <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/context/ContextHierarchy.html"><code>@ContextHierarchy</code></a> javadoc을 참조하세요.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-activeprofiles"><code>@ActiveProfiles</code></h5>
<div class="paragraph">
<p><code>@ActiveProfiles</code> 통합 테스트를 위해 <code>ApplicationContext</code> 을 로드할 때 활성화 되어야 하는 bean definition profile을 선언하는데 사용되는 class-level annotation 입니다.</p>
</div>
<div class="paragraph">
<p>다음 예는 <code>dev</code> profile이 활성화 되어야 함을 나타냅니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@ActiveProfiles("dev") <i class="conum" data-value="1"></i><b>(1)</b>
class DeveloperTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>dev</code> profile이 활성화 되어야 함을 나타냅니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@ActiveProfiles("dev") <i class="conum" data-value="1"></i><b>(1)</b>
class DeveloperTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>dev</code> profile이 활성화 되어야 함을 나타냅니다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>다음 예는 <code>dev</code> 및 <code>integration</code> profile이 모두 활성화되어야 함을 나타냅니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@ActiveProfiles({"dev", "integration"}) <i class="conum" data-value="1"></i><b>(1)</b>
class DeveloperIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>dev</code> 및 <code>integration</code> profile이 활성화되어야 함을 나타냅니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@ActiveProfiles(["dev", "integration"]) <i class="conum" data-value="1"></i><b>(1)</b>
class DeveloperIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>dev</code> 및 <code>integration</code> profile이 활성화되어야 함을 나타냅니다.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@ActiveProfiles</code> 기본적으로 superclass 및 enclosing class에 의해 선언된 active bean profile 상속을 지원합니다.
또한 custom <a href="#testcontext-ctx-management-env-profiles-ActiveProfilesResolver"><code>ActiveProfilesResolver</code></a>를 구현하고 <code>@ActiveProfiles</code> 의 <code>resolver</code> attribute를 사용하여 등록함으로써 active bean definition profile을 programming 방식으로 해결할 수 있습니다.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>자세한 내용은 <a href="#testcontext-ctx-management-env-profiles">Context Configuration with Environment Profiles</a>, <a href="#testcontext-junit-jupiter-nested-test-configuration"><code>@Nested</code> test class configuration</a> 및 <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/context/ActiveProfiles.html"><code>@ActiveProfiles</code></a> javadoc을 참조하세요.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-testpropertysource"><code>@TestPropertySource</code></h5>
<div class="paragraph">
<p><code>@TestPropertySource</code> 는 통합 테스트를 위해 로드된 <code>ApplicationContext</code> 에 대해 <code>Environment</code> 안에서 <code>PropertySources</code> set에 추가할 properties file과 inline property의 localtion을 구성하는데 사용할 수 있는 class-level annotation 입니다.
다음 예제는 classpath에서 properties file을 선언하는 방법을 보여줍니다;</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@TestPropertySource("/test.properties") <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>classpath의 root에 있는 <code>test.properties</code> 에서 property를 가져옵니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@TestPropertySource("/test.properties") <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>classpath의 root에 있는 <code>test.properties</code> 에서 property를 가져옵니다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>다음 예제는 inline property를 선언하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@TestPropertySource(properties = { "timezone = GMT", "port: 4242" }) <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>timezone</code> 및 <code>port</code> property 선언.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@TestPropertySource(properties = ["timezone = GMT", "port: 4242"]) <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>timezone</code> 및 <code>port</code> property 선언.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>예제 및 자세한 내용은 <a href="#testcontext-ctx-management-property-sources">Context Configuration with Test Property Sources</a>를 참조하세요.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-dynamicpropertysource"><code>@DynamicPropertySource</code></h5>
<div class="paragraph">
<p><code>@DynamicPropertySource</code> 는 통합 테스트를 위해 로드된 <code>ApplicationContext</code> 에 대해  <code>Environment</code> 에서 <code>PropertySources</code> set에 추가할 <em>dynamic</em> property를 등록할 때 사용할 수 있는 method-level annotation 입니다.
Dynamic property는 property의 값을 미리 모르는 경우 유용합니다.
예를 들어 <a href="https://www.testcontainers.org/">Testcontainers</a> project에서 관리하는 container와 같은 외부 resource에서 property를 관리하는 경우입니다.</p>
</div>
<div class="paragraph">
<p>다음 예제는 dynamic property를 등록하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
class MyIntegrationTests {

    static MyExternalServer server = // ...

    @DynamicPropertySource <i class="conum" data-value="1"></i><b>(1)</b>
    static void dynamicProperties(DynamicPropertyRegistry registry) { <i class="conum" data-value="2"></i><b>(2)</b>
        registry.add("server.port", server::getPort); <i class="conum" data-value="3"></i><b>(3)</b>
    }

    // tests ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@DynamicPropertySource`와 함께 `static</code> method를 annotate 합니다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>DynamicPropertyRegistry</code> 를 argument 사용합니다.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>server에서 lazy하게 검색할 dynamic <code>server.port</code> property를 등록합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
class MyIntegrationTests {

    companion object {

        @JvmStatic
        val server: MyExternalServer = // ...

        @DynamicPropertySource <i class="conum" data-value="1"></i><b>(1)</b>
        @JvmStatic
        fun dynamicProperties(registry: DynamicPropertyRegistry) { <i class="conum" data-value="2"></i><b>(2)</b>
            registry.add("server.port", server::getPort) <i class="conum" data-value="3"></i><b>(3)</b>
        }
    }

    // tests ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@DynamicPropertySource`와 함께 `static</code> method를 annotate 합니다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>DynamicPropertyRegistry</code> 를 argument 사용합니다.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>server에서 lazy하게 검색할 dynamic <code>server.port</code> property를 등록합니다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>자세한 내용은 <a href="#testcontext-ctx-management-dynamic-property-sources">Context Configuration with Dynamic Property Sources</a>를 참조하세요.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-dirtiescontext"><code>@DirtiesContext</code></h5>
<div class="paragraph">
<p><code>@DirtiesContext</code> 는 테스트 실행 중 기본 Spring <code>ApplicationContext</code> 가 더럽혀졌음(어떤 방식으로 인해 수정되거나 손상되는 경우&#8201;&#8212;&#8201;예를 들어 singleton bean의 상태가 변경됨)을 의미하며 이는 종료가 되어야 합니다.
Application context가 dirty로 표시되면 test framework의 cache에서 제거되고 닫힙니다.
결과적으로 기본 Spring container는 동일한 configuration metadata를 가진 context가 필요한 모든 후속 테스트를 위해 rebuild 됩니다.</p>
</div>
<div class="paragraph">
<p>동일한 class 또는 class hierarchy 내에서 <code>@DirtiesContext</code> 를 class-level과 method-level annotation으로 모두 사용할 수 있습니다.
이러한 시나리오에서 <code>ApplicationContext</code> 은 구성된 <code>methodMode</code> 와 <code>classMode</code> 에 따라 current test class 전과 후에 annotation이 달린 method가 더러워진 것으로 표시됩니다.</p>
</div>
<div class="paragraph">
<p>다음 예는 다양한 configuration 시나리오에서 context가 더러워지는 시기를 설명합니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>current test class 전에 class mode가 <code>BEFORE_CLASS</code> 로 설정된 class에 선언되었을 때</p>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@DirtiesContext(classMode = BEFORE_CLASS) <i class="conum" data-value="1"></i><b>(1)</b>
class FreshContextTests {
    // some tests that require a new Spring container
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>current test class 이전의 context를 dirty 합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@DirtiesContext(classMode = BEFORE_CLASS) <i class="conum" data-value="1"></i><b>(1)</b>
class FreshContextTests {
    // some tests that require a new Spring container
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>current test class 이전의 context를 dirty 합니다.</td>
</tr>
</table>
</div>
</li>
<li>
<p>current test class 이후 class mode가 <code>AFTER_CLASS</code> (즉, default class mode)로 설정된 class에 선언되었을 때</p>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@DirtiesContext <i class="conum" data-value="1"></i><b>(1)</b>
class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>current test class 이후의 context를 dirty 합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@DirtiesContext <i class="conum" data-value="1"></i><b>(1)</b>
class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>current test class 이후의 context를 dirty 합니다.</td>
</tr>
</table>
</div>
</li>
<li>
<p>current test class의 각 test method 이전에 class mode가 <code>BEFORE_EACH_TEST_METHOD</code> 로 설정된 class에 선언되었을 때</p>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
class FreshContextTests {
    // some tests that require a new Spring container
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>각 test method 전에 context를 dirty 합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
class FreshContextTests {
    // some tests that require a new Spring container
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>각 test method 전에 context를 dirty 합니다.</td>
</tr>
</table>
</div>
</li>
<li>
<p>current test class 의 각 test method 이후에 class mode가 <code>AFTER_EACH_TEST_METHOD</code> 로 설정된 class에 선언되었을 때</p>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>각 test method 이후 context가 dirty 합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>각 test method 이후 context가 dirty 합니다.</td>
</tr>
</table>
</div>
</li>
<li>
<p>current test 전에 method mode가 `BEFORE_METHOD`로 설정된 method에 선언된 경우</p>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@DirtiesContext(methodMode = BEFORE_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
void testProcessWhichRequiresFreshAppCtx() {
    // some logic that requires a new Spring container
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>current test method 전에 context가 dirty 합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@DirtiesContext(methodMode = BEFORE_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWhichRequiresFreshAppCtx() {
    // some logic that requires a new Spring container
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>current test method 전에 context가 dirty 합니다.</td>
</tr>
</table>
</div>
</li>
<li>
<p>current test 이후 method mode가 <code>AFTER_METHOD</code> (즉, default method mode)로 설정된 method에 선언된 경우</p>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@DirtiesContext <i class="conum" data-value="1"></i><b>(1)</b>
@Test
void testProcessWhichDirtiesAppCtx() {
    // some logic that results in the Spring container being dirtied
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>current test method 이후 context가 dirty 합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@DirtiesContext <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWhichDirtiesAppCtx() {
    // some logic that results in the Spring container being dirtied
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>current test method 이후 context가 dirty 합니다.</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>context가 <code>@ContextHierarchy</code> 로 context hierarchy의 일부로 구성된 테스트에서 <code>@DirtiesContext</code> 를 사용하면 <code>hierarchyMode</code> flag를 사용하여 context cache가 삭제되는 방법을 제어할 수 있습니다.
기본적으로 현재 수준 뿐만 아니라 현재 테스트에 공통된 상위 context를 공유하는 다른 모든 context hierarchy를 포함하여 전체 알고리즘을 사용하여 context cache를 지웁니다.
공통 상위 context의 하위 hierarchy에 있는 모든 <code>ApplicationContext</code> instance는 context cache에서 제거되고 닫힙니다.
특정 사용 사례에 대한 전체 알고리즘이 과다한 경우 다음 예와 같이 더 간단한 현재 수준 알고리즘을 지정할 수 있습니다.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextHierarchy({
    @ContextConfiguration("/parent-config.xml"),
    @ContextConfiguration("/child-config.xml")
})
class BaseTests {
    // class body...
}

class ExtendedTests extends BaseTests {

    @Test
    @DirtiesContext(hierarchyMode = CURRENT_LEVEL) <i class="conum" data-value="1"></i><b>(1)</b>
    void test() {
        // some logic that results in the child context being dirtied
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>현재 수준 알고리즘을 사용합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextHierarchy(
    ContextConfiguration("/parent-config.xml"),
    ContextConfiguration("/child-config.xml"))
open class BaseTests {
    // class body...
}

class ExtendedTests : BaseTests() {

    @Test
    @DirtiesContext(hierarchyMode = CURRENT_LEVEL) <i class="conum" data-value="1"></i><b>(1)</b>
    fun test() {
        // some logic that results in the child context being dirtied
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>현재 수준 알고리즘을 사용합니다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>EXHAUSTIVE</code> 및 <code>CURRENT_LEVEL</code> 알고리즘에 대한 자세한 내용은 <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/annotation/DirtiesContext.HierarchyMode.html"><code>DirtiesContext.HierarchyMode</code></a> javadoc을 참조하세요.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-testexecutionlisteners"><code>@TestExecutionListeners</code></h5>
<div class="paragraph">
<p><code>@TestExecutionListeners</code> 는 <code>TestContextManager</code> 에 등록해야 하는 <code>TestExecutionListener</code> 구현을 구성하기 위한 class-level metadasta를 정의합니다.
일반적으로 <code>@TestExecutionListeners</code> 는 <code>@ContextConfiguration</code> 와 함께 사용됩니다.</p>
</div>
<div class="paragraph">
<p>다음 예제는 2개의 <code>TestExecutionListener</code> 구현을 등록하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@TestExecutionListeners({CustomTestExecutionListener.class, AnotherTestExecutionListener.class}) <i class="conum" data-value="1"></i><b>(1)</b>
class CustomTestExecutionListenerTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>2개의 <code>TestExecutionListener</code> 구현을 등록합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@TestExecutionListeners(CustomTestExecutionListener::class, AnotherTestExecutionListener::class) <i class="conum" data-value="1"></i><b>(1)</b>
class CustomTestExecutionListenerTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>2개의 <code>TestExecutionListener</code> 구현을 등록합니다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>기본적으로 <code>@TestExecutionListeners</code> 는 superclass 또는 enclosing class에서 listener 상속을 지원합니다.
예제 및 추가 세부사항은 <a href="#testcontext-junit-jupiter-nested-test-configuration"><code>@Nested</code> test class configuration</a> 및 <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/context/TestExecutionListeners.html"><code>@TestExecutionListeners</code> javadoc</a>을 참조하세요.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-recordapplicationevents"><code>@RecordApplicationEvents</code></h5>
<div class="paragraph">
<p><code>@RecordApplicationEvents</code> 는 <em>Spring TestContext Framework</em> 에 단일 테스트를 실행하는 동안 <code>ApplicationContext</code> 에 publish 된 모든 application event를 기록하도록 지시하는데 사용되는 class-level annotation 입니다.</p>
</div>
<div class="paragraph">
<p>기록된 event는 테스트 내에서 <code>ApplicationEvents</code> API를 통해 access 할 수 있습니다.</p>
</div>
<div class="paragraph">
<p>예제 및 추가 세부사항은 <a href="#testcontext-application-events">Application Events</a> 및 <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/context/event/RecordApplicationEvents.html"><code>@RecordApplicationEvents</code> javadoc</a> 을 참조하세요.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-commit"><code>@Commit</code></h5>
<div class="paragraph">
<p><code>@Commit</code> 은 transcation test method에 대한 transaction이 test method가 완료된 후 commit 되어야 함을 나타냅니다.
<code>@Commit`을 `@Rollback(false)</code> 의 대체로 사용하여 코드의 의도를 좀더 명시적으로 전달할 수 있습니다.
<code>@Rollback</code> 과 마찬가지로 <code>@Commit</code> 도 class-level 또는 method-level annotation으로 선언할 수 있습니다.</p>
</div>
<div class="paragraph">
<p>다음 예는 <code>@Commit</code> annotation을 사용하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Commit <i class="conum" data-value="1"></i><b>(1)</b>
@Test
void testProcessWithoutRollback() {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>테스트 결과를 데이터베이스에 commit 합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Commit <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWithoutRollback() {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>테스트 결과를 데이터베이스에 commit 합니다.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-rollback"><code>@Rollback</code></h5>
<div class="paragraph">
<p><code>@Rollback</code> 은 test method가 완료된 후 transaction test method에 대한 transaction을 rollback 해야하는지 여부를 나타냅니다.
<code>true</code> 인 경우 transaction이 rollback 되며 그렇지 않으면 commit 됩니다. (<a href="#spring-testing-annotation-commit"><code>@Commit</code></a> 참조)
Spring TestContext Framework에서 통합 테스트를 위한 rollback은 <code>@Rollback</code> 이 명시적으로 선언되지 않은 경우 기본적으로 <code>true</code> 로 설정됩니다.</p>
</div>
<div class="paragraph">
<p>class-level annotation으로 선언되면 <code>@Rollback</code> 은 test class hierarchy 내의 모든 test method에 대한 기본 rolllback 체계를 정의합니다.
method-level annotation으로 선언되면 <code>@Rollback</code> 은 특정 test method에 대한 rollback 체계를 정의하여 잠재적으로 class-level <code>@Rollback</code> 또는 <code>@Commit</code> 체계를 재정의합니다.</p>
</div>
<div class="paragraph">
<p>다음 예제에서는 test method의 결과가 rollback되지 않도록 합니다. (즉, 결과가 데이터베이스에 commit 됨):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Rollback(false) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
void testProcessWithoutRollback() {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>결과를 rollback 하지 않습니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Rollback(false) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWithoutRollback() {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>결과를 rollback 하지 않습니다.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-beforetransaction"><code>@BeforeTransaction</code></h5>
<div class="paragraph">
<p><code>@BeforeTransaction</code> 은 Spring의 <code>@Transactional</code> annotation을 사용하여 transaction 내에서 실행되도록 구성된 test method의 경우 annotation이 있는 method가 transaction이 시작되기 전에 실행되어야 함을 나타냅니다.
<code>@BeforeTransaction</code> method는 public일 필요는 없으며 Java 8 기반 interface default method에 선언될 수 있습니다.</p>
</div>
<div class="paragraph">
<p>다음 예는 <code>@BeforeTransaction</code> annotation을 사용하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@BeforeTransaction <i class="conum" data-value="1"></i><b>(1)</b>
void beforeTransaction() {
    // logic to be run before a transaction is started
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>transaction 이전에 method를 실행합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@BeforeTransaction <i class="conum" data-value="1"></i><b>(1)</b>
fun beforeTransaction() {
    // logic to be run before a transaction is started
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>transaction 이전에 method를 실행합니다.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-aftertransaction"><code>@AfterTransaction</code></h5>
<div class="paragraph">
<p><code>@AfterTransaction</code> 은 Spring의  <code>@Transactional</code> annotation을 사용하여  transaction 내에서 실행되도록 구성된 test method에 대한 transaction이 종료된 후 annotation이 달린 <code>void</code> method를 실행해야 함을 나타냅니다.
<code>@AfterTransaction</code> method는 <code>public</code> 일 필요는 없으며 Java 8 기반 interface default method에 선언될 수 있습니다.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@AfterTransaction <i class="conum" data-value="1"></i><b>(1)</b>
void afterTransaction() {
    // logic to be run after a transaction has ended
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>transaction 이후에 method를 실행합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@AfterTransaction <i class="conum" data-value="1"></i><b>(1)</b>
fun afterTransaction() {
    // logic to be run after a transaction has ended
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>transaction 이후에 method를 실행합니다.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-sql"><code>@Sql</code></h5>
<div class="paragraph">
<p><code>@Sql</code> 은 통합 테스트 중에 지정된 데이터베이스에 대해 실행될 SQL script를 구성하기 위해 test class 또는 test method에 annotation을 추가하는데 사용됩니다.
다음 예제는 사용방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Test
@Sql({"/test-schema.sql", "/test-user-data.sql"}) <i class="conum" data-value="1"></i><b>(1)</b>
void userTest() {
    // run code that relies on the test schema and test data
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>이 테스트를 위해 두 개의 script를 실행합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Test
@Sql("/test-schema.sql", "/test-user-data.sql") <i class="conum" data-value="1"></i><b>(1)</b>
fun userTest() {
    // run code that relies on the test schema and test data
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>이 테스트를 위해 두 개의 script를 실행합니다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>자세한 내용은 <a href="#testcontext-executing-sql-declaratively">Executing SQL scripts declaratively with @Sql</a>을 참조하세요.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-sqlconfig"><code>@SqlConfig</code></h5>
<div class="paragraph">
<p><code>@SqlConfig</code> 는 <code>@Sql</code> annotation으로 구성된 SQL script를 구문 분석하고 실행하는 방법을 결정하는데 사용되는 metadata를 정의합니다.
다음 예제는 사용 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Test
@Sql(
    scripts = "/test-user-data.sql",
    config = @SqlConfig(commentPrefix = "`", separator = "@@") <i class="conum" data-value="1"></i><b>(1)</b>
)
void userTest() {
    // run code that relies on the test data
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>SQL script에서 comment prefix와 separator를 설정합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Test
@Sql("/test-user-data.sql", config = SqlConfig(commentPrefix = "`", separator = "@@")) <i class="conum" data-value="1"></i><b>(1)</b>
fun userTest() {
    // run code that relies on the test data
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>SQL script에서 comment prefix와 separator를 설정합니다.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-sqlmergemode"><code>@SqlMergeMode</code></h5>
<div class="paragraph">
<p><code>@SqlMergeMode</code> 는 method-level <code>@Sql</code> 선언이 class-level <code>@Sql</code> 선언과 병합되는지 여부를 구성하기 위해 test class 또는 test method에 annotation을 추가하는 데 사용됩니다.
test class나 test method에서 <code>@SqlMergeMode</code> 가 선언되지 않으면 기본적으로 <code>OVERRIDE</code> merge mode가 사용됩니다.
<code>OVERRIDE</code> mode를 사용하면 method-level <code>@Sql</code> 선언이 class-level <code>@Sql</code> 선언을 효과적으로 재정의 합니다.</p>
</div>
<div class="paragraph">
<p>method-level <code>@SqlMergeMode</code> 선언은 class-level 선언을 재정의합니다.</p>
</div>
<div class="paragraph">
<p>다음 예제는 class level에서 <code>@SqlMergeMode</code> 을 사용하는 방법을 보여줍니다.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(TestConfig.class)
@Sql("/test-schema.sql")
@SqlMergeMode(MERGE) <i class="conum" data-value="1"></i><b>(1)</b>
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    void standardUserProfile() {
        // run code that relies on test data set 001
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>class의 모든 test method에 대해 <code>@Sql</code> merge mode를 <code>MERGE</code> 로 설정합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(TestConfig::class)
@Sql("/test-schema.sql")
@SqlMergeMode(MERGE) <i class="conum" data-value="1"></i><b>(1)</b>
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    fun standardUserProfile() {
        // run code that relies on test data set 001
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>class의 모든 test method에 대해 <code>@Sql</code> merge mode를 <code>MERGE</code> 로 설정합니다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>다음 예제는 method level에서 <code>@SqlMergeMode</code> 을 사용하는 방법을 보여줍니다.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(TestConfig.class)
@Sql("/test-schema.sql")
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    @SqlMergeMode(MERGE) <i class="conum" data-value="1"></i><b>(1)</b>
    void standardUserProfile() {
        // run code that relies on test data set 001
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>특정 test method에 대해 <code>@Sql</code> merge mode를 <code>MERGE</code> 로 설정합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(TestConfig::class)
@Sql("/test-schema.sql")
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    @SqlMergeMode(MERGE) <i class="conum" data-value="1"></i><b>(1)</b>
    fun standardUserProfile() {
        // run code that relies on test data set 001
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>특정 test method에 대해 <code>@Sql</code> merge mode를 <code>MERGE</code> 로 설정합니다.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-sqlgroup"><code>@SqlGroup</code></h5>
<div class="paragraph">
<p><code>@SqlGroup</code> 은 여러 <code>@Sql</code> annotation을 사용할 때 쓰이는 container annotation입니다.
<code>@SqlGroup</code> 을 사용하여 여러 개의 중첩된 <code>@Sql</code> annotation을 선언하거나 Java 8의 repeatable annotation 지원과 함께 사용할 수 있으며 , 여기서 <code>@Sql</code> 은 동일한 class나 method에서 여러 번 선언되어 이 container annotation을 암시적으로 생성할 수 있습니다.
다음 예는 SQL group을 선언하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Test
@SqlGroup({ <i class="conum" data-value="1"></i><b>(1)</b>
    @Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`")),
    @Sql("/test-user-data.sql")
)}
void userTest() {
    // run code that uses the test schema and test data
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>SQL script group을 선언합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Test
@SqlGroup( <i class="conum" data-value="1"></i><b>(1)</b>
    Sql("/test-schema.sql", config = SqlConfig(commentPrefix = "`")),
    Sql("/test-user-data.sql"))
fun userTest() {
    // run code that uses the test schema and test data
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>SQL script group을 선언합니다.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="integration-testing-annotations-standard">Standard Annotation Support</h4>
<div class="paragraph">
<p>다음 annotation은 Spring TestContest Framework의 모든 구성에 대한 standard semantic으로 지원됩니다.
이러한 annotation은 테스트에만 국한되지 않으며 Spring Framework 어느 곳에서나 사용할 수 있습니다.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Autowired</code></p>
</li>
<li>
<p><code>@Qualifier</code></p>
</li>
<li>
<p><code>@Value</code></p>
</li>
<li>
<p><code>@Resource</code> (javax.annotation) JSR-250가 있는 경우</p>
</li>
<li>
<p><code>@ManagedBean</code> (javax.annotation) JSR-250가 있는 경우</p>
</li>
<li>
<p><code>@Inject</code> (javax.inject) JSR-330가 있는 경우</p>
</li>
<li>
<p><code>@Named</code> (javax.inject) JSR-330가 있는 경우</p>
</li>
<li>
<p><code>@PersistenceContext</code> (javax.persistence) JPA가 있는 경우</p>
</li>
<li>
<p><code>@PersistenceUnit</code> (javax.persistence) JPA가 있는 경우</p>
</li>
<li>
<p><code>@Required</code></p>
</li>
<li>
<p><code>@Transactional</code> (org.springframework.transaction.annotation)
<em>with <a href="#testcontext-tx-attribute-support">제한된 attribute 지원</a></em></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">JSR-250 Lifecycle Annotations</div>
<div class="paragraph">
<p>Spring TestContext Framework에서는 <code>ApplicationContext</code> 에서 구성된 모든 application component에 standard semantic과 함께 <code>@PostConstruct</code> 및 <code>@PreDestroy</code> 를 사용할 수 있습니다.
하지만 이러한 lifecycle annotation은 실제 test class 내에서 제한적으로 사용됩니다.</p>
</div>
<div class="paragraph">
<p>test class 내의 method에 <code>@PostConstruct</code> annotation이 달린 경우 해당 method는 기본 test framework의 어떤 method 보다 먼저 실행되며 (예 : JUnit Jupiter의 <code>@BeforeEach</code> annotation이 달린 method) test class의 모든 test method에 적용됩니다.
반면 test class 내의 method에 <code>@PreDestroy</code> annotation이 달린 경우 해당 method는 실행되지 않습니다.
따라서 test class 내에서 <code>@PostConstruct</code> 및 <code>@PreDestroy</code> 대신 기본 test framework에서 test lifecycle callback을 사용하는 것이 좋습니다.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="integration-testing-annotations-junit4">Spring JUnit 4 Testing Annotations</h4>
<div class="paragraph">
<p>다음 annotation은 <a href="#testcontext-junit4-runner">SpringRunner</a>, <a href="#testcontext-junit4-rules">Spring&#8217;s JUnit 4 rules</a>, 또는 <a href="#testcontext-support-classes-junit4">Spring&#8217;s JUnit 4 support classes</a> 와 함께 사용되는 경우에만 지원됩니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#integration-testing-annotations-junit4-ifprofilevalue"><code>@IfProfileValue</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit4-profilevaluesourceconfiguration"><code>@ProfileValueSourceConfiguration</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit4-timed"><code>@Timed</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit4-repeat"><code>@Repeat</code></a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit4-ifprofilevalue"><code>@IfProfileValue</code></h5>
<div class="paragraph">
<p><code>@IfProfileValue</code> 은 해당 annotation이 달린 테스트가 특정 테스트 환경에 대해 활성화 됨을 나타냅니다.
구성된 <code>ProfileValueSource</code> 가 제공된 <code>name</code> 에 일치하는 <code>value</code> 를 반환하는 경우 테스트가 활성화됩니다.</p>
</div>
<div class="paragraph">
<p><code>@IfProfileValue</code> 는 class level, method level 또는 둘다 적용할 수 있습니다.
<code>@IfProfileValue</code> 의 class-level 사용은 해당 class 또는 subclass 내의 모든 method에 대한 method-level 사용보다 우선합니다.
특히 class level 과 method level에서 모두 활성화되면 테스트가 활성화됩니다.
<code>@IfProfileValue</code> 가 없으면 테스트가 암묵적으로 활성화 되었음을 의미합니다.
이것은 <code>@Ignore</code> 가 존재하면 항상 테스트가 비활성화 된다는 점을 제외하면 JUnit 4의 <code>@Ignore</code> annotation의 의미와 유사합니다.</p>
</div>
<div class="paragraph">
<p>다음 예는 <code>@IfProfileValue</code> annotation이 있는 테스트를 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@IfProfileValue(name="java.vendor", value="Oracle Corporation") <i class="conum" data-value="1"></i><b>(1)</b>
@Test
public void testProcessWhichRunsOnlyOnOracleJvm() {
    // some logic that should run only on Java VMs from Oracle Corporation
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Java vendor가 "Oracle Corporation" 인 경우에만 테스트가 실행됩니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@IfProfileValue(name="java.vendor", value="Oracle Corporation") <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWhichRunsOnlyOnOracleJvm() {
    // some logic that should run only on Java VMs from Oracle Corporation
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Java vendor가 "Oracle Corporation" 인 경우에만 테스트가 실행됩니다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>또는 <code>values</code> 목록 (<code>OR</code> 의미 포함)과 함께 <code>@IfProfileValue</code> 를 구성하여 JUnit 4 환경에서 test group을 TestNG 처럼 지원할 수 있습니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@IfProfileValue(name="test-groups", values={"unit-tests", "integration-tests"}) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
public void testProcessWhichRunsForUnitOrIntegrationTestGroups() {
    // some logic that should run only for unit and integration test groups
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>unit tests 및 integration tests를 위해 이 테스트를 실행합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@IfProfileValue(name="test-groups", values=["unit-tests", "integration-tests"]) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWhichRunsForUnitOrIntegrationTestGroups() {
    // some logic that should run only for unit and integration test groups
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>unit tests 및 integration tests를 위해 이 테스트를 실행합니다.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit4-profilevaluesourceconfiguration"><code>@ProfileValueSourceConfiguration</code></h5>
<div class="paragraph">
<p><code>@ProfileValueSourceConfiguration</code> 은  <code>@IfProfileValue</code> annotation을 통해 구성된 profile value를 검색 할 때 사용할 <code>ProfileValueSource</code> 의 유형을 지정하는 class-level annotation 입니다.
테스트에 대해 <code>@ProfileValueSourceConfiguration</code> 이 선언되지 않은 경우 기본적으로 <code>SystemProfileValueSource</code> 가 사용됩니다.
다음 예는 <code>@ProfileValueSourceConfiguration</code> 을 사용하는 방법을 보여줍니다.:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ProfileValueSourceConfiguration(CustomProfileValueSource.class) <i class="conum" data-value="1"></i><b>(1)</b>
public class CustomProfileValueSourceTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>custom profile value source를 사용합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ProfileValueSourceConfiguration(CustomProfileValueSource::class) <i class="conum" data-value="1"></i><b>(1)</b>
class CustomProfileValueSourceTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>custom profile value source를 사용합니다.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit4-timed"><code>@Timed</code></h5>
<div class="paragraph">
<p><code>@Timed</code> 는 해당 annotation이 달린 test method가 지정된 기간 내에(millisecond 안에) 실행을 완료해야 함을 나타냅니다.
테스트 실행 시간이 지정된 시간을 초과하면 테스트가 실패합니다.</p>
</div>
<div class="paragraph">
<p>time period에는 test method 자체 실행. rest repeat (<code>@Repeat</code> 참조), test fixture 설정 또는 해제가 포함됩니다.
다음 예제는 사용 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Timed(millis = 1000) <i class="conum" data-value="1"></i><b>(1)</b>
public void testProcessWithOneSecondTimeout() {
    // some logic that should not take longer than 1 second to run
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>테스트 기간을 1초로 설정합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Timed(millis = 1000) <i class="conum" data-value="1"></i><b>(1)</b>
fun testProcessWithOneSecondTimeout() {
    // some logic that should not take longer than 1 second to run
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>테스트 기간을 1초로 설정합니다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring의 <code>@Timed</code> annotation은 JUnit 4의 <code>@Test(timeout=&#8230;&#8203;)</code> 지원과 다른 의미를 가지고 있습니다.
특히 JUnit4가 테스트 실행 시간 초과(즉, 별도의 <code>Thread</code> 에서 test method를 실행하여)를 처리하는 방식으로 인해 <code>@Test(timeout=&#8230;&#8203;)</code> 는 테스트가 너무 오래 걸릴 경우 선제적으로 테스트를 실패처리합니다.
반면에 Spring의 <code>@Timed</code> 는 선제적으로 fail 처리를 하지 않고 test가 종료되기를 기다렸다가 fail 처리를 합니다.</p>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit4-repeat"><code>@Repeat</code></h5>
<div class="paragraph">
<p><code>@Repeat</code> 는 해당 annotation이 달린 test method를 반복적으로 실행해야 함을 나타냅니다.
test method가 실행되는 횟수는 annotation에 지정됩니다.</p>
</div>
<div class="paragraph">
<p>반복되는 실행 범위에는 test method 자체의 실행과 test fixture의 설정 또는 해제가 포함됩니다.
다음 예는 <code>@Repeat</code> annotation을 사용하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Repeat(10) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
public void testProcessRepeatedly() {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>이 테스트를 10번 반복합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Repeat(10) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessRepeatedly() {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>이 테스트를 10번 반복합니다.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="integration-testing-annotations-junit-jupiter">Spring JUnit Jupiter Testing Annotations</h4>
<div class="paragraph">
<p>다음 annotation은 <a href="#testcontext-junit-jupiter-extension"><code>SpringExtension</code></a> 및 JUnit Jupiter(JUnit 5의 programming model)와 함께 사용될 때 지원됩니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#integration-testing-annotations-junit-jupiter-springjunitconfig"><code>@SpringJUnitConfig</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit-jupiter-springjunitwebconfig"><code>@SpringJUnitWebConfig</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-testconstructor"><code>@TestConstructor</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-nestedtestconfiguration"><code>@NestedTestConfiguration</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit-jupiter-enabledif"><code>@EnabledIf</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit-jupiter-disabledif"><code>@DisabledIf</code></a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit-jupiter-springjunitconfig"><code>@SpringJUnitConfig</code></h5>
<div class="paragraph">
<p><code>@SpringJUnitConfig</code> 는 JUnit Jupiter의 <code>@ExtendWith(SpringExtension.class)</code> 과 Spring TestContext Framework의 <code>@ContextConfiguration</code> 을 결합하여 구성된 annotation입니다.
class level에서 <code>@ContextConfiguration</code> 을 대체하여 사용할 수 있습니다.
<code>@ContextConfiguration</code> 과 <code>@SpringJUnitConfig</code> 사이의 유일한 차이점은 <code>@SpringJUnitConfig</code> 는 component class를 <code>value</code> attribute로 선언할 수 있다는 것입니다.</p>
</div>
<div class="paragraph">
<p>다음 예제는 <code>@SpringJUnitConfig</code> annotation을 사용하여 configuration class를 지정하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(TestConfig.class) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigurationClassJUnitJupiterSpringTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>configuration class를 지정합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(TestConfig::class) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigurationClassJUnitJupiterSpringTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>configuration class를 지정합니다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>다음 예제는 <code>@SpringJUnitConfig</code> annotation을 사용하여 configuration file의 location을 지정하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(locations = "/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class XmlJUnitJupiterSpringTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>configuration file의 location을 지정합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(locations = ["/test-config.xml"]) <i class="conum" data-value="1"></i><b>(1)</b>
class XmlJUnitJupiterSpringTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>configuration file의 location을 지정합니다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>자세한 내용은 <a href="#testcontext-ctx-management">Context Management</a>, <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/context/junit/jupiter/SpringJUnitConfig.html"><code>@SpringJUnitConfig</code></a> javadoc 및 `@ContextConfiguration`을 참조하세요.</p>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit-jupiter-springjunitwebconfig"><code>@SpringJUnitWebConfig</code></h5>
<div class="paragraph">
<p><code>@SpringJUnitWebConfig</code> 는 JUnit Jupiter의 <code>@ExtendWith(SpringExtension.class)</code> 과 Spring TestContext Framework의 <code>@ContextConfiguration</code> 및 <code>@WebAppConfiguration</code> 을 결합하여 구성된 annotation입니다.
class level에서 <code>@ContextConfiguration</code> 및 <code>@WebAppConfiguration</code> 을 대체하여 사용할 수 있습니다.
<code>@ContextConfiguration</code> 과 <code>@SpringJUnitWebConfig</code> 사이의 유일한 차이점은 <code>@SpringJUnitWebConfig</code> 는 component class를 <code>value</code> attribute로 선언할 수 있다는 것입니다.
또한 <code>@WebAppConfiguration</code> 의 <code>value</code> attribute를 <code>@SpringJUnitWebConfig</code> 에서 <code>resourcePath</code> attribute를 사용하여 재정의할 수 있습니다.</p>
</div>
<div class="paragraph">
<p>다음 예제는 <code>@SpringJUnitWebConfig</code> annotation를 사용하여 configuration class를 지정하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitWebConfig(TestConfig.class) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigurationClassJUnitJupiterSpringWebTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>configuration class을 지정합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitWebConfig(TestConfig::class) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigurationClassJUnitJupiterSpringWebTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>configuration class을 지정합니다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>다음 예제는 <code>@SpringJUnitWebConfig</code> annotation을 사용하여 configuration file의 location을 지정하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitWebConfig(locations = "/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class XmlJUnitJupiterSpringWebTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>configuration file의 location을 지정합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitWebConfig(locations = ["/test-config.xml"]) <i class="conum" data-value="1"></i><b>(1)</b>
class XmlJUnitJupiterSpringWebTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>configuration file의 location을 지정합니다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>자세한 내용은 <a href="#testcontext-ctx-management">Context Management</a>, <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/context/junit/jupiter/web/SpringJUnitWebConfig.html"><code>@SpringJUnitWebConfig</code></a>, <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/context/ContextConfiguration.html"><code>@ContextConfiguration</code></a>, 및 <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html"><code>@WebAppConfiguration</code></a>의 javadoc을 참조하세요.</p>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-testconstructor"><code>@TestConstructor</code></h5>
<div class="paragraph">
<p><code>@TestConstructor</code> 은 test class construct의 parameter를 테스트의 <code>ApplicationContext</code> 의 component로부터 autowired 되는 방식을 구성하는데 사용되는 type-level annotation 입니다.
<code>@TestConstructor</code> is a type-level annotation that is used to configure how the parameters of a test class constructor are autowired from components in the test&#8217;s <code>ApplicationContext</code>.</p>
</div>
<div class="paragraph">
<p><code>@TestConstructor</code> 가 없거나 test class에 meta가 있는 경우 기본적으로 <em>test constructor autowire mode</em> 가 사용됩니다.
default mode를 변경하는 방법에 대한 자세한 내용은 아래 tip을 참조하세요.
그러나 constructor에 대한 <code>@Autowired</code> 의 local 선언이 <code>@TestConstructor</code> 와 default mode보다 우선한다는 점에 유의하세요.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Changing the default test constructor autowire mode</div>
<div class="paragraph">
<p>기본 <em>test constructor autowire mode</em> 는 <code>spring.test.constructor.autowire.mode</code> JVM system property를 <code>all</code> 로 설정하여 변경할 수 있습니다.
또는 <a href="appendix.html#appendix-spring-properties"><code>SpringProperties</code></a> 메커니즘을 통해 default mode를 설정할 수 있습니다.</p>
</div>
<div class="paragraph">
<p>Spring Framework 5.3부터 defaut mode는 <a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-config-params">JUnit Platform configuration parameter</a>로 구성될 수도 있습니다.</p>
</div>
<div class="paragraph">
<p>만약 <code>spring.test.constructor.autowire.mode</code> property가 설정되지 않은 경우 test class constructor는 autowired가 자동으로 처리되지 않습니다.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Framework 5.2부터 @TestConstructor` 는 JUnit Jupiter과 함께 사용하기 위한 <code>SpringExtension</code> 과 결합만 지원됩니다.
Spring Boot Test에서 <code>@SpringJUnitConfig</code> 및 <code>@SpringJUnitWebConfig</code> 또는 다양한 test관련 annotation을 사용할 때 <code>SpringExtension</code> 은 자동으로 등록되는 경우가 많습니다.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-nestedtestconfiguration"><code>@NestedTestConfiguration</code></h5>
<div class="paragraph">
<p><code>@NestedTestConfiguration</code> 은 inner test class를 위한 enclosing class hierarchy 에서 Spring test configuration annotation이 처리되는 방식을 구성하는데 사용되는 type-level annotaion 입니다.</p>
</div>
<div class="paragraph">
<p><code>@NestedTestConfiguration</code> 가 test class, super type hierarchy 또는 enclosing class hierarchy에 없거나 meta가 포함되어 있는 경우 default <em>enclosing configuration inheritance mode</em> 가 사용됩니다.
default mode를 변경하는 방법에 대한 자세한 내용은 아래 tip을 참조하세요.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Changing the default enclosing configuration inheritance mode</div>
<div class="paragraph">
<p>default <em>enclosing configuration inheritance mode</em> 는 <code>INHERIT</code> 이지만 <code>spring.test.enclosing.configuration</code> JVM system property를 <code>OVERRIDE</code> 로 설정하여 변경할 수 있습니다.
또는 default mode는 <a href="appendix.html#appendix-spring-properties"><code>SpringProperties</code></a> 매커니즘을 통해 default mode를 설정할 수 있습니다.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="#testcontext-framework">Spring TestContext Framework</a>는 다음 annotation에 대해 <code>@NestedTestConfiguration</code> semantic을 존중합니다.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#spring-testing-annotation-bootstrapwith"><code>@BootstrapWith</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-contextconfiguration"><code>@ContextConfiguration</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-webappconfiguration"><code>@WebAppConfiguration</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-contexthierarchy"><code>@ContextHierarchy</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-activeprofiles"><code>@ActiveProfiles</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-testpropertysource"><code>@TestPropertySource</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-dynamicpropertysource"><code>@DynamicPropertySource</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-dirtiescontext"><code>@DirtiesContext</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-testexecutionlisteners"><code>@TestExecutionListeners</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-recordapplicationevents"><code>@RecordApplicationEvents</code></a></p>
</li>
<li>
<p><a href="#testcontext-tx"><code>@Transactional</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-commit"><code>@Commit</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-rollback"><code>@Rollback</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-sql"><code>@Sql</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-sqlconfig"><code>@SqlConfig</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-sqlmergemode"><code>@SqlMergeMode</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-testconstructor"><code>@TestConstructor</code></a></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@NestedTestConfiguration</code> 의 사용은 일반적으로 JUnit Jupiter의 <code>@Nested</code> test classes와 함께 사용하는 경우에만 의미가 있습니다.
그러나 이 annotation을 사용하는 Spring 및 nested test class를 지원하는 다른 test framework가 있을 수 있습니다.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>예제 및 자세한 내용은 <a href="#testcontext-junit-jupiter-nested-test-configuration"><code>@Nested</code> test class configuration</a>을 참조하세요.</p>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit-jupiter-enabledif"><code>@EnabledIf</code></h5>
<div class="paragraph">
<p><code>@EnabledIf</code> 는 annotation이 달린 JUnit Jupiter test class 또는 test method가 활성화 되었음을 알리는데 사용되며 제공된 <code>expression</code> 이 <code>true</code> 로 평가되면 실행되어야 합니다.
특히 표현식이 <code>Boolean.TRUE</code> 또는 <code>true</code> 와 같은 <code>String</code> (대소문자 무시)으로 평가되면 테스트가 활성화됩니다.
class level에서 적용하면 해당 class 내의 모든 test method도 기본적으로 자동으로 활성화됩니다.</p>
</div>
<div class="paragraph">
<p>표현식은 다음 중 하나일 수 있습니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="core.html#expressions">Spring Expression Language</a> (SpEL) expression. 예를 들면:
<code>@EnabledIf("#{systemProperties['os.name'].toLowerCase().contains('mac')}")</code></p>
</li>
<li>
<p>Placeholder for a property available in the Spring <a href="core.html#beans-environment"><code>Environment</code></a>.
예를 들면: <code>@EnabledIf("${smoke.tests.enabled}")</code></p>
</li>
<li>
<p>Text literal. 예를 들면: <code>@EnabledIf("true")</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>그러나 <code>@EnabledIf("false")</code> 는 <code>@Disabled</code> 와 같고 <code>@EnabledIf("true")</code> 는 논리적으로 의미가 없기 때문에 property placeholder의 동적 확인 결과가 아닌 text literal은 값이 zero practical value입니다. .</p>
</div>
<div class="paragraph">
<p><code>@EnabledIf</code> 를 meta-annotation으로 사용하여 custom composed annotation을 만들 수 있습니다.
예를 들어 다음과 같이 custom <code>@EnabledOnMac</code> annotation을 만들 수 있습니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@EnabledIf(
    expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
    reason = "Enabled on Mac OS"
)
public @interface EnabledOnMac {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
@EnabledIf(
        expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
        reason = "Enabled on Mac OS"
)
annotation class EnabledOnMac {}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit-jupiter-disabledif"><code>@DisabledIf</code></h5>
<div class="paragraph">
<p><code>@DisabledIf</code> 는 annotation이 달린 JUnit Jupiter test class 또는 test method가 비활성화 되었음을 알리는데 사용되며 제공된 <code>expression</code> 이 <code>true</code> 로 평가되면 실행되서는 안됩니다.
특히 표현식이 <code>Boolean.TRUE</code> 또는 <code>true</code> 와 같은 <code>String</code> (대소문자 무시)로 평가되면 테스트가 비활성화됩니다.
class level에서 적용하면 해당 class 내의 모든 test method도 기본적으로 자동으로 비활성화됩니다.</p>
</div>
<div class="paragraph">
<p>표현식은 다음 중 하나일 수 있습니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="core.html#expressions">Spring Expression Language</a> (SpEL) expression. 예를 들면:
<code>@DisabledIf("#{systemProperties['os.name'].toLowerCase().contains('mac')}")</code></p>
</li>
<li>
<p>Placeholder for a property available in the Spring <a href="core.html#beans-environment"><code>Environment</code></a>.
예를 들면: <code>@DisabledIf("${smoke.tests.disabled}")</code></p>
</li>
<li>
<p>Text literal. 예를 들면: <code>@DisabledIf("true")</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>그러나 <code>@DisabledIf("true")</code> 는 <code>@Disabled</code> 와 같고 <code>@DisabledIf("false")</code> 는 논리적으로 의미가 없으므로 property placeholder의 동적 확인 결과가 아닌 텍스트 리터럴은 값이 zero practical value입니다. .</p>
</div>
<div class="paragraph">
<p><code>@DisabledIf</code> 를 meta-annotation으로 사용하여 custom composed annotation을 만들 수 있습니다.
예를 들어 다음과 같이 custom <code>@DisabledOnMac</code> annotation을 만들 수 있습니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@DisabledIf(
    expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
    reason = "Disabled on Mac OS"
)
public @interface DisabledOnMac {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
@DisabledIf(
        expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
        reason = "Disabled on Mac OS"
)
annotation class DisabledOnMac {}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="integration-testing-annotations-meta">Meta-Annotation Support for Testing</h4>
<div class="paragraph">
<p>대부분의 테스트 관련 annotation을 <a href="core.html#beans-meta-annotations">meta-annotations</a>으로 사용하여 custom composed annotation을 만들고 test suite에서 구성 중복을 줄일 수 있습니다.</p>
</div>
<div class="paragraph">
<p><a href="#testcontext-framework">TestContext framework</a>와 함께 다음 각 항목을 meta-annotation으로 사용할 수 있습니다.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@BootstrapWith</code></p>
</li>
<li>
<p><code>@ContextConfiguration</code></p>
</li>
<li>
<p><code>@ContextHierarchy</code></p>
</li>
<li>
<p><code>@ActiveProfiles</code></p>
</li>
<li>
<p><code>@TestPropertySource</code></p>
</li>
<li>
<p><code>@DirtiesContext</code></p>
</li>
<li>
<p><code>@WebAppConfiguration</code></p>
</li>
<li>
<p><code>@TestExecutionListeners</code></p>
</li>
<li>
<p><code>@Transactional</code></p>
</li>
<li>
<p><code>@BeforeTransaction</code></p>
</li>
<li>
<p><code>@AfterTransaction</code></p>
</li>
<li>
<p><code>@Commit</code></p>
</li>
<li>
<p><code>@Rollback</code></p>
</li>
<li>
<p><code>@Sql</code></p>
</li>
<li>
<p><code>@SqlConfig</code></p>
</li>
<li>
<p><code>@SqlMergeMode</code></p>
</li>
<li>
<p><code>@SqlGroup</code></p>
</li>
<li>
<p><code>@Repeat</code> <em>(JUnit 4에서만 지원됨)</em></p>
</li>
<li>
<p><code>@Timed</code> <em>(JUnit 4에서만 지원됨)</em></p>
</li>
<li>
<p><code>@IfProfileValue</code> <em>(JUnit 4에서만 지원됨)</em></p>
</li>
<li>
<p><code>@ProfileValueSourceConfiguration</code> <em>(JUnit 4에서만 지원됨)</em></p>
</li>
<li>
<p><code>@SpringJUnitConfig</code> <em>(JUnit Jupiter에서만 지원됨)</em></p>
</li>
<li>
<p><code>@SpringJUnitWebConfig</code> <em>(JUnit Jupiter에서만 지원됨)</em></p>
</li>
<li>
<p><code>@TestConstructor</code> <em>(JUnit Jupiter에서만 지원됨)</em></p>
</li>
<li>
<p><code>@NestedTestConfiguration</code> <em>(JUnit Jupiter에서만 지원됨)</em></p>
</li>
<li>
<p><code>@EnabledIf</code> <em>(JUnit Jupiter에서만 지원됨)</em></p>
</li>
<li>
<p><code>@DisabledIf</code> <em>(JUnit Jupiter에서만 지원됨)</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>다음 예를 고려하십시오:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RunWith(SpringRunner.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public class OrderRepositoryTests { }

@RunWith(SpringRunner.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@RunWith(SpringRunner::class)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
class OrderRepositoryTests { }

@RunWith(SpringRunner::class)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>JUnit 4 기반 test suite에서 이전 구성을 반복하고 있음을 발견하면 다음과 같이 Spring의 common test configuration을 중앙 집중화하는 custom composed annotation을 도입하여 중복을 줄일 수 있습니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public @interface TransactionalDevTestConfig { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Target(AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
annotation class TransactionalDevTestConfig { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>그런 다음 custom <code>@TransactionalDevTestConfig</code> annotation을 사용하여 다음과 같이 개별 JUnit 4 기반 test class의 구성을 단순화 할 수 있습니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RunWith(SpringRunner.class)
@TransactionalDevTestConfig
public class OrderRepositoryTests { }

@RunWith(SpringRunner.class)
@TransactionalDevTestConfig
public class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@RunWith(SpringRunner::class)
@TransactionalDevTestConfig
class OrderRepositoryTests

@RunWith(SpringRunner::class)
@TransactionalDevTestConfig
class UserRepositoryTests</code></pre>
</div>
</div>
<div class="paragraph">
<p>JUnit Jupiter를 사용하는 테스트를 작성하면 JUnit 5의 annotation을 meta-annotation으로도 사용할 수 있으므로 코드 중복을 더욱 줄일 수 있습니다.
다음 예를 고려하십시오:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
class OrderRepositoryTests { }

@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
class OrderRepositoryTests { }

@ExtendWith(SpringExtension::class)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>JUnit Jupiter 기반 test suite에서 이전 구성을 반복하고 있음을 발견하면 다음과 같이 Spring 및 JUnit Jupiter의 common test configuration을 중앙 집중화하는 custom composed annotation을 도입하여 중복을 줄일 수 있습니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public @interface TransactionalDevTestConfig { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Target(AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@ExtendWith(SpringExtension::class)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
annotation class TransactionalDevTestConfig { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>그런 다음 custom <code>@TransactionalDevTestConfig</code> annotation을 사용하여 다음과 같이 개별 JUnit Jupiter 기반 test class의 구성을 단순화 할 수 있습니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@TransactionalDevTestConfig
class OrderRepositoryTests { }

@TransactionalDevTestConfig
class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@TransactionalDevTestConfig
class OrderRepositoryTests { }

@TransactionalDevTestConfig
class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>JUnit Jupiter는 <code>@Test</code>, <code>@RepeatedTest</code>, <code>ParameterizedTest</code> 및 다른 meta-annotation의 사용을 지원하므로 test method 수준에서 custom composed annotation을 만들 수도 있습니다.
예를 들어 JUnit Jupiter의 <code>@Test</code> 및 <code>@Tag</code> annotation을 Spring의 <code>@Transactional</code> annotation과 결합하는 composed annotation을 작성하려는 경우 다음과 같이 <code>@TransactionalIntegrationTest</code> annotation을 작성할 수 있습니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Transactional
@Tag("integration-test") // org.junit.jupiter.api.Tag
@Test // org.junit.jupiter.api.Test
public @interface TransactionalIntegrationTest { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Target(AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@Transactional
@Tag("integration-test") // org.junit.jupiter.api.Tag
@Test // org.junit.jupiter.api.Test
annotation class TransactionalIntegrationTest { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>그런 다음 custom <code>@TransactionalIntegrationTest</code> annotation을 사용하여 다음과 같이 개별 JUnit Jupiter 기반 test method의 구성을 단순화 할 수 있습니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@TransactionalIntegrationTest
void saveOrder() { }

@TransactionalIntegrationTest
void deleteOrder() { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@TransactionalIntegrationTest
fun saveOrder() { }

@TransactionalIntegrationTest
fun deleteOrder() { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>자세한 내용은 <a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model">Spring Annotation Programming Model</a> wiki page를 참조하세요.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="testcontext-framework">Spring TestContext Framework</h3>
<div class="paragraph">
<p>Spring TestContext Framework (<code>org.springframework.test.context</code> package에 위치함)는 사용중인 test framework와 무관한 일반적인 annotation 기반 단위 및 통합 테스트 지원을 제공합니다.
TestContext framework는 또한 annotation 기반 구성을 통해 재정의 할 수 있는 합리적인 기본값을 사용하여 구성에 대한 규칙을 중요시 합니다.</p>
</div>
<div class="paragraph">
<p>일반 test infrastructure 외에도 TestContext framework는 JUnit 4, JUnit Jupiter (AKA JUnit 5), 및 TestNG에 대한 명시적인 지원을 제공합니다.
JUnit 4 및 TestNG의 경우 Spring은 <code>abstract</code> support class를 제공합니다.
또한 Spring은 custom JUnit <code>Runner</code> 및 JUnit 4 용 custom <code>Rules</code> 및 소위 POJO test class를 작성할 수있는 JUnit Jupiter 용 custom <code>Extension`을 제공합니다.
POJO test class는 `abstract</code> support class와 같은 특정 class hierarchy를 확장하는데 필요하지 않습니다.</p>
</div>
<div class="paragraph">
<p>다음 section에서는 TestContext framework의 내부에 대한 개요를 제공합니다.
framework의 사용에만 관심이 있고 custom listener 또는 custom loader로 확장하는데 관심이 없는 경우 configuration (<a href="#testcontext-ctx-management">context management</a>, <a href="#testcontext-fixture-di">dependency injection</a>, <a href="#testcontext-tx">transaction management</a>), <a href="#testcontext-support-classes">support classes</a> 및 <a href="#integration-testing-annotations">annotation support</a> section으로 직접 이동하세요.</p>
</div>
<div class="sect3">
<h4 id="testcontext-key-abstractions">Key Abstractions</h4>
<div class="paragraph">
<p>framework의 핵심은 <code>TestContextManager</code> class 와 <code>TestContext</code>, <code>TestExecutionListener</code> 및 <code>SmartContextLoader</code> interfaces로 구성됩니다.
<code>TestContextManager</code> 는 각 test class에 대해 생성됩니다. (예: JUnit Jupiter의 단일 test class 내에서 모든 test method를 실행하는 경우)
<code>TestContextManager</code> 는 차례로 현재 테스트의 context를 보유하는 <code>TestContext`를 관리합니다.
`TestContextManager</code> 는 또한 테스트가 진행됨에 따라 <code>TestContext</code> 의 상태를 업데이트하고 <code>TestExecutionListener</code> 구현에 위임합니다.
이 구현은 dependency injection, managing transactions 등을 통해 실제 테스트 실행을 계측합니다.
<code>SmartContextLoader</code> 는 주어진 test class에 대한 <code>ApplicationContext</code> 을 로드하는 역할을 합니다.
다양한 구현에 대한 추가 정보와 예제는 <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/context/package-summary.html">javadoc</a> 및 Spring test suite를 참조하세요.</p>
</div>
<div class="sect4">
<h5 id="_testcontext"><code>TestContext</code></h5>
<div class="paragraph">
<p><code>TestContext</code> 는 테스트가 실행되는 context를 캡슐화하고 (사용 중인 실제 테스트 프레임 워크에 관계없이) 해당 테스트 인스턴스에 대한 context 관리 및 캐싱 지원을 제공합니다.
<code>TestContext</code> 는 또한 요청 된 경우 <code>ApplicationContext`를 로드하도록 `SmartContextLoader</code> 에 위임합니다.</p>
</div>
</div>
<div class="sect4">
<h5 id="_testcontextmanager"><code>TestContextManager</code></h5>
<div class="paragraph">
<p><code>TestContextManager</code> 는 Spring TestContext Framework의 주요 진입점이며 단일 <code>TestContext</code> 를 관리하고 잘 정의된 test 실행 지점에서 등록된 <code>TestExecutionListener</code> 에 이벤트 신호를 보내는 역할을 합니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>특정 test framework의 &#8220;before class&#8221; 또는 &#8220;before all&#8221; method 이전</p>
</li>
<li>
<p>Test instance 이후 처리</p>
</li>
<li>
<p>특정 test framework의 &#8220;before&#8221; 또는 &#8220;before each&#8221; method 이전.</p>
</li>
<li>
<p>test method 실행 직전, test setup 후</p>
</li>
<li>
<p>test method 실행 직후 test 해체 전.</p>
</li>
<li>
<p>특정 test framework의 &#8220;after&#8221; 또는 &#8220;after each&#8221; method 이후.</p>
</li>
<li>
<p>특정 test framework의 &#8220;after class&#8221; 또는 &#8220;after all&#8221; method 이후.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_testexecutionlistener"><code>TestExecutionListener</code></h5>
<div class="paragraph">
<p><code>TestExecutionListener</code> 는 listener가 등록된 `TestContextManager`에서 publish 한 테스트 실행 이벤트에 반응하기위한 API를 정의합니다.
<a href="#testcontext-tel-config"><code>TestExecutionListener</code> Configuration</a> 를 참조하세요.</p>
</div>
</div>
<div class="sect4">
<h5 id="_context_loaders">Context Loaders</h5>
<div class="paragraph">
<p><code>ContextLoader`는 Spring TestContext Framework에서 관리하는 통합 테스트를 위한 `ApplicationContext</code> 를 로드하기 위한 strategy interface입니다.
component classes, active bean definition profiles, test property sources, context hierarchies 및 <code>WebApplicationContext</code> 지원에 대한 지원을 제공하려면 이 interface 대신 <code>SmartContextLoader</code> 를 구현해야합니다.</p>
</div>
<div class="paragraph">
<p><code>SmartContextLoader</code> 는 original minimal <code>ContextLoader</code> SPI를 대체하는 <code>ContextLoader</code> interface의 확장입니다.
특히 <code>SmartContextLoader</code> 는 resource locations, component classes 또는 context initializers를 처리하도록 선택할 수 있습니다.
또한 `SmartContextLoader`는 로드되는 context에서 active bean definition profile 및 test property sources를 설정할 수 있습니다.</p>
</div>
<div class="paragraph">
<p>Spring은 다음 구현을 제공합니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DelegatingSmartContextLoader</code>: 2개의 기본 loader 중 하나이며 test class에 대해 선언된 configuration 또는 default location 또는 default configuration class의 존재 여부에 따라 <code>AnnotationConfigContextLoader</code>, <code>GenericXmlContextLoader</code> 또는 <code>GenericGroovyXmlContextLoader</code> 에 내부적으로 위임합니다.
Groovy 지원은 Groovy가 classpath에 있는 경우에만 활성화됩니다.</p>
</li>
<li>
<p><code>WebDelegatingSmartContextLoader</code>: 2개의 기본 loader 중 하나이며 test class에 대해 선언된 configuration 또는 default location 또는 default configuration class의 존재 여부에 따라 <code>AnnotationConfigWebContextLoader</code>, <code>GenericXmlWebContextLoader</code> 또는 <code>GenericGroovyXmlWebContextLoader</code> 에 내부적으로 위임합니다.
Groovy 지원은 Groovy가 classpath에 있는 경우에만 활성화됩니다.</p>
</li>
<li>
<p><code>AnnotationConfigContextLoader</code>: component class에서 standard <code>ApplicationContext</code> 를 로드합니다.</p>
</li>
<li>
<p><code>AnnotationConfigWebContextLoader</code>: component class에서 standard <code>WebApplicationContext</code> 를 로드합니다.</p>
</li>
<li>
<p><code>GenericGroovyXmlContextLoader</code>: Groovy script 또는 XML configuration file인 resource에서 standard <code>ApplicationContext</code> 를 로드합니다.</p>
</li>
<li>
<p><code>GenericGroovyXmlWebContextLoader</code>: Groovy script 또는 XML configuration file인 resource에서 standard <code>WebApplicationContext</code> 를 로드합니다.</p>
</li>
<li>
<p><code>GenericXmlContextLoader</code>: XML resource location에서 standard <code>ApplicationContext</code> 를 로드합니다.</p>
</li>
<li>
<p><code>GenericXmlWebContextLoader</code>: XML resource location에서 standard <code>WebApplicationContext</code> 를 로드합니다.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-bootstrapping">Bootstrapping the TestContext Framework</h4>
<div class="paragraph">
<p>Spring TestContext Framework의 내부에 대한 모든 기본 구성은 일반적인 사용 사례에 충분합니다.
그러나 개발 팀 또는 third party framework가 default <code>ContextLoader</code> 를 변경하고 custom <code>TestContext</code> 또는 <code>ContextCache`를 구현하고, `ContextCustomizerFactory</code> 및 <code>TestExecutionListener</code> 구현의 default set를 확장하려는 경우가 있습니다.
TestContext framework가 작동하는 방법에 대한 low-level의 제어를 위해 Spring은 bootstrapping strategy를 제공합니다.</p>
</div>
<div class="paragraph">
<p><code>TestContextBootstrapper</code> 는 TestContext framework를 bootstrapping 하기위한 SPI를 정의합니다.
<code>TestContextBootstrapper</code> 는 <code>TestContextManager</code> 에서 현재 테스트에 대한 <code>TestExecutionListener</code> 구현을 로드하고 관리하는 <code>TestContext</code> 를 빌드하는데 사용됩니다.
<code>@BootstrapWith</code> 를 직접 사용하거나 meta-annotation을 사용하여 test class (또는 test class hierarchy)에 대한 custom bootstrapping strategy를 구성할 수 있습니다.
bootstrapper가 <code>@BootstrapWith</code> 를 사용하여 명시적으로 구성되지 않은 경우 <code>@WebAppConfiguration</code> 의 존재 여부에 따라 <code>DefaultTestContextBootstrapper</code> 또는 <code>WebTestContextBootstrapper</code> 가 사용됩니다.</p>
</div>
<div class="paragraph">
<p><code>TestContextBootstrapper</code> SPI는 향후 (새로운 요구사항을 수용하기 위해) 변경 될 가능성이 있으므로 구현자가 interface를 직접 구현하지 말고 대신 <code>AbstractTestContextBootstrapper</code> 또는 구체적인 subclass 중 하나를 확장하는 것이 좋습니다.</p>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-tel-config"><code>TestExecutionListener</code> Configuration</h4>
<div class="paragraph">
<p>Spring은 기본적으로 정확히 다음 순서로 등록 된 다음 <code>TestExecutionListener</code> 구현을 제공합니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ServletTestExecutionListener</code>: <code>WebApplicationContext</code> 에 대한 Servlet API mock을 구성합니다.</p>
</li>
<li>
<p><code>DirtiesContextBeforeModesTestExecutionListener</code>: &#8220;before&#8221; mode에 대한 <code>@DirtiesContext</code> annotation을 처리합니다.</p>
</li>
<li>
<p><code>ApplicationEventsTestExecutionListener</code>: <a href="#testcontext-application-events"><code>ApplicationEvents</code></a>에 대한 지원을 제공합니다.</p>
</li>
<li>
<p><code>DependencyInjectionTestExecutionListener</code>: test instance에 대한 dependency injection을 제공합니다.</p>
</li>
<li>
<p><code>DirtiesContextTestExecutionListener</code>: &#8220;after&#8221; mode에 대한 <code>@DirtiesContext</code> annotation을 처리합니다.</p>
</li>
<li>
<p><code>TransactionalTestExecutionListener</code>: default rollback semantic과 함께 transactional test 실행을 제공합니다.</p>
</li>
<li>
<p><code>SqlScriptsTestExecutionListener</code>: <code>@Sql</code> annotation을 사용하여 구성된 SQL script를 실행합니다.</p>
</li>
<li>
<p><code>EventPublishingTestExecutionListener</code>: 테스트의 <code>ApplicationContext</code> 에 test execution event를 publish합니다 (<a href="#testcontext-test-execution-events">Test Execution Events</a> 참조).</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="testcontext-tel-config-registering-tels">Registering <code>TestExecutionListener</code> Implementations</h5>
<div class="paragraph">
<p><code>@TestExecutionListeners</code> annotation을 사용하여 test class 및 subclass에 대한 <code>TestExecutionListener</code> 구현을 등록 할 수 있습니다.
자세한 내용과 예제는 <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/context/TestExecutionListeners.html"><code>@TestExecutionListeners</code></a>에 대한  <a href="#integration-testing-annotations">annotation 지원</a> 및 javadoc을 참조하세요.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tel-config-automatic-discovery">Automatic Discovery of Default <code>TestExecutionListener</code> Implementations</h5>
<div class="paragraph">
<p><code>@TestExecutionListeners</code> 를 사용하여 <code>TestExecutionListener</code> 구현을 등록하는 것은 제한된 테스트 시나리오에서 사용되는 custom listener에 적합합니다.
그러나 custom listener를 전체 test suite에서 사용해야하는 경우 번거로울 수 있습니다.
이 문제는 <code>SpringFactoriesLoader</code> 메커니즘을 통한 default <code>TestExecutionListener</code> 구현의 자동 검색 지원을 통해 해결됩니다.</p>
</div>
<div class="paragraph">
<p>특히 <code>spring-test</code> module은 <code>META-INF/spring.factories</code> properties file의 <code>org.springframework.test.context.TestExecutionListener</code> key 아래에 모든 핵심 default <code>TestExecutionListener</code> 구현을 선언합니다.
Third-party frameworks 및 개발자는 자체 <code>META-INF/spring.factories</code> properties file을 통해 동일한 방식으로 자체 <code>TestExecutionListener</code> 구현을 default listener 목록에 제공 할 수 있습니다.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tel-config-ordering">Ordering <code>TestExecutionListener</code> Implementations</h5>
<div class="paragraph">
<p>TestContext framework가 <a href="#testcontext-tel-config-automatic-discovery">앞서 언급한</a> <code>SpringFactoriesLoader</code> 메커니즘을 통해 default <code>TestExecutionListener</code> 구현을 발견하면 인스턴스화 된 listener는 Spring의 <code>Ordered</code> interface와 <code>@Order</code> annotation을 준수하는 Spring의 <code>AnnotationAwareOrderComparator</code> 를 사용하여 정렬됩니다.
<code>AbstractTestExecutionListener</code> 및 Spring에서 제공하는 모든 default <code>TestExecutionListener</code> 구현은 적절한 값으로 <code>Ordered</code> 를 구현합니다.
따라서 third-party framework 및 개발자는 <code>Ordered</code> 를 구현하거나 <code>@Order</code> 를 선언하여 default <code>TestExecutionListener</code> 구현이 올바른 순서로 등록되었는지 확인해야합니다.
각 core listener에 할당되는 값에 대한 세부 사항은 core default <code>TestExecutionListener</code> 구현의 <code>getOrder()</code> method에 대한 javadoc을 참조하세요.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tel-config-merging">Merging <code>TestExecutionListener</code> Implementations</h5>
<div class="paragraph">
<p>custom <code>TestExecutionListener</code> 가 <code>@TestExecutionListeners</code> 를 통해 등록된 경우 default listener는 등록되지 않습니다
대부분의 일반적인 테스트 시나리오에서 이는 개발자가 모든 custom listener 외에 모든 default listener를 수동으로 선언하도록 효과적으로 강제합니다.
다음 목록은 이러한 구성 스타일을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@TestExecutionListeners({
    MyCustomTestExecutionListener.class,
    ServletTestExecutionListener.class,
    DirtiesContextBeforeModesTestExecutionListener.class,
    DependencyInjectionTestExecutionListener.class,
    DirtiesContextTestExecutionListener.class,
    TransactionalTestExecutionListener.class,
    SqlScriptsTestExecutionListener.class
})
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@TestExecutionListeners(
    MyCustomTestExecutionListener::class,
    ServletTestExecutionListener::class,
    DirtiesContextBeforeModesTestExecutionListener::class,
    DependencyInjectionTestExecutionListener::class,
    DirtiesContextTestExecutionListener::class,
    TransactionalTestExecutionListener::class,
    SqlScriptsTestExecutionListener::class
)
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>이 접근 방식의 문제는 개발자가 기본적으로 등록된 listener를 정확히 알아야한다는 것입니다.
또한 default listener set은 release에서 release로 변경 될 수 있습니다.
예를 들어 <code>SqlScriptsTestExecutionListener</code> 는 Spring Framework 4.1에 도입되었고 <code>DirtiesContextBeforeModesTestExecutionListener</code> 는 Spring Framework 4.2에 도입되었습니다.
또한 Spring Boot 및 Spring Security와 같은 third-party framework는 앞서 언급한 &lt;testcontext-tel-config-automatic-discovery,automatic discovery mechanism&gt;&gt;을 사용하여 자체 기본 <code>TestExecutionListener</code> 구현을 등록합니다.</p>
</div>
<div class="paragraph">
<p>모든 default listener를 인식하고 다시 선언 할 필요가 없도록 <code>@TestExecutionListeners`의 `mergeMode</code> attribute를 <code>MergeMode.MERGE_WITH_DEFAULTS</code> 로 설정할 수 있습니다.
<code>MERGE_WITH_DEFAULTS</code> 는 local로 선언된 listener가 default listener와 병합되어야 함을 나타냅니다.
병합 알고리즘은 <a href="#testcontext-tel-config-ordering">Ordering <code>TestExecutionListener</code> Implementations</a>에 설명 된대로 목록에서 중복 항목이 제거되고 병합된 listener의 result set이 <code>AnnotationAwareOrderComparator</code> 의 의미 체계에 따라 정렬되도록합니다.
listener가 <code>Ordered</code> 를 구현하거나 <code>@Order</code> 로 annotation이 달린 경우 기본 값과 병합되는 위치에 영향을 줄 수 있습니다.
그렇지 않으면 lcoal로 선언된 listener가 병합 될 때 default listener 목록에 추가됩니다.</p>
</div>
<div class="paragraph">
<p>예를 들어, 이전 예제의 <code>MyCustomTestExecutionListener</code> class 가 <code>order</code> value (예 : <code>500</code>)를 <code>ServletTestExecutionListener</code> 의 order (<code>1000</code> 이 됨)보다 작게 구성하면 <code>MyCustomTestExecutionListener</code> 가 기본값 목록과 자동으로 병합 될 수 있습니다.
<code>ServletTestExecutionListener</code> 앞에서 이전 예제를 다음으로 대체 할 수 있습니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@TestExecutionListeners(
    listeners = MyCustomTestExecutionListener.class,
    mergeMode = MERGE_WITH_DEFAULTS
)
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@TestExecutionListeners(
        listeners = [MyCustomTestExecutionListener::class],
        mergeMode = MERGE_WITH_DEFAULTS
)
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-application-events">Application Events</h4>
<div class="paragraph">
<p>Spring Framework 5.3.3부터 TestContext framework는 <code>ApplicationContext</code> 에 publish 된 <a href="core.html#context-functionality-events">application events</a> 기록을 지원하므로 테스트 내에서 해당 이벤트에 대해 assertion을 수행 할 수 있습니다.
단일 테스트 실행 중에 publish 된 모든 이벤트는 이벤트를 <code>java.util.Stream</code> 으로 처리 할 수 있는 <code>ApplicationEvents</code> API를 통해 사용할 수 있습니다.</p>
</div>
<div class="paragraph">
<p>테스트에서 <code>ApplicationEvents</code> 를 사용하려면 다음을 수행하십시오.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>test class가 <a href="#spring-testing-annotation-recordapplicationevents"><code>@RecordApplicationEvents</code></a>로 annotation 처리되거나 meta-annotation 처리되었는지 확인하십시오.</p>
</li>
<li>
<p><code>ApplicationEventsTestExecutionListener</code> 가 등록되었는지 확인하십시오.
그러나 <code>ApplicationEventsTestExecutionListener</code> 는 기본적으로 등록되며 default listener를 포함하지 않는 <code>@TestExecutionListeners</code> 를 통해 custom configuration이 있는 경우에만 수동으로 등록해야합니다.</p>
</li>
<li>
<p><code>@Autowired</code> 로 <code>ApplicationEvents</code> type의 field에 annotation을 달고 테스트 및 lifecycle method (예 : JUnit Jupiter의 <code>@BeforeEach</code> 및 <code>@AfterEach</code> method)에서 <code>ApplicationEvents</code> instance를 사용합니다.</p>
<div class="ulist">
<ul>
<li>
<p><a href="#testcontext-junit-jupiter-extension">SpringExtension for JUnit Jupiter</a>을 사용할 때 테스트 클래스의 <code>@Autowired</code> field 대신 테스트 또는 lifecycle method에서 <code>ApplicationEvents</code> type의 method parameter를 선언 할 수 있습니다.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>다음 테스트 클래스는 JUnit Jupiter 및 <a href="https://assertj.github.io/doc/">AssertJ</a> 용 <code>SpringExtension</code> 을 사용하여 Spring 관리 component에서 method를 호출하는 동안 publish 된 application event type을 주장합니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(/* ... */)
@RecordApplicationEvents <i class="conum" data-value="1"></i><b>(1)</b>
class OrderServiceTests {

    @Autowired
    OrderService orderService;

    @Autowired
    ApplicationEvents events; <i class="conum" data-value="2"></i><b>(2)</b>

    @Test
    void submitOrder() {
        // Invoke method in OrderService that publishes an event
        orderService.submitOrder(new Order(/* ... */));
        // Verify that an OrderSubmitted event was published
        int numEvents = events.stream(OrderSubmitted.class).count(); <i class="conum" data-value="3"></i><b>(3)</b>
        assertThat(numEvents).isEqualTo(1);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@RecordApplicationEvents</code> 로 테스트 클래스에 주석을 답니다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>현재 테스트에 대한 <code>ApplicationEvents</code> instance를 inject합니다.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>ApplicationEvents</code> API를 사용하여 publish 된 <code>OrderSubmitted</code> 이벤트 수를 계산합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(/* ... */)
@RecordApplicationEvents <i class="conum" data-value="1"></i><b>(1)</b>
class OrderServiceTests {

    @Autowired
    lateinit var orderService: OrderService

    @Autowired
    lateinit var events: ApplicationEvents <i class="conum" data-value="2"></i><b>(2)</b>

    @Test
    fun submitOrder() {
        // Invoke method in OrderService that publishes an event
        orderService.submitOrder(Order(/* ... */))
        // Verify that an OrderSubmitted event was published
        val numEvents = events.stream(OrderSubmitted::class).count() <i class="conum" data-value="3"></i><b>(3)</b>
        assertThat(numEvents).isEqualTo(1)
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@RecordApplicationEvents</code> 로 테스트 클래스에 주석을 답니다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>현재 테스트에 대한 <code>ApplicationEvents</code> instance를 inject합니다.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>ApplicationEvents</code> API를 사용하여 publish 된 <code>OrderSubmitted</code> 이벤트 수를 계산합니다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>ApplicationEvents</code> API에 대한 자세한 내용은 <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/context/event/ApplicationEvents.html"><code>ApplicationEvents</code> javadoc</a>을 참조하십시오.</p>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-test-execution-events">Test Execution Events</h4>
<div class="paragraph">
<p>Spring Framework 5.2에 도입된 <code>EventPublishingTestExecutionListener</code> 는 custom <code>TestExecutionListener</code> 구현에 대한 대안적인 접근 방식을 제공합니다.
테스트의 <code>ApplicationContext</code> 에 있는 component는 <code>EventPublishingTestExecutionListener</code> 가 publish 한 다음 이벤트를 수신 할 수 있습니다.
각 이벤트는 <code>TestExecutionListener</code> API의 method에 해당합니다.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BeforeTestClassEvent</code></p>
</li>
<li>
<p><code>PrepareTestInstanceEvent</code></p>
</li>
<li>
<p><code>BeforeTestMethodEvent</code></p>
</li>
<li>
<p><code>BeforeTestExecutionEvent</code></p>
</li>
<li>
<p><code>AfterTestExecutionEvent</code></p>
</li>
<li>
<p><code>AfterTestMethodEvent</code></p>
</li>
<li>
<p><code>AfterTestClassEvent</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
이러한 이벤트는 `ApplicationContext`가 이미 로드된 경우에만 publish 됩니다.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>이러한 이벤트는 mock bean 재설정 또는 테스트 실행 추적과 같은 다양한 이유로 사용될 수 있습니다.
custom <code>TestExecutionListener</code> 를 구현하는 것보다  test execution event를 사용하는 한 가지 장점은 test execution event가 test <code>ApplicationContext</code> 에 등록된 Spring bean에 의해 사용될 수 있으며 이러한 bean은 dependency injection 및 <code>ApplicationContext`의 다른 기능으로부터 직접 혜택을 받을 수 있다는 것입니다.
반대로 `TestExecutionListener</code> 는 <code>ApplicationContext</code> 의 bean이 아닙니다.</p>
</div>
<div class="paragraph">
<p>test execution event를 수신하기 위해 Spring bean은 <code>org.springframework.context.ApplicationListener</code> interface를 구현하도록 선택할 수 있습니다.
또는 listener method에 <code>@EventListener`로 annotation을 달고 위에 나열된 특정 event types 중 하나를 수신하도록 구성 할 수 있습니다 (<a href="core.html#context-functionality-events-annotation">Annotation-based Event Listeners</a> 참조).
이 접근법의 인기로 인해 Spring은 test execution event listener의 등록을 단순화하기 위해 다음과 같은 전용 `@EventListener</code> annotation을 제공합니다.
이러한 annotation은 <code>org.springframework.test.context.event.annotation</code> package에 있습니다.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@BeforeTestClass</code></p>
</li>
<li>
<p><code>@PrepareTestInstance</code></p>
</li>
<li>
<p><code>@BeforeTestMethod</code></p>
</li>
<li>
<p><code>@BeforeTestExecution</code></p>
</li>
<li>
<p><code>@AfterTestExecution</code></p>
</li>
<li>
<p><code>@AfterTestMethod</code></p>
</li>
<li>
<p><code>@AfterTestClass</code></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="testcontext-test-execution-events-exception-handling">Exception Handling</h5>
<div class="paragraph">
<p>기본적으로 test execution event listener가 event를 사용하는 동안 exception을 발생시키면 해당 exception은 사용중인 기본 testing framework(예 : JUnit 또는 TestNG)으로 전파됩니다.
예를 들어 <code>BeforeTestMethodEvent</code> 를 사용하여 exception이 발생하면 해당 test method가 exception으로 인해 실패합니다.
반대로 asynchronous test execution event listener 가 exception을 throw하면 exception이 기본 testing framework로 전파되지 않습니다.
asynchronous exception handling에 대한 자세한 내용은 <code>@EventListener</code> 에 대한 class-level javadoc을 참조하세요.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-test-execution-events-async">Asynchronous Listeners</h5>
<div class="paragraph">
<p>특정 test execution event listener가 event를 비동기적으로 처리하도록 하려면 Spring의 <a href="integration.html#scheduling-annotation-support-async">일반 <code>@Async</code> 지원</a>을 사용할 수 있습니다.
자세한 내용은 <code>@EventListener</code> 에 대한 class-level javadoc을 참조하세요.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-ctx-management">Context Management</h4>
<div class="paragraph">
<p>각 <code>TestContext</code> 는 담당하는 test instance에 대한 context 관리 및 캐싱 지원을 제공합니다.
test instances는 구성된 <code>ApplicationContext</code> 에 대한 액세스를 자동으로 받지 않습니다.
그러나 test class가 <code>ApplicationContextAware</code> interface를 구현하는 경우 <code>ApplicationContext</code> 에 대한 참조가 test instance에 제공됩니다.
<code>AbstractJUnit4SpringContextTests</code> 및 <code>AbstractTestNGSpringContextTests</code> 는 <code>ApplicationContextAware</code> 를 구현하므로 <code>ApplicationContext</code> 에 대한 액세스를 자동으로 제공합니다.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">@Autowired ApplicationContext</div>
<div class="paragraph">
<p><code>ApplicationContextAware</code> interface를 구현하는 대신 다음 예제와 같이 field 또는 setter method에서 <code>@Autowired</code> annotation을 통해 테스트 클래스에 대한 application context를 inject 할 수 있습니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig
class MyTest {

    @Autowired <i class="conum" data-value="1"></i><b>(1)</b>
    ApplicationContext applicationContext;

    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Injecting the <code>ApplicationContext</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig
class MyTest {

    @Autowired <i class="conum" data-value="1"></i><b>(1)</b>
    lateinit var applicationContext: ApplicationContext

    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Injecting the <code>ApplicationContext</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>마찬가지로 테스트가 web application context를 로드하도록 구성된 경우 다음과 같이 `WebApplicationContext`를 테스트에 inject 할 수 있습니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitWebConfig <i class="conum" data-value="1"></i><b>(1)</b>
class MyWebAppTest {

    @Autowired <i class="conum" data-value="2"></i><b>(2)</b>
    WebApplicationContext wac;

    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configuring the <code>WebApplicationContext</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Injecting the <code>WebApplicationContext</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitWebConfig <i class="conum" data-value="1"></i><b>(1)</b>
class MyWebAppTest {

    @Autowired <i class="conum" data-value="2"></i><b>(2)</b>
    lateinit var wac: WebApplicationContext
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configuring the <code>WebApplicationContext</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Injecting the <code>WebApplicationContext</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@Autowired</code> 를 사용한 dependency injection은 기본적으로 구성되는 <code>DependencyInjectionTestExecutionListener</code> 에서 제공합니다 (<a href="#testcontext-fixture-di">Dependency Injection of Test Fixtures</a> 참조).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>TestContext framework를 사용하는 test class는 application context를 구성하기 위해 특정 class를 확장하거나 특정 interface를 구현할 필요가 없습니다.
대신 class level에서 <code>@ContextConfiguration</code> annotation을 선언하여 구성을 수행합니다.
test class가 application context resource location 또는 component class를 명시적으로 선언하지 않는 경우 구성된 <code>ContextLoader</code> 는 default location 또는 default configuration class에서 context를 로드하는 방법을 결정합니다.
context resource location 및 component class 외에도 application context initializer를 통해 application context를 구성 할 수도 있습니다.</p>
</div>
<div class="paragraph">
<p>다음 section에서는 XML configuration file, Groovy script, component class (일반적으로 <code>@Configuration</code> class) 또는 context initializer를 사용하여 test <code>ApplicationContext</code> 를 구성하기 위해 Spring의 <code>@ContextConfiguration</code> annotation을 사용하는 방법을 설명합니다.
또는 advanced use case를 위해 고유한 custom <code>SmartContextLoader</code> 를 구현하고 구성 할 수 있습니다.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#testcontext-ctx-management-xml">Context Configuration with XML resources</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-groovy">Context Configuration with Groovy Scripts</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-javaconfig">Context Configuration with Component Classes</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-mixed-config">Mixing XML, Groovy Scripts, and Component Classes</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-initializers">Context Configuration with Context Initializers</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-inheritance">Context Configuration Inheritance</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-env-profiles">Context Configuration with Environment Profiles</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-property-sources">Context Configuration with Test Property Sources</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-dynamic-property-sources">Context Configuration with Dynamic Property Sources</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-web">Loading a <code>WebApplicationContext</code></a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-caching">Context Caching</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-ctx-hierarchies">Context Hierarchies</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-xml">Context Configuration with XML resources</h5>
<div class="paragraph">
<p>XML configuration file을 사용하여 테스트 용 <code>ApplicationContext</code> 를 로드하려면 <code>@ContextConfiguration</code> 으로 test class에 annotation을 달고 XML configuration metadata의 resource location이 포함된 배열로  <code>locations</code> attribute를 구성합니다.
plain 또는 relative path (예 : <code>context.xml</code>)는 test class가 정의된 package에 상대적인 classpath resource 로 처리됩니다.
slash로 시작하는 path는 absolute classpath location(예 : <code>/org/example/config.xml</code>)으로 처리됩니다.
resource URL을 나타내는 path (즉, <code>classpath:</code>, <code>file:</code>, <code>http:</code> 등이 prefix로 붙은 path)는 <em>그대로</em> 사용됩니다.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "/app-config.xml" and
// "/test-config.xml" in the root of the classpath
@ContextConfiguration(locations={"/app-config.xml", "/test-config.xml"}) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>locations attribute를 XML file 목록으로 설정합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from "/app-config.xml" and
// "/test-config.xml" in the root of the classpath
@ContextConfiguration("/app-config.xml", "/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>locations attribute를 XML file 목록으로 설정합니다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@ContextConfiguration`은 standard Java `value</code> attribute를 통해 <code>locations</code> attribute에 대한 alias를 지원합니다.
따라서 <code>@ContextConfiguration</code> 에서 추가 attribute를 선언할 필요가 없는 경우 <code>locations</code> attribute name의 선언을 생략하고 다음 예제에 설명된 shorthand format을 사용하여 resource location을 선언할 수 있습니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-config.xml"}) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>location</code> attribute를 사용하지 않고 XML file을 지정합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
@ContextConfiguration("/app-config.xml", "/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>location</code> attribute를 사용하지 않고 XML file을 지정합니다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@ContextConfiguration</code> annotation에서 <code>locations</code> 및 <code>value</code> attribute를 모두 생략하면 TestContext framework가 default XML resource location을 감지하려고합니다.
특히 <code>GenericXmlContextLoader</code> 및 <code>GenericXmlWebContextLoader</code> 는 test class의 이름을 기반으로 default location을 감지합니다.
class name이 <code>com.example.MyTest</code> 인 경우 <code>GenericXmlContextLoader</code> 는 <code>"classpath:com/example/MyTest-context.xml"</code> 에서 application context를 로드합니다.
다음 예는 이를 수행하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// "classpath:com/example/MyTest-context.xml"
@ContextConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>default location에서 구성 로드.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from
// "classpath:com/example/MyTest-context.xml"
@ContextConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>default location에서 구성 로드.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-groovy">Context Configuration with Groovy Scripts</h5>
<div class="paragraph">
<p><a href="core.html#groovy-bean-definition-dsl">Groovy Bean Definition DSL</a>을 사용하는 Groovy script를 사용하여 테스트 용 <code>ApplicationContext</code> 를 로드하려면 <code>@ContextConfiguration</code> 으로 test class에 annotation을 달고 Groovy script의 resource location을 포함하는 배열로 <code>locations</code> 또는 <code>value</code> attribute를 구성 할 수 있습니다.
Groovy script에 대한 resource lookcup semantic은 <a href="#testcontext-ctx-management-xml">XML configuration files</a>에 대해 설명된 것과 동일합니다.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Enabling Groovy script support</div>
Groovy가 classpath에 있으면 Spring TestContext Framework에서 <code>ApplicationContext</code> 를 로드하기 위해 Groovy script를 사용하는 지원이 자동으로 활성화됩니다.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>다음 예는 Groovy configuration file을 지정하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "/AppConfig.groovy" and
// "/TestConfig.groovy" in the root of the classpath
@ContextConfiguration({"/AppConfig.groovy", "/TestConfig.Groovy"}) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from "/AppConfig.groovy" and
// "/TestConfig.groovy" in the root of the classpath
@ContextConfiguration("/AppConfig.groovy", "/TestConfig.Groovy") <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Groovy configuration file location 지정.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@ContextConfiguration</code> annotation에서 <code>locations</code> 및 <code>value</code> attribute를 모두 생략하면 TestContext framework는 기본 Groovy script를 감지하려고 합니다.
특히 <code>GenericGroovyXmlContextLoader</code> 및 <code>GenericGroovyXmlWebContextLoader</code> 는 test class의 이름을 기반으로 default location을 감지합니다.
class name이 <code>com.example.MyTest</code> 이면 Groovy context loader 는 <code>"classpath:com/example/MyTestContext.groovy"</code> 에서 application context를 로드합니다.
다음 예는 default 값을 사용하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// "classpath:com/example/MyTestContext.groovy"
@ContextConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>default location에서 configuration 로드.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from
// "classpath:com/example/MyTestContext.groovy"
@ContextConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>default location에서 configuration 로드.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Declaring XML configuration and Groovy scripts simultaneously</div>
<div class="paragraph">
<p><code>@ContextConfiguration</code> 의 <code>locations</code> 또는 <code>value</code> attribute를 사용하여 ML configuration file과 Groovy script를 동시에 선언 할 수 있습니다.
구성된 resource location에 대한 경로가 <code>.xml</code> 로 끝나면 <code>XmlBeanDefinitionReader</code> 를 사용하여 로드됩니다.
그렇지 않으면 <code>GroovyBeanDefinitionReader</code> 를 사용하여 로드됩니다.</p>
</div>
<div class="paragraph">
<p>다음 목록은 통합 테스트에서 두 가지를 결합하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// "/app-config.xml" and "/TestConfig.groovy"
@ContextConfiguration({ "/app-config.xml", "/TestConfig.groovy" })
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from
// "/app-config.xml" and "/TestConfig.groovy"
@ContextConfiguration("/app-config.xml", "/TestConfig.groovy")
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-javaconfig">Context Configuration with Component Classes</h5>
<div class="paragraph">
<p>component class를 사용하여 테스트 용 <code>ApplicationContext</code> 를 로드하려면(<a href="core.html#beans-java">Java-based container configuration</a> 참조) <code>@ContextConfiguration</code> 으로 test class에 annotation을 달고 component class에 대한 참조를 포함하는 배열로 <code>classes</code> attribute를 구성할 수 있습니다.
다음 예는이를 수행하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from AppConfig and TestConfig
@ContextConfiguration(classes = {AppConfig.class, TestConfig.class}) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>component class 지정.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from AppConfig and TestConfig
@ContextConfiguration(classes = [AppConfig::class, TestConfig::class]) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>component class 지정.</td>
</tr>
</table>
</div>
<div id="testcontext-ctx-management-javaconfig-component-classes" class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Component Classes</div>
<div class="paragraph">
<p>&#8220;component class&#8221; 라는 용어는 다음 중 하나를 나타낼 수 있습니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Configuration</code> 으로 annotation이 달린 class.</p>
</li>
<li>
<p>A component (즉, <code>@Component</code> ,  <code>@Service</code> , <code>@Repository</code> 또는 기타  stereotype annotations이 있는 class).</p>
</li>
<li>
<p><code>javax.inject</code> annotation으로 annotation이 있는 JSR-330 준수 class.</p>
</li>
<li>
<p><code>@Bean</code>-method를 포함하는 모든 class.</p>
</li>
<li>
<p>Spring component (즉, <code>ApplicationContext</code> 의 Spring bean)로 등록되도록 의도된 다른 class, 잠재적으로 Spring annotation을 사용하지 않고 single constructor의 자동 autowire를 활용할 수 있습니다.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>@Bean</code> Lite mode에 대한 논의에 특별한 주의를 기울이면서 component class의 구성 및 의미에 대한 자세한 정보는 <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/context/annotation/Configuration.html"><code>@Configuration</code></a> 및 <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/context/annotation/Bean.html"><code>@Bean</code></a>의 javadoc을 참조하세요.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@ContextConfiguration</code> annotation에서 <code>classes</code> attribute를 생략하면 TestContext framework는 default configuration class의 존재를 감지하려고합니다.
특히 <code>AnnotationConfigContextLoader</code> 및 <code>AnnotationConfigWebContextLoader</code> 는 <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/context/annotation/Configuration.html"><code>@Configuration</code></a> javadoc에 지정된대로 configuration class 구현 요구 사항을 충족하는 test class의 모든 <code>static</code> nested class를 감지합니다.
configuration class의 이름은 임의적입니다.
또한 test class 는 원하는 경우 둘 이상의 <code>static</code> nested configuration class를 포함 할 수 있습니다.
다음 예제에서 <code>OrderServiceTest</code> class는 test class에 대한 <code>ApplicationContext</code> 를 로드하는데 자동으로 사용되는 <code>Config</code> 라는 <code>static</code> nested configuration class를 선언합니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig <i class="conum" data-value="1"></i><b>(1)</b>
// ApplicationContext will be loaded from the
// static nested Config class
class OrderServiceTest {

    @Configuration
    static class Config {

        // this bean will be injected into the OrderServiceTest class
        @Bean
        OrderService orderService() {
            OrderService orderService = new OrderServiceImpl();
            // set properties, etc.
            return orderService;
        }
    }

    @Autowired
    OrderService orderService;

    @Test
    void testOrderService() {
        // test the orderService
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>nested <code>Config</code> class에서 configuration 로드.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig <i class="conum" data-value="1"></i><b>(1)</b>
// ApplicationContext will be loaded from the nested Config class
class OrderServiceTest {

    @Autowired
    lateinit var orderService: OrderService

    @Configuration
    class Config {

        // this bean will be injected into the OrderServiceTest class
        @Bean
        fun orderService(): OrderService {
            // set properties, etc.
            return OrderServiceImpl()
        }
    }

    @Test
    fun testOrderService() {
        // test the orderService
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>nested <code>Config</code> class에서 configuration 로드.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-mixed-config">Mixing XML, Groovy Scripts, and Component Classes</h5>
<div class="paragraph">
<p>XML configuration file, Groovy script 및 component class (일반적으로 <code>@Configuration</code> class)를 혼합하여 테스트를 위한 <code>ApplicationContext</code> 를 구성하는 것이 바람직 할 수 있습니다.
예를 들어, production에서 XML configuration을 사용하는 경우 <code>@Configuration</code> class를 사용하여 테스트를 위한 특정 Spring 관리 components를 구성할지 또는 그 반대인지 결정할 수 있습니다.
또한 일부 third-party framework(예: Spring Boot)는 다양한 유형의 resources(예 : XML configuration file, Groovy script 및 <code>@Configuration</code> class)에서 동시에 <code>ApplicationContext</code> 를 로드하기 위한 최상의 지원을 제공합니다.
역사적으로 Spring Framework는 standard deployment에 대해 이를 지원하지 않았습니다.
결과적으로 Spring Framework가 <code>spring-test</code> module에서 제공하는 대부분의 <code>SmartContextLoader</code> 구현은 각 test context에 대해 하나의 resource type만 지원합니다.
그러나 이것이 둘 다 사용할 수 없다는 의미는 아닙니다.
일반적인 규칙에 대한 한 가지 예외는 <code>GenericGroovyXmlContextLoader</code> 및 <code>GenericGroovyXmlWebContextLoader</code> 가 XML configuration file과 Groovy script를 동시에 지원한다는 것입니다.
또한 third-party framework는 <code>@ContextConfiguration</code> 을 통해 <code>locations</code> 과 `classes`의 선언을 모두 지원하도록 선택할 수 있으며 TestContext framework의 표준 테스트 지원을 통해 다음 옵션을 사용할 수 있습니다.</p>
</div>
<div class="paragraph">
<p>resource location(예 : XML 또는 Groovy) 및 <code>@Configuration</code> class를 사용하여 테스트를 구성하려는 경우 하나를 진입점으로 선택하고 다른 하나를 포함하거나 가져와야합니다.
예를 들어 XML 또는 Groovy script에서는 component scan을 사용하거나 일반 Spring Bean으로 정의하여 <code>@Configuration</code> class를 포함 할 수 있지만 @Configuration 클래스에서는 <code>@ImportResource</code> 를 사용하여 XML configuration file 또는 Groovy script를 가져올 수 있습니다.
이 동작은 production에서 application을 구성하는 방법과 의미 상 동일합니다:
production configuration에서 XML 또는 Groovy resource location set 또는 production <code>ApplicationContext</code> 가 로드되는 <code>@Configuration</code> class set을 정의하지만 여전히 다른 유형의 configuration을 include 또는 import 할 수 있습니다.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-initializers">Context Configuration with Context Initializers</h5>
<div class="paragraph">
<p>context initializer를 사용하여 테스트에 대한 <code>ApplicationContext</code> 를 구성하려면 <code>@ContextConfiguration</code> 으로 test class에 annotation을 달고 <code>ApplicationContextInitializer</code> 를 구현하는 class에 대한 참조를 포함하는 배열로 <code>initializers</code> attribute를 구성합니다.
선언된 컨텍스트 context initializers는 테스트를 위해 로드된 <code>ConfigurableApplicationContext</code> 를 초기화하는 데 사용됩니다.
선언된 각 initializer가 지원하는 구체적인 <code>ConfigurableApplicationContext</code> type은 사용중인 <code>SmartContextLoader</code> (일반적으로 <code>GenericApplicationContext</code>)에 의해 생성된 <code>ApplicationContext</code> type과 호환되어야 합니다.
또한 initializer가 호출되는 순서는 Spring의 <code>Ordered</code> interface를 구현하는지 아니면 Spring의 <code>@Order</code> annotation 또는 표준 <code>@Priority</code> annotation으로 주석 처리되는지에 따라 다릅니다.
다음 예제는 initializer를 사용하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from TestConfig
// and initialized by TestAppCtxInitializer
@ContextConfiguration(
    classes = TestConfig.class,
    initializers = TestAppCtxInitializer.class) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>configuration class 및 initializer를 사용하여 configuration  지정.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from TestConfig
// and initialized by TestAppCtxInitializer
@ContextConfiguration(
        classes = [TestConfig::class],
        initializers = [TestAppCtxInitializer::class]) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>configuration class 및 initializer를 사용하여 configuration  지정.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>또한 <code>@ContextConfiguration</code> 에서 XML configuration file, Groovy script 또는 component class의 선언을 완전히 생략하고 대신 <code>ApplicationContextInitializer</code> class만 선언하여 context에 bean을 등록 할 수 있습니다.
예를 들어 XML file 또는 configuration class에서 프로그래밍 방식으로 bean definition을 로드합니다.
다음 예는 이를 수행하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// ApplicationContext will be initialized by EntireAppInitializer
// which presumably registers beans in the context
@ContextConfiguration(initializers = EntireAppInitializer.class) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>initializer만 사용하여 configuration 지정.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// ApplicationContext will be initialized by EntireAppInitializer
// which presumably registers beans in the context
@ContextConfiguration(initializers = [EntireAppInitializer::class]) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>initializer만 사용하여 configuration 지정.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-inheritance">Context Configuration Inheritance</h5>
<div class="paragraph">
<p><code>@ContextConfiguration</code> 은 resource locations 또는 component classe와 superclasses에 의해 선언된 context initializers를 상속해야하는지 여부를 나타내는 boolean <code>inheritLocations</code> 및 <code>inheritInitializers</code> attribute를 지원합니다.
두 flag의 기본값은 true입니다.
이는 test class가 resource location 또는 component class 뿐만 아니라 superclasses에서 선언한 context initializer를 상속한다는 것을 의미합니다.
특히 test class의 resource location 또는 component class는 resource location 또는 superclasses에서 선언한 annotation이 있는 class 목록에 추가됩니다.
유사하게, 주어진 test class의 initializer는 test superclasses에 의해 정의된 initializer set에 추가됩니다.
따라서 subclasses에는 resource location, component class 또는 context initializer를 확장하는 옵션이 있습니다.</p>
</div>
<div class="paragraph">
<p><code>@ContextConfiguration</code> 의 <code>inheritLocations</code> 또는 <code>inheritInitializers</code> attribute가 <code>false</code> 로 설정되면 test class shadow에 대한 resource location 또는 component class와 context initializers가 각각 superclass에 정의된 configuration을 효과적으로 대체합니다.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Framework 5.3부터 test configuration은 enclosing class에서 상속될 수도 있습니다.
자세한 내용은 <a href="#testcontext-junit-jupiter-nested-test-configuration"><code>@Nested</code> test class configuration</a>을 참조하세요.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>XML resource location을 사용하는 다음 예제에서 <code>ExtendedTest</code> 에 대한 <code>ApplicationContext</code> 는 <code>base-config.xml</code> 및 <code>extended-config.xml</code> 에서 순서대로 로드됩니다.
따라서 <code>extended-config.xml</code> 에 정의된 bean은 <code>base-config.xml</code> 에 정의된 bean을 override(즉, replace) 할 수 있습니다.
다음 예제는 한 class가 다른 class를 확장하고 자체 configuration file과 superclass의 configuration file을 모두 사용하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "/base-config.xml"
// in the root of the classpath
@ContextConfiguration("/base-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class BaseTest {
    // class body...
}

// ApplicationContext will be loaded from "/base-config.xml" and
// "/extended-config.xml" in the root of the classpath
@ContextConfiguration("/extended-config.xml") <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest extends BaseTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>superclass에 정의된 configuration file 입니다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>subclass에 정의된 configuration file 입니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from "/base-config.xml"
// in the root of the classpath
@ContextConfiguration("/base-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
open class BaseTest {
    // class body...
}

// ApplicationContext will be loaded from "/base-config.xml" and
// "/extended-config.xml" in the root of the classpath
@ContextConfiguration("/extended-config.xml") <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest : BaseTest() {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>superclass에 정의된 configuration file 입니다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>subclass에 정의된 configuration file 입니다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>마찬가지로 component class를 사용하는 다음 예제에서 <code>ExtendedTest</code> 에 대한 <code>ApplicationContext</code> 는 <code>BaseConfig</code> 및 <code>ExtendedConfig</code> class에서 순서대로 로드됩니다.
따라서 <code>ExtendedConfig</code> 에 정의된 bean은 <code>BaseConfig</code> 에 정의된 bean을 override(즉, replace) 할 수 있습니다.
다음 예제는 한 class가 다른 class를 확장하고 자체 configuration class와 superclass의 configuration class를 모두 사용하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// ApplicationContext will be loaded from BaseConfig
@SpringJUnitConfig(BaseConfig.class) <i class="conum" data-value="1"></i><b>(1)</b>
class BaseTest {
    // class body...
}

// ApplicationContext will be loaded from BaseConfig and ExtendedConfig
@SpringJUnitConfig(ExtendedConfig.class) <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest extends BaseTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>superclass에 정의된 configuration file 입니다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>subclass에 정의된 configuration file 입니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// ApplicationContext will be loaded from BaseConfig
@SpringJUnitConfig(BaseConfig::class) <i class="conum" data-value="1"></i><b>(1)</b>
open class BaseTest {
    // class body...
}

// ApplicationContext will be loaded from BaseConfig and ExtendedConfig
@SpringJUnitConfig(ExtendedConfig::class) <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest : BaseTest() {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>superclass에 정의된 configuration file 입니다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>subclass에 정의된 configuration file 입니다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>context initializer를 사용하는 다음 예제에서 <code>ExtendedTest</code> 용 <code>ApplicationContext</code> 는 <code>BaseInitializer</code> 및 <code>ExtendedInitializer</code> 를 사용하여 초기화됩니다.
그러나 initializer가 호출되는 순서는 Spring의 <code>Ordered</code> interface를 구현하는지 또는 Spring의 <code>@Order</code> annotation 또는 표준 <code>@Priority</code> annotation으로 주석 처리되는지 여부에 따라 다릅니다.
다음 예제는 한 class가 다른 class를 확장하고 자체 initializer와 superclass의 initializer를 모두 사용하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// ApplicationContext will be initialized by BaseInitializer
@SpringJUnitConfig(initializers = BaseInitializer.class) <i class="conum" data-value="1"></i><b>(1)</b>
class BaseTest {
    // class body...
}

// ApplicationContext will be initialized by BaseInitializer
// and ExtendedInitializer
@SpringJUnitConfig(initializers = ExtendedInitializer.class) <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest extends BaseTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>superclass에 정의된 initializer 입니다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>subclass에 정의된 initializer 입니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// ApplicationContext will be initialized by BaseInitializer
@SpringJUnitConfig(initializers = [BaseInitializer::class]) <i class="conum" data-value="1"></i><b>(1)</b>
open class BaseTest {
    // class body...
}

// ApplicationContext will be initialized by BaseInitializer
// and ExtendedInitializer
@SpringJUnitConfig(initializers = [ExtendedInitializer::class]) <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest : BaseTest() {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>superclass에 정의된 initializer 입니다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>subclass에 정의된 initializer 입니다.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-env-profiles">Context Configuration with Environment Profiles</h5>
<div class="paragraph">
<p>Spring Framework는 environment 및 profile (일명 "bean definition profiles") 개념에 대한 최고 수준의 지원을 제공하며 다양한 테스트 시나리오에 대해 특정 bean definition profile을 활성화하도록 통합 테스트를 구성 할 수 있습니다.
이는 <code>@ActiveProfiles</code> annotation으로 test class에 annotation을 작성하고 테스트를 위해 `ApplicationContext`를 로드할 때 활성화해야하는 profile 목록을 제공하여 수행됩니다.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>SmartContextLoader</code> SPI 구현과 함께 <code>@ActiveProfiles</code> 를 사용할 수 있지만 이전 <code>ContextLoader</code> SPI 구현에서는 <code>@ActiveProfiles</code> 가 지원되지 않습니다.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>XML configuration 및 <code>@Configuration</code> class가 있는 두 가지 예를 고려하십시오:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- app-config.xml --&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jdbc="http://www.springframework.org/schema/jdbc"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="..."&gt;

    &lt;bean id="transferService"
            class="com.bank.service.internal.DefaultTransferService"&gt;
        &lt;constructor-arg ref="accountRepository"/&gt;
        &lt;constructor-arg ref="feePolicy"/&gt;
    &lt;/bean&gt;

    &lt;bean id="accountRepository"
            class="com.bank.repository.internal.JdbcAccountRepository"&gt;
        &lt;constructor-arg ref="dataSource"/&gt;
    &lt;/bean&gt;

    &lt;bean id="feePolicy"
        class="com.bank.service.internal.ZeroFeePolicy"/&gt;

    &lt;beans profile="dev"&gt;
        &lt;jdbc:embedded-database id="dataSource"&gt;
            &lt;jdbc:script
                location="classpath:com/bank/config/sql/schema.sql"/&gt;
            &lt;jdbc:script
                location="classpath:com/bank/config/sql/test-data.sql"/&gt;
        &lt;/jdbc:embedded-database&gt;
    &lt;/beans&gt;

    &lt;beans profile="production"&gt;
        &lt;jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/&gt;
    &lt;/beans&gt;

    &lt;beans profile="default"&gt;
        &lt;jdbc:embedded-database id="dataSource"&gt;
            &lt;jdbc:script
                location="classpath:com/bank/config/sql/schema.sql"/&gt;
        &lt;/jdbc:embedded-database&gt;
    &lt;/beans&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "classpath:/app-config.xml"
@ContextConfiguration("/app-config.xml")
@ActiveProfiles("dev")
class TransferServiceTest {

    @Autowired
    TransferService transferService;

    @Test
    void testTransferService() {
        // test the transferService
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from "classpath:/app-config.xml"
@ContextConfiguration("/app-config.xml")
@ActiveProfiles("dev")
class TransferServiceTest {

    @Autowired
    lateinit var transferService: TransferService

    @Test
    fun testTransferService() {
        // test the transferService
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TransferServiceTest</code> 가 실행되면 해당 <code>ApplicationContext</code> 가 classpath의 root에 있는 <code>app-config.xml</code> configuration file에서 로드됩니다.
<code>app-config.xml</code> 을 살펴보면 <code>accountRepository</code> bean이 <code>dataSource</code> bean에 종속되어 있음을 알 수 있습니다.
단, <code>dataSource</code> 는 top-level bean으로 정의되어 있지 않습니다.
대신 <code>dataSource</code> 는 <code>production</code> profile, <code>dev</code> profile 및 <code>default</code> profile에 세 번 정의됩니다.</p>
</div>
<div class="paragraph">
<p><code>@ActiveProfiles("dev")</code> 로 <code>TransferServiceTest</code> 에 annotation을 달아 Spring TestContext framework에 active profile이 <code>{"dev"}</code> 로 설정된 <code>ApplicationContext</code> 를 로드하도록 지시합니다.
결과적으로 embedded database가 생성되고 테스트 데이터로 채워지며 <code>accountRepository</code> bean은 개발 <code>DastaSource</code> 에 대한 참조와 연결됩니다.
그것은 통합 테스트에서 우리가 원하는 것입니다.</p>
</div>
<div class="paragraph">
<p>bean을 <code>default</code> profile에 할당하는 것이 때때로 유용합니다.
default profile 내의 bean은 다른 profile이 특별히 활성화되지 않은 경우에만 포함됩니다.
이를 사용하여 application의 default state에서 사용할 &#8220;fallback&#8221; bean을 정의 할 수 있습니다.
예를 들어 <code>dev</code> 및 <code>production</code> profile에 대한 data source를 명시 적으로 제공 할 수 있지만 둘 다 활성화되지 않은 경우 in-memory data source를 기본값으로 정의할 수 있습니다.</p>
</div>
<div class="paragraph">
<p>다음 code 목록은 XML 대신 <code>@Configuration</code> class를 사용하여 동일한 configuration 및 통합 테스트를 구현하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@Profile("dev")
public class StandaloneDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .addScript("classpath:com/bank/config/sql/test-data.sql")
            .build();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@Profile("dev")
class StandaloneDataConfig {

    @Bean
    fun dataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript("classpath:com/bank/config/sql/schema.sql")
                .addScript("classpath:com/bank/config/sql/test-data.sql")
                .build()
    }
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@Profile("production")
public class JndiDataConfig {

    @Bean(destroyMethod="")
    public DataSource dataSource() throws Exception {
        Context ctx = new InitialContext();
        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@Profile("production")
class JndiDataConfig {

    @Bean(destroyMethod = "")
    fun dataSource(): DataSource {
        val ctx = InitialContext()
        return ctx.lookup("java:comp/env/jdbc/datasource") as DataSource
    }
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@Profile("default")
public class DefaultDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .build();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@Profile("default")
class DefaultDataConfig {

    @Bean
    fun dataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript("classpath:com/bank/config/sql/schema.sql")
                .build()
    }
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class TransferServiceConfig {

    @Autowired DataSource dataSource;

    @Bean
    public TransferService transferService() {
        return new DefaultTransferService(accountRepository(), feePolicy());
    }

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }

    @Bean
    public FeePolicy feePolicy() {
        return new ZeroFeePolicy();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class TransferServiceConfig {

    @Autowired
    lateinit var dataSource: DataSource

    @Bean
    fun transferService(): TransferService {
        return DefaultTransferService(accountRepository(), feePolicy())
    }

    @Bean
    fun accountRepository(): AccountRepository {
        return JdbcAccountRepository(dataSource)
    }

    @Bean
    fun feePolicy(): FeePolicy {
        return ZeroFeePolicy()
    }
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig({
        TransferServiceConfig.class,
        StandaloneDataConfig.class,
        JndiDataConfig.class,
        DefaultDataConfig.class})
@ActiveProfiles("dev")
class TransferServiceTest {

    @Autowired
    TransferService transferService;

    @Test
    void testTransferService() {
        // test the transferService
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(
        TransferServiceConfig::class,
        StandaloneDataConfig::class,
        JndiDataConfig::class,
        DefaultDataConfig::class)
@ActiveProfiles("dev")
class TransferServiceTest {

    @Autowired
    lateinit var transferService: TransferService

    @Test
    fun testTransferService() {
        // test the transferService
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>이 변형에서는 XML configuration을 4개의 독립적인 <code>@Configuration</code> class로 나누었습니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TransferServiceConfig</code>: <code>@Autowired</code> 를 사용하여 dependency injection을 통해 <code>dataSource</code> 를 획득합니다.</p>
</li>
<li>
<p><code>StandaloneDataConfig</code>: 개발자 테스트에 적합한 embedded database의 <code>dataSource</code> 를 정의합니다</p>
</li>
<li>
<p><code>JndiDataConfig</code>: production environment의 JNDI에서 검색되는 <code>dataSource</code> 를 정의합니다.</p>
</li>
<li>
<p><code>DefaultDataConfig</code>: profile이 활성화되지 않은 경우 default embedded database에 대한 <code>dataSource</code> 를 정의합니다.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>XML-based configuration 예제와 마찬가지로 여전히 <code>@ActiveProfiles("dev")</code> 로 <code>TransferServiceTest</code> 에 annotation을 달지만 이번에는 <code>@ContextConfiguration</code> annotation을 사용하여 네 가지 configuration classe를 모두 지정합니다.
test class의 본문 자체는 완전히 변경되지 않습니다.</p>
</div>
<div class="paragraph">
<p>특정 프로젝트 내의 여러 test class에서 profile single set이 사용되는 경우가 많습니다.
따라서 <code>@ActiveProfiles</code> annotation의 중복 선언을 방지하기 위해 base class에서 <code>@ActiveProfiles</code> 를 한 번 선언할 수 있으며 subclass는 base class에서 <code>@ActiveProfiles</code> configuration을 자동으로 상속합니다.
다음 예제에서 <code>@ActiveProfiles</code> 선언 (및 기타 annotation)이 abstract superclass 인 <code>AbstractIntegrationTest</code> 로 이동되었습니다:</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Framework 5.3부터 테스트 구성은 enclosing class에서 상속 될 수도 있습니다.
자세한 내용은 <a href="#testcontext-junit-jupiter-nested-test-configuration"><code>@Nested</code> test class configuration</a>을 참조하십시오.
</td>
</tr>
</table>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig({
        TransferServiceConfig.class,
        StandaloneDataConfig.class,
        JndiDataConfig.class,
        DefaultDataConfig.class})
@ActiveProfiles("dev")
abstract class AbstractIntegrationTest {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(
        TransferServiceConfig::class,
        StandaloneDataConfig::class,
        JndiDataConfig::class,
        DefaultDataConfig::class)
@ActiveProfiles("dev")
abstract class AbstractIntegrationTest {
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// "dev" profile inherited from superclass
class TransferServiceTest extends AbstractIntegrationTest {

    @Autowired
    TransferService transferService;

    @Test
    void testTransferService() {
        // test the transferService
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// "dev" profile inherited from superclass
class TransferServiceTest : AbstractIntegrationTest() {

    @Autowired
    lateinit var transferService: TransferService

    @Test
    fun testTransferService() {
        // test the transferService
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@ActiveProfiles</code> 는 다음 예제와 같이 active profile의 상속을 비활성화 하는데 사용할 수있는 <code>inheritProfiles</code> attribute도 지원합니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// "dev" profile overridden with "production"
@ActiveProfiles(profiles = "production", inheritProfiles = false)
class ProductionTransferServiceTest extends AbstractIntegrationTest {
    // test body
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// "dev" profile overridden with "production"
@ActiveProfiles("production", inheritProfiles = false)
class ProductionTransferServiceTest : AbstractIntegrationTest() {
    // test body
}</code></pre>
</div>
</div>
<div id="testcontext-ctx-management-env-profiles-ActiveProfilesResolver" class="paragraph">
<p>또한, 테스트 용 active profile을 선언적 방식이 아닌 프로그래밍 방식으로 해결해야하는 경우도 있습니다.
예를 들면 다음과 같습니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>현재 운영 체제.</p>
</li>
<li>
<p>지속적 통합 빌드 서버에서 테스트가 실행되고 있는지 여부.</p>
</li>
<li>
<p>특정 environment variable의 존재 여부.</p>
</li>
<li>
<p>custom class-level annotation 존재 여부</p>
</li>
<li>
<p>기타 문제</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>프로그래밍 방식으로 active Bean definition profile을 분석하려면 custom <code>ActiveProfilesResolver</code> 를 구현하고 <code>@ActiveProfiles`의 `resolver</code> attribute을 사용하여 등록할 수 있습니다.
자세한 정보는 해당 <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/context/ActiveProfilesResolver.html">javadoc</a>을 참조하세요.
다음 예제는 custom <code>OperatingSystemActiveProfilesResolver</code> 를 구현하고 등록하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// "dev" profile overridden programmatically via a custom resolver
@ActiveProfiles(
        resolver = OperatingSystemActiveProfilesResolver.class,
        inheritProfiles = false)
class TransferServiceTest extends AbstractIntegrationTest {
    // test body
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// "dev" profile overridden programmatically via a custom resolver
@ActiveProfiles(
        resolver = OperatingSystemActiveProfilesResolver::class,
        inheritProfiles = false)
class TransferServiceTest : AbstractIntegrationTest() {
    // test body
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class OperatingSystemActiveProfilesResolver implements ActiveProfilesResolver {

    @Override
    public String[] resolve(Class&lt;?&gt; testClass) {
        String profile = ...;
        // determine the value of profile based on the operating system
        return new String[] {profile};
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class OperatingSystemActiveProfilesResolver : ActiveProfilesResolver {

    override fun resolve(testClass: Class&lt;*&gt;): Array&lt;String&gt; {
        val profile: String = ...
        // determine the value of profile based on the operating system
        return arrayOf(profile)
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-property-sources">Context Configuration with Test Property Sources</h5>
<div class="paragraph">
<p>Spring Framework는 property sources hierarchy가 있는 environment 개념에 대한 최고 수준의 지원을 제공하며 테스트 별 property sources로 통합 테스트를 구성할 수 있습니다.
<code>@Configuration</code> class에서 사용되는 <code>@PropertySource</code> annotation과 달리 test class에서 <code>@TestPropertySource</code> annotation을 선언하여 test properties file 또는 inlined properties에 대한 resource location을 선언할 수 있습니다.
이러한 test property source는 annotation이 있는 통합 테스트를 위해 로드된 <code>ApplicationContext</code> 에 대한 <code>Environment</code> 의 <code>PropertySources</code> set에 추가됩니다.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>SmartContextLoader</code> SPI의 모든 구현과 함께 <code>@TestPropertySource</code> 를 사용할 수 있지만 <code>@TestPropertySource</code> 는 이전 <code>ContextLoader</code> SPI의 구현에서 지원되지 않습니다.</p>
</div>
<div class="paragraph">
<p><code>SmartContextLoader</code> 의 구현은 <code>MergedContextConfiguration</code> 의 <code>getPropertySourceLocations()</code> 및 <code>getPropertySourceProperties()</code> method를 통해 병합된 test property source value에 액세스 할 수 있습니다.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_declaring_test_property_sources">Declaring Test Property Sources</h6>
<div class="paragraph">
<p><code>@TestPropertySource`의 `locations</code> 또는 <code>value</code> attribute을 사용하여 test properties file을 구성 할 수 있습니다.</p>
</div>
<div class="paragraph">
<p>기존 및 XML XML-based properties file format이 모두 지원됩니다 — 예 : <code>"classpath:/com/example/test.properties"</code> 또는 <code>"file:///path/to/file.xml"</code></p>
</div>
<div class="paragraph">
<p>각 경로는 Spring <code>Resource</code> 로 해석됩니다.
일반 path(예 : <code>"test.properties"</code>)는 test class가 정의된 package에 상대적인 classpath resource로 처리됩니다.
slash로 시작하는 path는 absolute classpath resource로 처리됩니다 (예 : <code>"/org/example/test.xml"</code>).
URL을 참조하는 path(예 : <code>classpath:</code>, <code>file:</code> 또는 <code>http:</code> prefix가 붙은 path)는 지정된 resource protocol을 사용하여로드됩니다.
resource location wildcards (예 : <code><strong>*/</strong>.properties</code>)는 허용되지 않습니다.
각 위치는 정확히 하나의 <code>.properties</code> 또는 <code>.xml</code> resource로 평가되어야 합니다.</p>
</div>
<div class="paragraph">
<p>다음 예제에서는 test properties file을 사용합니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@TestPropertySource("/test.properties") <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>absolute path로 properties 지정.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@TestPropertySource("/test.properties") <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>absolute path로 properties 지정.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>다음 예제와 같이 <code>@TestPropertySource</code> 의 <code>properties</code> attribute를 사용하여 key-value 쌍의 형태로 inline properties를 구성할 수 있습니다.
모든 key-value 쌍은 우선 순위가 가장 높은 단일 테스트 <code>PropertySource`로 둘러싸는 `Environment</code> 에 추가됩니다.</p>
</div>
<div class="paragraph">
<p>key-value 쌍에 대해 지원되는 구문은 Java properties file의 항목에 대해 정의된 구문과 동일합니다:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>key=value</code></p>
</li>
<li>
<p><code>key:value</code></p>
</li>
<li>
<p><code>key value</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>다음 예제는 2개의 inline properties를 설정합니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@TestPropertySource(properties = {"timezone = GMT", "port: 4242"}) <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>key-value 구문의 두 가지 변형을 사용하여 2개의 properties를 설정합니다.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@TestPropertySource(properties = ["timezone = GMT", "port: 4242"]) <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>key-value 구문의 두 가지 변형을 사용하여 2개의 properties를 설정합니다.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring Framework 5.2부터 <code>@TestPropertySource</code> 를 _repeatable annotation_으로 사용할 수 있습니다.
즉, single test class에서 <code>@TestPropertySource</code> 의 여러 선언을 가질 수 있으며 이후 <code>@TestPropertySource</code> annotation의 <code>locations</code> 와 <code>properties`가 이전 `@TestPropertySource</code> annotation의 <code>locations</code> 와 <code>properties</code> 를 재정의합니다.</p>
</div>
<div class="paragraph">
<p>또한 각각 <code>@TestPropertySource`로 meta annotation이 추가된 test class에 구성된 여러 annotation을 선언할 수 있으며 이러한 모든 `@TestPropertySource</code> 선언은 test property sources에 기여합니다.</p>
</div>
<div class="paragraph">
<p>직접 존재하는 <code>@TestPropertySource</code> annotation은 항상 meta 존재하는 <code>@TestPropertySource</code> annotation보다 우선합니다.
즉, 직접 존재하는 <code>@TestPropertySource</code> annotation의 <code>locations</code> 및 <code>properties</code> 는 meta-annotation으로 사용되는 <code>@TestPropertySource</code> annotation의 <code>locations</code> 및 <code>properties</code> 를 재정의합니다.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_default_properties_file_detection">Default Properties File Detection</h6>
<div class="paragraph">
<p><code>@TestPropertySource`가 빈 annotation으로 선언 된 경우 (즉, `locations</code> 또는 <code>properties</code> attributes에 대한 명시적 값이 없음) annotation을 선언한 class와 관련된 default properties file을 감지하려고 시도합니다.
예를 들어, annotation이 달린 test class가 <code>com.example.MyTest</code> 인 경우 해당 default properties file은 <code>classpath:com/example/MyTest.properties</code> 입니다.
기본값을 감지할 수 없는 경우 <code>IllegalStateException</code> 이 발생합니다.</p>
</div>
</div>
<div class="sect5">
<h6 id="_precedence">Precedence</h6>
<div class="paragraph">
<p>Test properties는 <code>@PropertySource</code> 를 사용하여 선언적으로 또는 프로그래밍 방식으로 application에서 추가한 operating system&#8217;s environment, Java system properties 또는 property sources에 정의된 properties 보다 우선 순위가 높습니다.
따라서 test properties를 사용하여 system 및 application property sources에서 로드된 properties를 선택적으로 재정의 할 수 있습니다.
또한 inline properties는 resource location에서 로드된 properties보다 우선 순위가 높습니다.
그러나 <a href="#testcontext-ctx-management-dynamic-property-sources"><code>@DynamicPropertySource</code></a> 를 통해 등록된 properties는 `@TestPropertySource`를 통해 로드된 properties보다 우선 순위가 높습니다.</p>
</div>
<div class="paragraph">
<p>다음 예에서 <code>"/test.properties"</code> 에 정의된 <code>timezone</code> 및 <code>port</code> properties와 모든 properties는 system 및 application property sources에 정의된 동일한 이름의 properties를 재정의합니다.
또한 <code>"/test.properties"</code> file이 <code>timezone</code> 및 <code>port</code> properties에 대한 항목을 정의하면 <code>properties</code> attribute를 사용하여 선언된 inline properties에 의해 재정의됩니다.</p>
</div>
<div class="paragraph">
<p>다음 예제는 file과 inline 모두에서 properties를 지정하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration
@TestPropertySource(
    locations = "/test.properties",
    properties = {"timezone = GMT", "port: 4242"}
)
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration
@TestPropertySource("/test.properties",
        properties = ["timezone = GMT", "port: 4242"]
)
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_inheriting_and_overriding_test_property_sources">Inheriting and Overriding Test Property Sources</h6>
<div class="paragraph">
<p><code>@TestPropertySource`는 superclass에서 선언한 properties file 및 inline properties의 resource location을 상속해야하는지 여부를 나타내는 boolean `inheritLocations</code> 및 <code>inheritProperties`attribute를 지원합니다.
두 flag의 기본 값은 `true</code> 입니다.
즉, test class는 모든 superclass에서 선언한 location과 inline properties를 상속합니다.
특히, test class의 location 및 inline properties는 superclass에서 선언한 location 및 inline properties에 추가됩니다.
따라서 subclasses에는 location 및 inline properties를 확장하는 option이 있습니다.
나중에 나타나는 properties는 이전에 나타나는 동일한 이름의 properties를 shadow (즉, override)합니다.
또한 앞서 언급한 우선 순위 규칙은 상속된 test property source에도 적용됩니다.</p>
</div>
<div class="paragraph">
<p><code>@TestPropertySource</code> 의 <code>inheritLocations</code> 또는 <code>inheritProperties</code> attribute가 false로 설정되면 test class shadow에 대한 location 또는 inline properties가 각각 superclass에 정의된 configuration을 효과적으로 대체합니다.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Framework 5.3부터 test configuration은 enclosing class에서 상속될 수도 있습니다.
자세한 내용은 <a href="#testcontext-junit-jupiter-nested-test-configuration"><code>@Nested</code> test class configuration</a>을 참조하십시오.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>다음 예에서는 <code>base.properties</code> file만 test property source로 사용하여 <code>BaseTest</code> 에 대한 <code>ApplicationContext</code> 를 로드합니다.
반대로 <code>ExtendedTest</code> 용 <code>ApplicationContext</code> 는 <code>base.properties</code> 및 <code>extended.properties</code> file을 test property source location으로 사용하여 로드됩니다.
다음 예제에서는 <code>properties</code> file을 사용하여 subclass와 해당 superclass 모두에서 properties을 정의하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@TestPropertySource("base.properties")
@ContextConfiguration
class BaseTest {
    // ...
}

@TestPropertySource("extended.properties")
@ContextConfiguration
class ExtendedTest extends BaseTest {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@TestPropertySource("base.properties")
@ContextConfiguration
open class BaseTest {
    // ...
}

@TestPropertySource("extended.properties")
@ContextConfiguration
class ExtendedTest : BaseTest() {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>다음 예제에서는 인라인 된 <code>key1</code> property만 사용하여 <code>BaseTest</code> 에 대한 <code>ApplicationContext</code> 를 로드합니다.
반대로 <code>ExtendedTest</code> 용 <code>ApplicationContext</code> 는 인라인 된 <code>key1</code> 및 <code>key2</code> properties를 사용하여 로드됩니다.
다음 예제는 inline properties를 사용하여 subclass와 해당 superclass 모두에서 properties를 정의하는 방법을 보여줍니다:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@TestPropertySource(properties = "key1 = value1")
@ContextConfiguration
class BaseTest {
    // ...
}

@TestPropertySource(properties = "key2 = value2")
@ContextConfiguration
class ExtendedTest extends BaseTest {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@TestPropertySource(properties = ["key1 = value1"])
@ContextConfiguration
open class BaseTest {
    // ...
}

@TestPropertySource(properties = ["key2 = value2"])
@ContextConfiguration
class ExtendedTest : BaseTest() {
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-dynamic-property-sources">Context Configuration with Dynamic Property Sources</h5>
<div class="paragraph">
<p>Spring Framework 5.2.5부터 TestContext framework는 <code>@DynamicPropertySource</code> annotation을 통해 <em>dynamic</em> properties에 대한 지원을 제공합니다.
이 annotation은 통합 테스트를 위해 로드된 <code>ApplicationContext</code> 에 대한 <code>Environment</code> 의 <code>PropertySources</code> set에 dynamic value가 있는 properties를 추가해야하는 통합 테스트에서 사용할 수 있습니다.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@DynamicPropertySource</code> annotation 및 지원 인프라는 원래 <a href="https://www.testcontainers.org/">Testcontainers</a> 기반 테스트의 properties를 Spring 통합 테스트에 쉽게 노출할 수 있도록 설계되었습니다.
그러나 이 기능은 lifecycle이 테스트의 <code>ApplicationContext</code> 외부에서 유지되는 모든 형태의 external resource와 함께 사용할 수도 있습니다.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>class level에서 적용되는 <a href="#testcontext-ctx-management-property-sources"><code>@TestPropertySource</code></a> annotation과 달리 <code>@DynamicPropertySource</code> 는 <code>Environment</code> 에 <em>name-value</em> 쌍을 추가하는 데 사용되는 single <code>DynamicPropertyRegistry</code> argument를 허용하는 <code>static</code> method 에 적용되어야합니다.
값은 동적이며 property이 해결 될 때만 호출되는 <code>Supplier</code> 를 통해 제공됩니다.
일반적으로 Spring <code>ApplicationContext</code> 외부에서 Redis 컨테이너를 관리하기 위해 Testcontainers 프로젝트를 사용하는 다음 예제에서 볼 수 있듯이 method 참조는 값을 제공하는 데 사용됩니다.
관리되는 Redis 컨테이너의 IP address와 port는 <code>redis.host</code> 및 <code>redis.port</code> properties를 통해 테스트의 <code>ApplicationContext</code> 내의 component에서 사용할 수 있습니다.
이러한 properties는 Spring의 <code>Environment</code> 추상화를 통해 액세스하거나 Spring 관리 components에 직접 inject 할 수 있습니다 (예 : 각각 <code>@Value("${redis.host}")</code> 및 <code>@Value("${redis.port}")</code>).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>base class에서 <code>@DynamicPropertySource`를 사용하고 subclass간에  dynamic properties가 변경되어 subclass의 테스트가 실패하는 것을 발견하면 각 subclass가 올바른 dynamic properties 가 있는 고유한 `ApplicationContext</code> 를 가져 오도록 base class에 <a href="#spring-testing-annotation-dirtiescontext"><code>@DirtiesContext</code></a>를 annotation 처리해야할 수 있습니다.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(/* ... */)
@Testcontainers
class ExampleIntegrationTests {

    @Container
    static RedisContainer redis = new RedisContainer();

    @DynamicPropertySource
    static void redisProperties(DynamicPropertyRegistry registry) {
        registry.add("redis.host", redis::getContainerIpAddress);
        registry.add("redis.port", redis::getMappedPort);
    }

    // tests ...

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(/* ... */)
@Testcontainers
class ExampleIntegrationTests {

    companion object {

        @Container
        @JvmStatic
        val redis: RedisContainer = RedisContainer()

        @DynamicPropertySource
        @JvmStatic
        fun redisProperties(registry: DynamicPropertyRegistry) {
            registry.add("redis.host", redis::getContainerIpAddress)
            registry.add("redis.port", redis::getMappedPort)
        }
    }

    // tests ...

}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_precedence_2">Precedence</h6>
<div class="paragraph">
<p>Dynamic properties have higher precedence than those loaded from <code>@TestPropertySource</code>,
the operating system&#8217;s environment, Java system properties, or property sources added by
the application declaratively by using <code>@PropertySource</code> or programmatically. Thus,
dynamic properties can be used to selectively override properties loaded via
<code>@TestPropertySource</code>, system property sources, and application property sources.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-web">Loading a <code>WebApplicationContext</code></h5>
<div class="paragraph">
<p>To instruct the TestContext framework to load a <code>WebApplicationContext</code> instead of a
standard <code>ApplicationContext</code>, you can annotate the respective test class with
<code>@WebAppConfiguration</code>.</p>
</div>
<div class="paragraph">
<p>The presence of <code>@WebAppConfiguration</code> on your test class instructs the TestContext
framework (TCF) that a <code>WebApplicationContext</code> (WAC) should be loaded for your
integration tests. In the background, the TCF makes sure that a <code>MockServletContext</code> is
created and supplied to your test&#8217;s WAC. By default, the base resource path for your
<code>MockServletContext</code> is set to <code>src/main/webapp</code>. This is interpreted as a path relative
to the root of your JVM (normally the path to your project). If you are familiar with the
directory structure of a web application in a Maven project, you know that
<code>src/main/webapp</code> is the default location for the root of your WAR. If you need to
override this default, you can provide an alternate path to the <code>@WebAppConfiguration</code>
annotation (for example, <code>@WebAppConfiguration("src/test/webapp")</code>). If you wish to
reference a base resource path from the classpath instead of the file system, you can use
Spring&#8217;s <code>classpath:</code> prefix.</p>
</div>
<div class="paragraph">
<p>Note that Spring&#8217;s testing support for <code>WebApplicationContext</code> implementations is on par
with its support for standard <code>ApplicationContext</code> implementations. When testing with a
<code>WebApplicationContext</code>, you are free to declare XML configuration files, Groovy scripts,
or <code>@Configuration</code> classes by using <code>@ContextConfiguration</code>. You are also free to use
any other test annotations, such as <code>@ActiveProfiles</code>, <code>@TestExecutionListeners</code>, <code>@Sql</code>,
<code>@Rollback</code>, and others.</p>
</div>
<div class="paragraph">
<p>The remaining examples in this section show some of the various configuration options for
loading a <code>WebApplicationContext</code>. The following example shows the TestContext
framework&#8217;s support for convention over configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)

// defaults to "file:src/main/webapp"
@WebAppConfiguration

// detects "WacTests-context.xml" in the same package
// or static nested @Configuration classes
@ContextConfiguration
class WacTests {
    //...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)

// defaults to "file:src/main/webapp"
@WebAppConfiguration

// detects "WacTests-context.xml" in the same package
// or static nested @Configuration classes
@ContextConfiguration
class WacTests {
    //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you annotate a test class with <code>@WebAppConfiguration</code> without specifying a resource
base path, the resource path effectively defaults to <code>file:src/main/webapp</code>. Similarly,
if you declare <code>@ContextConfiguration</code> without specifying resource <code>locations</code>, component
<code>classes</code>, or context <code>initializers</code>, Spring tries to detect the presence of your
configuration by using conventions (that is, <code>WacTests-context.xml</code> in the same package
as the <code>WacTests</code> class or static nested <code>@Configuration</code> classes).</p>
</div>
<div class="paragraph">
<p>The following example shows how to explicitly declare a resource base path with
<code>@WebAppConfiguration</code> and an XML resource location with <code>@ContextConfiguration</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)

// file system resource
@WebAppConfiguration("webapp")

// classpath resource
@ContextConfiguration("/spring/test-servlet-config.xml")
class WacTests {
    //...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)

// file system resource
@WebAppConfiguration("webapp")

// classpath resource
@ContextConfiguration("/spring/test-servlet-config.xml")
class WacTests {
    //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The important thing to note here is the different semantics for paths with these two
annotations. By default, <code>@WebAppConfiguration</code> resource paths are file system based,
whereas <code>@ContextConfiguration</code> resource locations are classpath based.</p>
</div>
<div class="paragraph">
<p>The following example shows that we can override the default resource semantics for both
annotations by specifying a Spring resource prefix:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)

// classpath resource
@WebAppConfiguration("classpath:test-web-resources")

// file system resource
@ContextConfiguration("file:src/main/webapp/WEB-INF/servlet-config.xml")
class WacTests {
    //...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)

// classpath resource
@WebAppConfiguration("classpath:test-web-resources")

// file system resource
@ContextConfiguration("file:src/main/webapp/WEB-INF/servlet-config.xml")
class WacTests {
    //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Contrast the comments in this example with the previous example.</p>
</div>
<div class="openblock">
<div class="title"><a id="testcontext-ctx-management-web-mocks"></a>Working with Web Mocks</div>
<div class="content">
<div class="paragraph">
<p>To provide comprehensive web testing support, the TestContext framework has a
<code>ServletTestExecutionListener</code> that is enabled by default. When testing against a
<code>WebApplicationContext</code>, this <a href="#testcontext-key-abstractions"><code>TestExecutionListener</code></a>
sets up default thread-local state by using Spring Web&#8217;s <code>RequestContextHolder</code> before
each test method and creates a <code>MockHttpServletRequest</code>, a <code>MockHttpServletResponse</code>, and
a <code>ServletWebRequest</code> based on the base resource path configured with
<code>@WebAppConfiguration</code>. <code>ServletTestExecutionListener</code> also ensures that the
<code>MockHttpServletResponse</code> and <code>ServletWebRequest</code> can be injected into the test instance,
and, once the test is complete, it cleans up thread-local state.</p>
</div>
<div class="paragraph">
<p>Once you have a <code>WebApplicationContext</code> loaded for your test, you might find that you
need to interact with the web mocks&#8201;&#8212;&#8201;for example, to set up your test fixture or to
perform assertions after invoking your web component. The following example shows which
mocks can be autowired into your test instance. Note that the <code>WebApplicationContext</code> and
<code>MockServletContext</code> are both cached across the test suite, whereas the other mocks are
managed per test method by the <code>ServletTestExecutionListener</code>.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitWebConfig
class WacTests {

    @Autowired
    WebApplicationContext wac; // cached

    @Autowired
    MockServletContext servletContext; // cached

    @Autowired
    MockHttpSession session;

    @Autowired
    MockHttpServletRequest request;

    @Autowired
    MockHttpServletResponse response;

    @Autowired
    ServletWebRequest webRequest;

    //...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitWebConfig
class WacTests {

    @Autowired
    lateinit var wac: WebApplicationContext // cached

    @Autowired
    lateinit var servletContext: MockServletContext // cached

    @Autowired
    lateinit var session: MockHttpSession

    @Autowired
    lateinit var request: MockHttpServletRequest

    @Autowired
    lateinit var response: MockHttpServletResponse

    @Autowired
    lateinit var webRequest: ServletWebRequest

    //...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-caching">Context Caching</h5>
<div class="paragraph">
<p>Once the TestContext framework loads an <code>ApplicationContext</code> (or <code>WebApplicationContext</code>)
for a test, that context is cached and reused for all subsequent tests that declare the
same unique context configuration within the same test suite. To understand how caching
works, it is important to understand what is meant by &#8220;unique&#8221; and &#8220;test suite.&#8221;</p>
</div>
<div class="paragraph">
<p>An <code>ApplicationContext</code> can be uniquely identified by the combination of configuration
parameters that is used to load it. Consequently, the unique combination of configuration
parameters is used to generate a key under which the context is cached. The TestContext
framework uses the following configuration parameters to build the context cache key:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>locations</code> (from <code>@ContextConfiguration</code>)</p>
</li>
<li>
<p><code>classes</code> (from <code>@ContextConfiguration</code>)</p>
</li>
<li>
<p><code>contextInitializerClasses</code> (from <code>@ContextConfiguration</code>)</p>
</li>
<li>
<p><code>contextCustomizers</code> (from <code>ContextCustomizerFactory</code>) – this includes
<code>@DynamicPropertySource</code> methods as well as various features from Spring Boot&#8217;s
testing support such as <code>@MockBean</code> and <code>@SpyBean</code>.</p>
</li>
<li>
<p><code>contextLoader</code> (from <code>@ContextConfiguration</code>)</p>
</li>
<li>
<p><code>parent</code> (from <code>@ContextHierarchy</code>)</p>
</li>
<li>
<p><code>activeProfiles</code> (from <code>@ActiveProfiles</code>)</p>
</li>
<li>
<p><code>propertySourceLocations</code> (from <code>@TestPropertySource</code>)</p>
</li>
<li>
<p><code>propertySourceProperties</code> (from <code>@TestPropertySource</code>)</p>
</li>
<li>
<p><code>resourceBasePath</code> (from <code>@WebAppConfiguration</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, if <code>TestClassA</code> specifies <code>{"app-config.xml", "test-config.xml"}</code> for the
<code>locations</code> (or <code>value</code>) attribute of <code>@ContextConfiguration</code>, the TestContext framework
loads the corresponding <code>ApplicationContext</code> and stores it in a <code>static</code> context cache
under a key that is based solely on those locations. So, if <code>TestClassB</code> also defines
<code>{"app-config.xml", "test-config.xml"}</code> for its locations (either explicitly or
implicitly through inheritance) but does not define <code>@WebAppConfiguration</code>, a different
<code>ContextLoader</code>, different active profiles, different context initializers, different
test property sources, or a different parent context, then the same <code>ApplicationContext</code>
is shared by both test classes. This means that the setup cost for loading an application
context is incurred only once (per test suite), and subsequent test execution is much
faster.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Test suites and forked processes</div>
<div class="paragraph">
<p>The Spring TestContext framework stores application contexts in a static cache. This
means that the context is literally stored in a <code>static</code> variable. In other words, if
tests run in separate processes, the static cache is cleared between each test
execution, which effectively disables the caching mechanism.</p>
</div>
<div class="paragraph">
<p>To benefit from the caching mechanism, all tests must run within the same process or test
suite. This can be achieved by executing all tests as a group within an IDE. Similarly,
when executing tests with a build framework such as Ant, Maven, or Gradle, it is
important to make sure that the build framework does not fork between tests. For example,
if the
<a href="https://maven.apache.org/plugins/maven-surefire-plugin/test-mojo.html#forkMode"><code>forkMode</code></a>
for the Maven Surefire plug-in is set to <code>always</code> or <code>pertest</code>, the TestContext framework
cannot cache application contexts between test classes, and the build process runs
significantly more slowly as a result.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The size of the context cache is bounded with a default maximum size of 32. Whenever the
maximum size is reached, a least recently used (LRU) eviction policy is used to evict and
close stale contexts. You can configure the maximum size from the command line or a build
script by setting a JVM system property named <code>spring.test.context.cache.maxSize</code>. As an
alternative, you can set the same property via the
<a href="appendix.html#appendix-spring-properties"><code>SpringProperties</code></a> mechanism.</p>
</div>
<div class="paragraph">
<p>Since having a large number of application contexts loaded within a given test suite can
cause the suite to take an unnecessarily long time to run, it is often beneficial to
know exactly how many contexts have been loaded and cached. To view the statistics for
the underlying context cache, you can set the log level for the
<code>org.springframework.test.context.cache</code> logging category to <code>DEBUG</code>.</p>
</div>
<div class="paragraph">
<p>In the unlikely case that a test corrupts the application context and requires reloading
(for example, by modifying a bean definition or the state of an application object), you
can annotate your test class or test method with <code>@DirtiesContext</code> (see the discussion of
<code>@DirtiesContext</code> in <a href="#spring-testing-annotation-dirtiescontext">Spring Testing
Annotations</a>). This instructs Spring to remove the context from the cache and rebuild
the application context before running the next test that requires the same application
context. Note that support for the <code>@DirtiesContext</code> annotation is provided by the
<code>DirtiesContextBeforeModesTestExecutionListener</code> and the
<code>DirtiesContextTestExecutionListener</code>, which are enabled by default.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">ApplicationContext lifecycle and console logging</div>
<div class="paragraph">
<p>When you need to debug a test executed with the Spring TestContext Framework, it can be
useful to analyze the console output (that is, output to the <code>SYSOUT</code> and <code>SYSERR</code>
streams). Some build tools and IDEs are able to associate console output with a given
test; however, some console output cannot be easily associated with a given test.</p>
</div>
<div class="paragraph">
<p>With regard to console logging triggered by the Spring Framework itself or by components
registered in the <code>ApplicationContext</code>, it is important to understand the lifecycle of an
<code>ApplicationContext</code> that has been loaded by the Spring TestContext Framework within a
test suite.</p>
</div>
<div class="paragraph">
<p>The <code>ApplicationContext</code> for a test is typically loaded when an instance of the test
class is being prepared&#8201;&#8212;&#8201;for example, to perform dependency injection into <code>@Autowired</code>
fields of the test instance. This means that any console logging triggered during the
initialization of the <code>ApplicationContext</code> typically cannot be associated with an
individual test method. However, if the context is closed immediately before the
execution of a test method according to <a href="#spring-testing-annotation-dirtiescontext"><code>@DirtiesContext</code></a>
semantics, a new instance of the context will be loaded just prior to execution of the
test method. In the latter scenario, an IDE or build tool may potentially associate
console logging with the individual test method.</p>
</div>
<div class="paragraph">
<p>The <code>ApplicationContext</code> for a test can be closed via one of the following scenarios.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The context is closed according to <code>@DirtiesContext</code> semantics.</p>
</li>
<li>
<p>The context is closed because it has been automatically evicted from the cache
according to the LRU eviction policy.</p>
</li>
<li>
<p>The context is closed via a JVM shutdown hook when the JVM for the test suite
terminates.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the context is closed according to <code>@DirtiesContext</code> semantics after a particular test
method, an IDE or build tool may potentially associate console logging with the
individual test method. If the context is closed according to <code>@DirtiesContext</code> semantics
after a test class, any console logging triggered during the shutdown of the
<code>ApplicationContext</code> cannot be associated with an individual test method. Similarly, any
console logging triggered during the shutdown phase via a JVM shutdown hook cannot be
associated with an individual test method.</p>
</div>
<div class="paragraph">
<p>When a Spring <code>ApplicationContext</code> is closed via a JVM shutdown hook, callbacks executed
during the shutdown phase are executed on a thread named <code>SpringContextShutdownHook</code>. So,
if you wish to disable console logging triggered when the <code>ApplicationContext</code> is closed
via a JVM shutdown hook, you may be able to register a custom filter with your logging
framework that allows you to ignore any logging initiated by that thread.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-ctx-hierarchies">Context Hierarchies</h5>
<div class="paragraph">
<p>When writing integration tests that rely on a loaded Spring <code>ApplicationContext</code>, it is
often sufficient to test against a single context. However, there are times when it is
beneficial or even necessary to test against a hierarchy of <code>ApplicationContext</code>
instances. For example, if you are developing a Spring MVC web application, you typically
have a root <code>WebApplicationContext</code> loaded by Spring&#8217;s <code>ContextLoaderListener</code> and a
child <code>WebApplicationContext</code> loaded by Spring&#8217;s <code>DispatcherServlet</code>. This results in a
parent-child context hierarchy where shared components and infrastructure configuration
are declared in the root context and consumed in the child context by web-specific
components. Another use case can be found in Spring Batch applications, where you often
have a parent context that provides configuration for shared batch infrastructure and a
child context for the configuration of a specific batch job.</p>
</div>
<div class="paragraph">
<p>You can write integration tests that use context hierarchies by declaring context
configuration with the <code>@ContextHierarchy</code> annotation, either on an individual test class
or within a test class hierarchy. If a context hierarchy is declared on multiple classes
within a test class hierarchy, you can also merge or override the context configuration
for a specific, named level in the context hierarchy. When merging configuration for a
given level in the hierarchy, the configuration resource type (that is, XML configuration
files or component classes) must be consistent. Otherwise, it is perfectly acceptable to
have different levels in a context hierarchy configured using different resource types.</p>
</div>
<div class="paragraph">
<p>The remaining JUnit Jupiter based examples in this section show common configuration
scenarios for integration tests that require the use of context hierarchies.</p>
</div>
<div class="openblock">
<div class="title">Single test class with context hierarchy</div>
<div class="content">
<div class="paragraph">
<p><code>ControllerIntegrationTests</code> represents a typical integration testing scenario for a
Spring MVC web application by declaring a context hierarchy that consists of two levels,
one for the root <code>WebApplicationContext</code> (loaded by using the <code>TestAppConfig</code>
<code>@Configuration</code> class) and one for the dispatcher servlet <code>WebApplicationContext</code>
(loaded by using the <code>WebConfig</code> <code>@Configuration</code> class). The <code>WebApplicationContext</code>
that is autowired into the test instance is the one for the child context (that is, the
lowest context in the hierarchy). The following listing shows this configuration scenario:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
@WebAppConfiguration
@ContextHierarchy({
    @ContextConfiguration(classes = TestAppConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})
class ControllerIntegrationTests {

    @Autowired
    WebApplicationContext wac;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
@WebAppConfiguration
@ContextHierarchy(
    ContextConfiguration(classes = [TestAppConfig::class]),
    ContextConfiguration(classes = [WebConfig::class]))
class ControllerIntegrationTests {

    @Autowired
    lateinit var wac: WebApplicationContext

    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="title">Class hierarchy with implicit parent context</div>
<div class="content">
<div class="paragraph">
<p>The test classes in this example define a context hierarchy within a test class
hierarchy. <code>AbstractWebTests</code> declares the configuration for a root
<code>WebApplicationContext</code> in a Spring-powered web application. Note, however, that
<code>AbstractWebTests</code> does not declare <code>@ContextHierarchy</code>. Consequently, subclasses of
<code>AbstractWebTests</code> can optionally participate in a context hierarchy or follow the
standard semantics for <code>@ContextConfiguration</code>. <code>SoapWebServiceTests</code> and
<code>RestWebServiceTests</code> both extend <code>AbstractWebTests</code> and define a context hierarchy by
using <code>@ContextHierarchy</code>. The result is that three application contexts are loaded (one
for each declaration of <code>@ContextConfiguration</code>), and the application context loaded
based on the configuration in <code>AbstractWebTests</code> is set as the parent context for each of
the contexts loaded for the concrete subclasses. The following listing shows this
configuration scenario:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
@WebAppConfiguration
@ContextConfiguration("file:src/main/webapp/WEB-INF/applicationContext.xml")
public abstract class AbstractWebTests {}

@ContextHierarchy(@ContextConfiguration("/spring/soap-ws-config.xml"))
public class SoapWebServiceTests extends AbstractWebTests {}

@ContextHierarchy(@ContextConfiguration("/spring/rest-ws-config.xml"))
public class RestWebServiceTests extends AbstractWebTests {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
@WebAppConfiguration
@ContextConfiguration("file:src/main/webapp/WEB-INF/applicationContext.xml")
abstract class AbstractWebTests

@ContextHierarchy(ContextConfiguration("/spring/soap-ws-config.xml"))
class SoapWebServiceTests : AbstractWebTests()

@ContextHierarchy(ContextConfiguration("/spring/rest-ws-config.xml"))
class RestWebServiceTests : AbstractWebTests()</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="title">Class hierarchy with merged context hierarchy configuration</div>
<div class="content">
<div class="paragraph">
<p>The classes in this example show the use of named hierarchy levels in order to merge the
configuration for specific levels in a context hierarchy. <code>BaseTests</code> defines two levels
in the hierarchy, <code>parent</code> and <code>child</code>. <code>ExtendedTests</code> extends <code>BaseTests</code> and instructs
the Spring TestContext Framework to merge the context configuration for the <code>child</code>
hierarchy level, by ensuring that the names declared in the <code>name</code> attribute in
<code>@ContextConfiguration</code> are both <code>child</code>. The result is that three application contexts
are loaded: one for <code>/app-config.xml</code>, one for <code>/user-config.xml</code>, and one for
<code>{"/user-config.xml", "/order-config.xml"}</code>. As with the previous example, the
application context loaded from <code>/app-config.xml</code> is set as the parent context for the
contexts loaded from <code>/user-config.xml</code> and <code>{"/user-config.xml", "/order-config.xml"}</code>.
The following listing shows this configuration scenario:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
@ContextHierarchy({
    @ContextConfiguration(name = "parent", locations = "/app-config.xml"),
    @ContextConfiguration(name = "child", locations = "/user-config.xml")
})
class BaseTests {}

@ContextHierarchy(
    @ContextConfiguration(name = "child", locations = "/order-config.xml")
)
class ExtendedTests extends BaseTests {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
@ContextHierarchy(
    ContextConfiguration(name = "parent", locations = ["/app-config.xml"]),
    ContextConfiguration(name = "child", locations = ["/user-config.xml"]))
open class BaseTests {}

@ContextHierarchy(
    ContextConfiguration(name = "child", locations = ["/order-config.xml"])
)
class ExtendedTests : BaseTests() {}</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="title">Class hierarchy with overridden context hierarchy configuration</div>
<div class="content">
<div class="paragraph">
<p>In contrast to the previous example, this example demonstrates how to override the
configuration for a given named level in a context hierarchy by setting the
<code>inheritLocations</code> flag in <code>@ContextConfiguration</code> to <code>false</code>. Consequently, the
application context for <code>ExtendedTests</code> is loaded only from <code>/test-user-config.xml</code> and
has its parent set to the context loaded from <code>/app-config.xml</code>. The following listing
shows this configuration scenario:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
@ContextHierarchy({
    @ContextConfiguration(name = "parent", locations = "/app-config.xml"),
    @ContextConfiguration(name = "child", locations = "/user-config.xml")
})
class BaseTests {}

@ContextHierarchy(
    @ContextConfiguration(
        name = "child",
        locations = "/test-user-config.xml",
        inheritLocations = false
))
class ExtendedTests extends BaseTests {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
@ContextHierarchy(
    ContextConfiguration(name = "parent", locations = ["/app-config.xml"]),
    ContextConfiguration(name = "child", locations = ["/user-config.xml"]))
open class BaseTests {}

@ContextHierarchy(
        ContextConfiguration(
                name = "child",
                locations = ["/test-user-config.xml"],
                inheritLocations = false
        ))
class ExtendedTests : BaseTests() {}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Dirtying a context within a context hierarchy</div>
If you use <code>@DirtiesContext</code> in a test whose context is configured as part of a
context hierarchy, you can use the <code>hierarchyMode</code> flag to control how the context cache
is cleared. For further details, see the discussion of <code>@DirtiesContext</code> in
<a href="#spring-testing-annotation-dirtiescontext">Spring Testing Annotations</a> and the
<a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/annotation/DirtiesContext.html"><code>@DirtiesContext</code></a> javadoc.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-fixture-di">Dependency Injection of Test Fixtures</h4>
<div class="paragraph">
<p>When you use the <code>DependencyInjectionTestExecutionListener</code> (which is configured by
default), the dependencies of your test instances are injected from beans in the
application context that you configured with <code>@ContextConfiguration</code> or related
annotations. You may use setter injection, field injection, or both, depending on
which annotations you choose and whether you place them on setter methods or fields.
If you are using JUnit Jupiter you may also optionally use constructor injection
(see <a href="#testcontext-junit-jupiter-di">Dependency Injection with <code>SpringExtension</code></a>). For consistency with Spring&#8217;s annotation-based
injection support, you may also use Spring&#8217;s <code>@Autowired</code> annotation or the <code>@Inject</code>
annotation from JSR-330 for field and setter injection.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For testing frameworks other than JUnit Jupiter, the TestContext framework does not
participate in instantiation of the test class. Thus, the use of <code>@Autowired</code> or
<code>@Inject</code> for constructors has no effect for test classes.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although field injection is discouraged in production code, field injection is
actually quite natural in test code. The rationale for the difference is that you will
never instantiate your test class directly. Consequently, there is no need to be able to
invoke a <code>public</code> constructor or setter method on your test class.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Because <code>@Autowired</code> is used to perform <a href="core.html#beans-factory-autowire">autowiring by
type</a>, if you have multiple bean definitions of the same type, you cannot rely on this
approach for those particular beans. In that case, you can use <code>@Autowired</code> in
conjunction with <code>@Qualifier</code>. You can also choose to use <code>@Inject</code> in conjunction with
<code>@Named</code>. Alternatively, if your test class has access to its <code>ApplicationContext</code>, you
can perform an explicit lookup by using (for example) a call to
<code>applicationContext.getBean("titleRepository", TitleRepository.class)</code>.</p>
</div>
<div class="paragraph">
<p>If you do not want dependency injection applied to your test instances, do not annotate
fields or setter methods with <code>@Autowired</code> or <code>@Inject</code>. Alternatively, you can disable
dependency injection altogether by explicitly configuring your class with
<code>@TestExecutionListeners</code> and omitting <code>DependencyInjectionTestExecutionListener.class</code>
from the list of listeners.</p>
</div>
<div class="paragraph">
<p>Consider the scenario of testing a <code>HibernateTitleRepository</code> class, as outlined in the
<a href="#integration-testing-goals">Goals</a> section. The next two code listings demonstrate the
use of <code>@Autowired</code> on fields and setter methods. The application context configuration
is presented after all sample code listings.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The dependency injection behavior in the following code listings is not specific to JUnit
Jupiter. The same DI techniques can be used in conjunction with any supported testing
framework.</p>
</div>
<div class="paragraph">
<p>The following examples make calls to static assertion methods, such as <code>assertNotNull()</code>,
but without prepending the call with <code>Assertions</code>. In such cases, assume that the method
was properly imported through an <code>import static</code> declaration that is not shown in the
example.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The first code listing shows a JUnit Jupiter based implementation of the test class that
uses <code>@Autowired</code> for field injection:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration("repository-config.xml")
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    @Autowired
    HibernateTitleRepository titleRepository;

    @Test
    void findById() {
        Title title = titleRepository.findById(new Long(10));
        assertNotNull(title);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration("repository-config.xml")
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    @Autowired
    lateinit var titleRepository: HibernateTitleRepository

    @Test
    fun findById() {
        val title = titleRepository.findById(10)
        assertNotNull(title)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can configure the class to use <code>@Autowired</code> for setter injection, as
follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ExtendWith(SpringExtension.class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration("repository-config.xml")
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    HibernateTitleRepository titleRepository;

    @Autowired
    void setTitleRepository(HibernateTitleRepository titleRepository) {
        this.titleRepository = titleRepository;
    }

    @Test
    void findById() {
        Title title = titleRepository.findById(new Long(10));
        assertNotNull(title);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ExtendWith(SpringExtension::class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration("repository-config.xml")
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    lateinit var titleRepository: HibernateTitleRepository

    @Autowired
    fun setTitleRepository(titleRepository: HibernateTitleRepository) {
        this.titleRepository = titleRepository
    }

    @Test
    fun findById() {
        val title = titleRepository.findById(10)
        assertNotNull(title)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding code listings use the same XML context file referenced by the
<code>@ContextConfiguration</code> annotation (that is, <code>repository-config.xml</code>). The following
shows this configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;!-- this bean will be injected into the HibernateTitleRepositoryTests class --&gt;
    &lt;bean id="titleRepository" class="com.foo.repository.hibernate.HibernateTitleRepository"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;

    &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt;
        &lt;!-- configuration elided for brevity --&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you are extending from a Spring-provided test base class that happens to use
<code>@Autowired</code> on one of its setter methods, you might have multiple beans of the affected
type defined in your application context (for example, multiple <code>DataSource</code> beans). In
such a case, you can override the setter method and use the <code>@Qualifier</code> annotation to
indicate a specific target bean, as follows (but make sure to delegate to the overridden
method in the superclass as well):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// ...

    @Autowired
    @Override
    public void setDataSource(@Qualifier("myDataSource") DataSource dataSource) {
        super.setDataSource(dataSource);
    }

// ...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// ...

    @Autowired
    override fun setDataSource(@Qualifier("myDataSource") dataSource: DataSource) {
        super.setDataSource(dataSource)
    }

// ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The specified qualifier value indicates the specific <code>DataSource</code> bean to inject,
narrowing the set of type matches to a specific bean. Its value is matched against
<code>&lt;qualifier&gt;</code> declarations within the corresponding <code>&lt;bean&gt;</code> definitions. The bean name
is used as a fallback qualifier value, so you can effectively also point to a specific
bean by name there (as shown earlier, assuming that <code>myDataSource</code> is the bean <code>id</code>).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-web-scoped-beans">Testing Request- and Session-scoped Beans</h4>
<div class="paragraph">
<p>Spring has supported <a href="core.html#beans-factory-scopes-other">Request- and session-scoped
beans</a> since the early years, and you can test your request-scoped and session-scoped
beans by following these steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ensure that a <code>WebApplicationContext</code> is loaded for your test by annotating your test
class with <code>@WebAppConfiguration</code>.</p>
</li>
<li>
<p>Inject the mock request or session into your test instance and prepare your test
fixture as appropriate.</p>
</li>
<li>
<p>Invoke your web component that you retrieved from the configured
<code>WebApplicationContext</code> (with dependency injection).</p>
</li>
<li>
<p>Perform assertions against the mocks.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The next code snippet shows the XML configuration for a login use case. Note that the
<code>userService</code> bean has a dependency on a request-scoped <code>loginAction</code> bean. Also, the
<code>LoginAction</code> is instantiated by using <a href="core.html#expressions">SpEL expressions</a> that
retrieve the username and password from the current HTTP request. In our test, we want to
configure these request parameters through the mock managed by the TestContext framework.
The following listing shows the configuration for this use case:</p>
</div>
<div class="listingblock">
<div class="title">Request-scoped bean configuration</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;bean id="userService" class="com.example.SimpleUserService"
            c:loginAction-ref="loginAction"/&gt;

    &lt;bean id="loginAction" class="com.example.LoginAction"
            c:username="#{request.getParameter('user')}"
            c:password="#{request.getParameter('pswd')}"
            scope="request"&gt;
        &lt;aop:scoped-proxy/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In <code>RequestScopedBeanTests</code>, we inject both the <code>UserService</code> (that is, the subject under
test) and the <code>MockHttpServletRequest</code> into our test instance. Within our
<code>requestScope()</code> test method, we set up our test fixture by setting request parameters in
the provided <code>MockHttpServletRequest</code>. When the <code>loginUser()</code> method is invoked on our
<code>userService</code>, we are assured that the user service has access to the request-scoped
<code>loginAction</code> for the current <code>MockHttpServletRequest</code> (that is, the one in which we just
set parameters). We can then perform assertions against the results based on the known
inputs for the username and password. The following listing shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitWebConfig
class RequestScopedBeanTests {

    @Autowired UserService userService;
    @Autowired MockHttpServletRequest request;

    @Test
    void requestScope() {
        request.setParameter("user", "enigma");
        request.setParameter("pswd", "$pr!ng");

        LoginResults results = userService.loginUser();
        // assert results
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitWebConfig
class RequestScopedBeanTests {

    @Autowired lateinit var userService: UserService
    @Autowired lateinit var request: MockHttpServletRequest

    @Test
    fun requestScope() {
        request.setParameter("user", "enigma")
        request.setParameter("pswd", "\$pr!ng")

        val results = userService.loginUser()
        // assert results
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following code snippet is similar to the one we saw earlier for a request-scoped
bean. However, this time, the <code>userService</code> bean has a dependency on a session-scoped
<code>userPreferences</code> bean. Note that the <code>UserPreferences</code> bean is instantiated by using a
SpEL expression that retrieves the theme from the current HTTP session. In our test, we
need to configure a theme in the mock session managed by the TestContext framework. The
following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="title">Session-scoped bean configuration</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;bean id="userService" class="com.example.SimpleUserService"
            c:userPreferences-ref="userPreferences" /&gt;

    &lt;bean id="userPreferences" class="com.example.UserPreferences"
            c:theme="#{session.getAttribute('theme')}"
            scope="session"&gt;
        &lt;aop:scoped-proxy/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In <code>SessionScopedBeanTests</code>, we inject the <code>UserService</code> and the <code>MockHttpSession</code> into
our test instance. Within our <code>sessionScope()</code> test method, we set up our test fixture by
setting the expected <code>theme</code> attribute in the provided <code>MockHttpSession</code>. When the
<code>processUserPreferences()</code> method is invoked on our <code>userService</code>, we are assured that
the user service has access to the session-scoped <code>userPreferences</code> for the current
<code>MockHttpSession</code>, and we can perform assertions against the results based on the
configured theme. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitWebConfig
class SessionScopedBeanTests {

    @Autowired UserService userService;
    @Autowired MockHttpSession session;

    @Test
    void sessionScope() throws Exception {
        session.setAttribute("theme", "blue");

        Results results = userService.processUserPreferences();
        // assert results
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitWebConfig
class SessionScopedBeanTests {

    @Autowired lateinit var userService: UserService
    @Autowired lateinit var session: MockHttpSession

    @Test
    fun sessionScope() {
        session.setAttribute("theme", "blue")

        val results = userService.processUserPreferences()
        // assert results
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-tx">Transaction Management</h4>
<div class="paragraph">
<p>In the TestContext framework, transactions are managed by the
<code>TransactionalTestExecutionListener</code>, which is configured by default, even if you do not
explicitly declare <code>@TestExecutionListeners</code> on your test class. To enable support for
transactions, however, you must configure a <code>PlatformTransactionManager</code> bean in the
<code>ApplicationContext</code> that is loaded with <code>@ContextConfiguration</code> semantics (further
details are provided later). In addition, you must declare Spring&#8217;s <code>@Transactional</code>
annotation either at the class or the method level for your tests.</p>
</div>
<div class="sect4">
<h5 id="testcontext-tx-test-managed-transactions">Test-managed Transactions</h5>
<div class="paragraph">
<p>Test-managed transactions are transactions that are managed declaratively by using the
<code>TransactionalTestExecutionListener</code> or programmatically by using <code>TestTransaction</code>
(described later). You should not confuse such transactions with Spring-managed
transactions (those managed directly by Spring within the <code>ApplicationContext</code> loaded for
tests) or application-managed transactions (those managed programmatically within
application code that is invoked by tests). Spring-managed and application-managed
transactions typically participate in test-managed transactions. However, you should use
caution if Spring-managed or application-managed transactions are configured with any
propagation type other than <code>REQUIRED</code> or <code>SUPPORTS</code> (see the discussion on
<a href="data-access.html#tx-propagation">transaction propagation</a> for details).</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="title">Preemptive timeouts and test-managed transactions</div>
<div class="paragraph">
<p>Caution must be taken when using any form of preemptive timeouts from a testing framework
in conjunction with Spring&#8217;s test-managed transactions.</p>
</div>
<div class="paragraph">
<p>Specifically, Spring’s testing support binds transaction state to the current thread (via
a <code>java.lang.ThreadLocal</code> variable) <em>before</em> the current test method is invoked. If a
testing framework invokes the current test method in a new thread in order to support a
preemptive timeout, any actions performed within the current test method will <em>not</em> be
invoked within the test-managed transaction. Consequently, the result of any such actions
will not be rolled back with the test-managed transaction. On the contrary, such actions
will be committed to the persistent store&#8201;&#8212;&#8201;for example, a relational database&#8201;&#8212;&#8201;even
though the test-managed transaction is properly rolled back by Spring.</p>
</div>
<div class="paragraph">
<p>Situations in which this can occur include but are not limited to the following.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JUnit 4&#8217;s <code>@Test(timeout = &#8230;&#8203;)</code> support and <code>TimeOut</code> rule</p>
</li>
<li>
<p>JUnit Jupiter&#8217;s <code>assertTimeoutPreemptively(&#8230;&#8203;)</code> methods in the
<code>org.junit.jupiter.api.Assertions</code> class</p>
</li>
<li>
<p>TestNG&#8217;s <code>@Test(timeOut = &#8230;&#8203;)</code> support</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-enabling-transactions">Enabling and Disabling Transactions</h5>
<div class="paragraph">
<p>Annotating a test method with <code>@Transactional</code> causes the test to be run within a
transaction that is, by default, automatically rolled back after completion of the test.
If a test class is annotated with <code>@Transactional</code>, each test method within that class
hierarchy runs within a transaction. Test methods that are not annotated with
<code>@Transactional</code> (at the class or method level) are not run within a transaction. Note
that <code>@Transactional</code> is not supported on test lifecycle methods — for example, methods
annotated with JUnit Jupiter&#8217;s <code>@BeforeAll</code>, <code>@BeforeEach</code>, etc. Furthermore, tests that
are annotated with <code>@Transactional</code> but have the <code>propagation</code> attribute set to
<code>NOT_SUPPORTED</code> or <code>NEVER</code> are not run within a transaction.</p>
</div>
<table id="testcontext-tx-attribute-support" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. <code>@Transactional</code> attribute support</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Supported for test-managed transactions</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>value</code> and <code>transactionManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>propagation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">only <code>Propagation.NOT_SUPPORTED</code> and <code>Propagation.NEVER</code> are supported</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isolation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>timeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>readOnly</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rollbackFor</code> and <code>rollbackForClassName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no: use <code>TestTransaction.flagForRollback()</code> instead</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>noRollbackFor</code> and <code>noRollbackForClassName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no: use <code>TestTransaction.flagForCommit()</code> instead</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Method-level lifecycle methods — for example, methods annotated with JUnit Jupiter&#8217;s
<code>@BeforeEach</code> or <code>@AfterEach</code> — are run within a test-managed transaction. On the other
hand, suite-level and class-level lifecycle methods — for example, methods annotated with
JUnit Jupiter&#8217;s <code>@BeforeAll</code> or <code>@AfterAll</code> and methods annotated with TestNG&#8217;s
<code>@BeforeSuite</code>, <code>@AfterSuite</code>, <code>@BeforeClass</code>, or <code>@AfterClass</code> — are <em>not</em> run within a
test-managed transaction.</p>
</div>
<div class="paragraph">
<p>If you need to run code in a suite-level or class-level lifecycle method within a
transaction, you may wish to inject a corresponding <code>PlatformTransactionManager</code> into
your test class and then use that with a <code>TransactionTemplate</code> for programmatic
transaction management.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that <a href="#testcontext-support-classes-junit4"><code>AbstractTransactionalJUnit4SpringContextTests</code></a> and
<a href="#testcontext-support-classes-testng"><code>AbstractTransactionalTestNGSpringContextTests</code></a>
are preconfigured for transactional support at the class level.</p>
</div>
<div class="paragraph">
<p>The following example demonstrates a common scenario for writing an integration test for
a Hibernate-based <code>UserRepository</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(TestConfig.class)
@Transactional
class HibernateUserRepositoryTests {

    @Autowired
    HibernateUserRepository repository;

    @Autowired
    SessionFactory sessionFactory;

    JdbcTemplate jdbcTemplate;

    @Autowired
    void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Test
    void createUser() {
        // track initial state in test database:
        final int count = countRowsInTable("user");

        User user = new User(...);
        repository.save(user);

        // Manual flush is required to avoid false positive in test
        sessionFactory.getCurrentSession().flush();
        assertNumUsers(count + 1);
    }

    private int countRowsInTable(String tableName) {
        return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);
    }

    private void assertNumUsers(int expected) {
        assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"));
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(TestConfig::class)
@Transactional
class HibernateUserRepositoryTests {

    @Autowired
    lateinit var repository: HibernateUserRepository

    @Autowired
    lateinit var sessionFactory: SessionFactory

    lateinit var jdbcTemplate: JdbcTemplate

    @Autowired
    fun setDataSource(dataSource: DataSource) {
        this.jdbcTemplate = JdbcTemplate(dataSource)
    }

    @Test
    fun createUser() {
        // track initial state in test database:
        val count = countRowsInTable("user")

        val user = User()
        repository.save(user)

        // Manual flush is required to avoid false positive in test
        sessionFactory.getCurrentSession().flush()
        assertNumUsers(count + 1)
    }

    private fun countRowsInTable(tableName: String): Int {
        return JdbcTestUtils.countRowsInTable(jdbcTemplate, tableName)
    }

    private fun assertNumUsers(expected: Int) {
        assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As explained in <a href="#testcontext-tx-rollback-and-commit-behavior">Transaction Rollback and Commit Behavior</a>, there is no need to
clean up the database after the <code>createUser()</code> method runs, since any changes made to the
database are automatically rolled back by the <code>TransactionalTestExecutionListener</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-rollback-and-commit-behavior">Transaction Rollback and Commit Behavior</h5>
<div class="paragraph">
<p>By default, test transactions will be automatically rolled back after completion of the
test; however, transactional commit and rollback behavior can be configured declaratively
via the <code>@Commit</code> and <code>@Rollback</code> annotations. See the corresponding entries in the
<a href="#integration-testing-annotations">annotation support</a> section for further details.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-programmatic-tx-mgt">Programmatic Transaction Management</h5>
<div class="paragraph">
<p>You can interact with test-managed transactions programmatically by using the static
methods in <code>TestTransaction</code>. For example, you can use <code>TestTransaction</code> within test
methods, before methods, and after methods to start or end the current test-managed
transaction or to configure the current test-managed transaction for rollback or commit.
Support for <code>TestTransaction</code> is automatically available whenever the
<code>TransactionalTestExecutionListener</code> is enabled.</p>
</div>
<div class="paragraph">
<p>The following example demonstrates some of the features of <code>TestTransaction</code>. See the
javadoc for <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/context/transaction/TestTransaction.html"><code>TestTransaction</code></a>
for further details.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ContextConfiguration(classes = TestConfig.class)
public class ProgrammaticTransactionManagementTests extends
        AbstractTransactionalJUnit4SpringContextTests {

    @Test
    public void transactionalTest() {
        // assert initial state in test database:
        assertNumUsers(2);

        deleteFromTables("user");

        // changes to the database will be committed!
        TestTransaction.flagForCommit();
        TestTransaction.end();
        assertFalse(TestTransaction.isActive());
        assertNumUsers(0);

        TestTransaction.start();
        // perform other actions against the database that will
        // be automatically rolled back after the test completes...
    }

    protected void assertNumUsers(int expected) {
        assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"));
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ContextConfiguration(classes = [TestConfig::class])
class ProgrammaticTransactionManagementTests : AbstractTransactionalJUnit4SpringContextTests() {

    @Test
    fun transactionalTest() {
        // assert initial state in test database:
        assertNumUsers(2)

        deleteFromTables("user")

        // changes to the database will be committed!
        TestTransaction.flagForCommit()
        TestTransaction.end()
        assertFalse(TestTransaction.isActive())
        assertNumUsers(0)

        TestTransaction.start()
        // perform other actions against the database that will
        // be automatically rolled back after the test completes...
    }

    protected fun assertNumUsers(expected: Int) {
        assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"))
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-before-and-after-tx">Running Code Outside of a Transaction</h5>
<div class="paragraph">
<p>Occasionally, you may need to run certain code before or after a transactional test
method but outside the transactional context&#8201;&#8212;&#8201;for example, to verify the initial
database state prior to running your test or to verify expected transactional commit
behavior after your test runs (if the test was configured to commit the transaction).
<code>TransactionalTestExecutionListener</code> supports the <code>@BeforeTransaction</code> and
<code>@AfterTransaction</code> annotations for exactly such scenarios. You can annotate any <code>void</code>
method in a test class or any <code>void</code> default method in a test interface with one of these
annotations, and the <code>TransactionalTestExecutionListener</code> ensures that your before
transaction method or after transaction method runs at the appropriate time.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Any before methods (such as methods annotated with JUnit Jupiter&#8217;s <code>@BeforeEach</code>)
and any after methods (such as methods annotated with JUnit Jupiter&#8217;s <code>@AfterEach</code>) are
run within a transaction. In addition, methods annotated with <code>@BeforeTransaction</code> or
<code>@AfterTransaction</code> are not run for test methods that are not configured to run within a
transaction.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-mgr-config">Configuring a Transaction Manager</h5>
<div class="paragraph">
<p><code>TransactionalTestExecutionListener</code> expects a <code>PlatformTransactionManager</code> bean to be
defined in the Spring <code>ApplicationContext</code> for the test. If there are multiple instances
of <code>PlatformTransactionManager</code> within the test&#8217;s <code>ApplicationContext</code>, you can declare a
qualifier by using <code>@Transactional("myTxMgr")</code> or <code>@Transactional(transactionManager =
"myTxMgr")</code>, or <code>TransactionManagementConfigurer</code> can be implemented by an
<code>@Configuration</code> class. Consult the
<a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/context/transaction/TestContextTransactionUtils.html#retrieveTransactionManager-org.springframework.test.context.TestContext-java.lang.String-">javadoc
for <code>TestContextTransactionUtils.retrieveTransactionManager()</code></a> for details on the
algorithm used to look up a transaction manager in the test&#8217;s <code>ApplicationContext</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-annotation-demo">Demonstration of All Transaction-related Annotations</h5>
<div class="paragraph">
<p>The following JUnit Jupiter based example displays a fictitious integration testing
scenario that highlights all transaction-related annotations. The example is not intended
to demonstrate best practices but rather to demonstrate how these annotations can be
used. See the <a href="#integration-testing-annotations">annotation support</a> section for further
information and configuration examples. <a href="#testcontext-executing-sql-declaratively-tx">Transaction management for <code>@Sql</code></a> contains an additional example that uses <code>@Sql</code> for
declarative SQL script execution with default transaction rollback semantics. The
following example shows the relevant annotations:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig
@Transactional(transactionManager = "txMgr")
@Commit
class FictitiousTransactionalTest {

    @BeforeTransaction
    void verifyInitialDatabaseState() {
        // logic to verify the initial state before a transaction is started
    }

    @BeforeEach
    void setUpTestDataWithinTransaction() {
        // set up test data within the transaction
    }

    @Test
    // overrides the class-level @Commit setting
    @Rollback
    void modifyDatabaseWithinTransaction() {
        // logic which uses the test data and modifies database state
    }

    @AfterEach
    void tearDownWithinTransaction() {
        // run "tear down" logic within the transaction
    }

    @AfterTransaction
    void verifyFinalDatabaseState() {
        // logic to verify the final state after transaction has rolled back
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig
@Transactional(transactionManager = "txMgr")
@Commit
class FictitiousTransactionalTest {

    @BeforeTransaction
    fun verifyInitialDatabaseState() {
        // logic to verify the initial state before a transaction is started
    }

    @BeforeEach
    fun setUpTestDataWithinTransaction() {
        // set up test data within the transaction
    }

    @Test
    // overrides the class-level @Commit setting
    @Rollback
    fun modifyDatabaseWithinTransaction() {
        // logic which uses the test data and modifies database state
    }

    @AfterEach
    fun tearDownWithinTransaction() {
        // run "tear down" logic within the transaction
    }

    @AfterTransaction
    fun verifyFinalDatabaseState() {
        // logic to verify the final state after transaction has rolled back
    }

}</code></pre>
</div>
</div>
<div id="testcontext-tx-false-positives" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Avoid false positives when testing ORM code</div>
<div class="paragraph">
<p>When you test application code that manipulates the state of a Hibernate session or JPA
persistence context, make sure to flush the underlying unit of work within test methods
that run that code. Failing to flush the underlying unit of work can produce false
positives: Your test passes, but the same code throws an exception in a live, production
environment. Note that this applies to any ORM framework that maintains an in-memory unit
of work. In the following Hibernate-based example test case, one method demonstrates a
false positive, and the other method correctly exposes the results of flushing the
session:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// ...

@Autowired
SessionFactory sessionFactory;

@Transactional
@Test // no expected exception!
public void falsePositive() {
    updateEntityInHibernateSession();
    // False positive: an exception will be thrown once the Hibernate
    // Session is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
public void updateWithSessionFlush() {
    updateEntityInHibernateSession();
    // Manual flush is required to avoid false positive in test
    sessionFactory.getCurrentSession().flush();
}

// ...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// ...

@Autowired
lateinit var sessionFactory: SessionFactory

@Transactional
@Test // no expected exception!
fun falsePositive() {
    updateEntityInHibernateSession()
    // False positive: an exception will be thrown once the Hibernate
    // Session is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
fun updateWithSessionFlush() {
    updateEntityInHibernateSession()
    // Manual flush is required to avoid false positive in test
    sessionFactory.getCurrentSession().flush()
}

// ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows matching methods for JPA:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// ...

@PersistenceContext
EntityManager entityManager;

@Transactional
@Test // no expected exception!
public void falsePositive() {
    updateEntityInJpaPersistenceContext();
    // False positive: an exception will be thrown once the JPA
    // EntityManager is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
public void updateWithEntityManagerFlush() {
    updateEntityInJpaPersistenceContext();
    // Manual flush is required to avoid false positive in test
    entityManager.flush();
}

// ...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// ...

@PersistenceContext
lateinit var entityManager:EntityManager

@Transactional
@Test // no expected exception!
fun falsePositive() {
    updateEntityInJpaPersistenceContext()
    // False positive: an exception will be thrown once the JPA
    // EntityManager is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
void updateWithEntityManagerFlush() {
    updateEntityInJpaPersistenceContext()
    // Manual flush is required to avoid false positive in test
    entityManager.flush()
}

// ...</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-executing-sql">Executing SQL Scripts</h4>
<div class="paragraph">
<p>When writing integration tests against a relational database, it is often beneficial to
run SQL scripts to modify the database schema or insert test data into tables. The
<code>spring-jdbc</code> module provides support for <em>initializing</em> an embedded or existing database
by executing SQL scripts when the Spring <code>ApplicationContext</code> is loaded. See
<a href="data-access.html#jdbc-embedded-database-support">Embedded database support</a> and
<a href="data-access.html#jdbc-embedded-database-dao-testing">Testing data access logic with an
embedded database</a> for details.</p>
</div>
<div class="paragraph">
<p>Although it is very useful to initialize a database for testing <em>once</em> when the
<code>ApplicationContext</code> is loaded, sometimes it is essential to be able to modify the
database <em>during</em> integration tests. The following sections explain how to run SQL
scripts programmatically and declaratively during integration tests.</p>
</div>
<div class="sect4">
<h5 id="testcontext-executing-sql-programmatically">Executing SQL scripts programmatically</h5>
<div class="paragraph">
<p>Spring provides the following options for executing SQL scripts programmatically within
integration test methods.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.jdbc.datasource.init.ScriptUtils</code></p>
</li>
<li>
<p><code>org.springframework.jdbc.datasource.init.ResourceDatabasePopulator</code></p>
</li>
<li>
<p><code>org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests</code></p>
</li>
<li>
<p><code>org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>ScriptUtils</code> provides a collection of static utility methods for working with SQL
scripts and is mainly intended for internal use within the framework. However, if you
require full control over how SQL scripts are parsed and run, <code>ScriptUtils</code> may suit
your needs better than some of the other alternatives described later. See the
<a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/jdbc/datasource/init/ScriptUtils.html">javadoc</a> for individual
methods in <code>ScriptUtils</code> for further details.</p>
</div>
<div class="paragraph">
<p><code>ResourceDatabasePopulator</code> provides an object-based API for programmatically populating,
initializing, or cleaning up a database by using SQL scripts defined in external
resources. <code>ResourceDatabasePopulator</code> provides options for configuring the character
encoding, statement separator, comment delimiters, and error handling flags used when
parsing and running the scripts. Each of the configuration options has a reasonable
default value. See the
<a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/jdbc/datasource/init/ResourceDatabasePopulator.html">javadoc</a> for
details on default values. To run the scripts configured in a
<code>ResourceDatabasePopulator</code>, you can invoke either the <code>populate(Connection)</code> method to
run the populator against a <code>java.sql.Connection</code> or the <code>execute(DataSource)</code> method
to run the populator against a <code>javax.sql.DataSource</code>. The following example
specifies SQL scripts for a test schema and test data, sets the statement separator to
<code>@@</code>, and run the scripts against a <code>DataSource</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Test
void databaseTest() {
    ResourceDatabasePopulator populator = new ResourceDatabasePopulator();
    populator.addScripts(
            new ClassPathResource("test-schema.sql"),
            new ClassPathResource("test-data.sql"));
    populator.setSeparator("@@");
    populator.execute(this.dataSource);
    // run code that uses the test schema and data
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Test
fun databaseTest() {
    val populator = ResourceDatabasePopulator()
    populator.addScripts(
            ClassPathResource("test-schema.sql"),
            ClassPathResource("test-data.sql"))
    populator.setSeparator("@@")
    populator.execute(dataSource)
    // run code that uses the test schema and data
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>ResourceDatabasePopulator</code> internally delegates to <code>ScriptUtils</code> for parsing
and running SQL scripts. Similarly, the <code>executeSqlScript(..)</code> methods in
<a href="#testcontext-support-classes-junit4"><code>AbstractTransactionalJUnit4SpringContextTests</code></a>
and <a href="#testcontext-support-classes-testng"><code>AbstractTransactionalTestNGSpringContextTests</code></a>
internally use a <code>ResourceDatabasePopulator</code> to run SQL scripts. See the Javadoc for the
various <code>executeSqlScript(..)</code> methods for further details.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-executing-sql-declaratively">Executing SQL scripts declaratively with @Sql</h5>
<div class="paragraph">
<p>In addition to the aforementioned mechanisms for running SQL scripts programmatically,
you can declaratively configure SQL scripts in the Spring TestContext Framework.
Specifically, you can declare the <code>@Sql</code> annotation on a test class or test method to
configure individual SQL statements or the resource paths to SQL scripts that should be
run against a given database before or after an integration test method. Support for
<code>@Sql</code> is provided by the <code>SqlScriptsTestExecutionListener</code>, which is enabled by default.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Method-level <code>@Sql</code> declarations override class-level declarations by default. As
of Spring Framework 5.2, however, this behavior may be configured per test class or per
test method via <code>@SqlMergeMode</code>. See
<a href="#testcontext-executing-sql-declaratively-script-merging">Merging and Overriding Configuration with <code>@SqlMergeMode</code></a> for further details.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="testcontext-executing-sql-declaratively-script-resources">Path Resource Semantics</h6>
<div class="paragraph">
<p>Each path is interpreted as a Spring <code>Resource</code>. A plain path (for example,
<code>"schema.sql"</code>) is treated as a classpath resource that is relative to the package in
which the test class is defined. A path starting with a slash is treated as an absolute
classpath resource (for example, <code>"/org/example/schema.sql"</code>). A path that references a
URL (for example, a path prefixed with <code>classpath:</code>, <code>file:</code>, <code>http:</code>) is loaded by using
the specified resource protocol.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use <code>@Sql</code> at the class level and at the method level
within a JUnit Jupiter based integration test class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig
@Sql("/test-schema.sql")
class DatabaseTests {

    @Test
    void emptySchemaTest() {
        // run code that uses the test schema without any test data
    }

    @Test
    @Sql({"/test-schema.sql", "/test-user-data.sql"})
    void userTest() {
        // run code that uses the test schema and test data
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig
@Sql("/test-schema.sql")
class DatabaseTests {

    @Test
    fun emptySchemaTest() {
        // run code that uses the test schema without any test data
    }

    @Test
    @Sql("/test-schema.sql", "/test-user-data.sql")
    fun userTest() {
        // run code that uses the test schema and test data
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testcontext-executing-sql-declaratively-script-detection">Default Script Detection</h6>
<div class="paragraph">
<p>If no SQL scripts or statements are specified, an attempt is made to detect a <code>default</code>
script, depending on where <code>@Sql</code> is declared. If a default cannot be detected, an
<code>IllegalStateException</code> is thrown.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Class-level declaration: If the annotated test class is <code>com.example.MyTest</code>, the
corresponding default script is <code>classpath:com/example/MyTest.sql</code>.</p>
</li>
<li>
<p>Method-level declaration: If the annotated test method is named <code>testMethod()</code> and is
defined in the class <code>com.example.MyTest</code>, the corresponding default script is
<code>classpath:com/example/MyTest.testMethod.sql</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="testcontext-executing-sql-declaratively-multiple-annotations">Declaring Multiple <code>@Sql</code> Sets</h6>
<div class="paragraph">
<p>If you need to configure multiple sets of SQL scripts for a given test class or test
method but with different syntax configuration, different error handling rules, or
different execution phases per set, you can declare multiple instances of <code>@Sql</code>. With
Java 8, you can use <code>@Sql</code> as a repeatable annotation. Otherwise, you can use the
<code>@SqlGroup</code> annotation as an explicit container for declaring multiple instances of
<code>@Sql</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use <code>@Sql</code> as a repeatable annotation with Java 8:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Test
@Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`"))
@Sql("/test-user-data.sql")
void userTest() {
    // run code that uses the test schema and test data
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Repeatable annotations with non-SOURCE retention are not yet supported by Kotlin</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the scenario presented in the preceding example, the <code>test-schema.sql</code> script uses a
different syntax for single-line comments.</p>
</div>
<div class="paragraph">
<p>The following example is identical to the preceding example, except that the <code>@Sql</code>
declarations are grouped together within <code>@SqlGroup</code>. With Java 8 and above, the use of
<code>@SqlGroup</code> is optional, but you may need to use <code>@SqlGroup</code> for compatibility with
other JVM languages such as Kotlin.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Test
@SqlGroup({
    @Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`")),
    @Sql("/test-user-data.sql")
)}
void userTest() {
    // run code that uses the test schema and test data
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Test
@SqlGroup(
    Sql("/test-schema.sql", config = SqlConfig(commentPrefix = "`")),
    Sql("/test-user-data.sql"))
fun userTest() {
    // Run code that uses the test schema and test data
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testcontext-executing-sql-declaratively-script-execution-phases">Script Execution Phases</h6>
<div class="paragraph">
<p>By default, SQL scripts are run before the corresponding test method. However, if
you need to run a particular set of scripts after the test method (for example, to clean
up database state), you can use the <code>executionPhase</code> attribute in <code>@Sql</code>, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Test
@Sql(
    scripts = "create-test-data.sql",
    config = @SqlConfig(transactionMode = ISOLATED)
)
@Sql(
    scripts = "delete-test-data.sql",
    config = @SqlConfig(transactionMode = ISOLATED),
    executionPhase = AFTER_TEST_METHOD
)
void userTest() {
    // run code that needs the test data to be committed
    // to the database outside of the test's transaction
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Test
@SqlGroup(
    Sql("create-test-data.sql",
        config = SqlConfig(transactionMode = ISOLATED)),
    Sql("delete-test-data.sql",
        config = SqlConfig(transactionMode = ISOLATED),
        executionPhase = AFTER_TEST_METHOD))
fun userTest() {
    // run code that needs the test data to be committed
    // to the database outside of the test's transaction
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>ISOLATED</code> and <code>AFTER_TEST_METHOD</code> are statically imported from
<code>Sql.TransactionMode</code> and <code>Sql.ExecutionPhase</code>, respectively.</p>
</div>
</div>
<div class="sect5">
<h6 id="testcontext-executing-sql-declaratively-script-configuration">Script Configuration with <code>@SqlConfig</code></h6>
<div class="paragraph">
<p>You can configure script parsing and error handling by using the <code>@SqlConfig</code> annotation.
When declared as a class-level annotation on an integration test class, <code>@SqlConfig</code>
serves as global configuration for all SQL scripts within the test class hierarchy. When
declared directly by using the <code>config</code> attribute of the <code>@Sql</code> annotation, <code>@SqlConfig</code>
serves as local configuration for the SQL scripts declared within the enclosing <code>@Sql</code>
annotation. Every attribute in <code>@SqlConfig</code> has an implicit default value, which is
documented in the javadoc of the corresponding attribute. Due to the rules defined for
annotation attributes in the Java Language Specification, it is, unfortunately, not
possible to assign a value of <code>null</code> to an annotation attribute. Thus, in order to
support overrides of inherited global configuration, <code>@SqlConfig</code> attributes have an
explicit default value of either <code>""</code> (for Strings), <code>{}</code> (for arrays), or <code>DEFAULT</code> (for
enumerations). This approach lets local declarations of <code>@SqlConfig</code> selectively override
individual attributes from global declarations of <code>@SqlConfig</code> by providing a value other
than <code>""</code>, <code>{}</code>, or <code>DEFAULT</code>. Global <code>@SqlConfig</code> attributes are inherited whenever
local <code>@SqlConfig</code> attributes do not supply an explicit value other than <code>""</code>, <code>{}</code>, or
<code>DEFAULT</code>. Explicit local configuration, therefore, overrides global configuration.</p>
</div>
<div class="paragraph">
<p>The configuration options provided by <code>@Sql</code> and <code>@SqlConfig</code> are equivalent to those
supported by <code>ScriptUtils</code> and <code>ResourceDatabasePopulator</code> but are a superset of those
provided by the <code>&lt;jdbc:initialize-database/&gt;</code> XML namespace element. See the javadoc of
individual attributes in <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/context/jdbc/Sql.html"><code>@Sql</code></a> and
<a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/context/jdbc/SqlConfig.html"><code>@SqlConfig</code></a> for details.</p>
</div>
<div id="testcontext-executing-sql-declaratively-tx" class="paragraph">
<p><strong>Transaction management for <code>@Sql</code></strong></p>
</div>
<div class="paragraph">
<p>By default, the <code>SqlScriptsTestExecutionListener</code> infers the desired transaction
semantics for scripts configured by using <code>@Sql</code>. Specifically, SQL scripts are run
without a transaction, within an existing Spring-managed transaction (for example, a
transaction managed by the <code>TransactionalTestExecutionListener</code> for a test annotated with
<code>@Transactional</code>), or within an isolated transaction, depending on the configured value
of the <code>transactionMode</code> attribute in <code>@SqlConfig</code> and the presence of a
<code>PlatformTransactionManager</code> in the test&#8217;s <code>ApplicationContext</code>. As a bare minimum,
however, a <code>javax.sql.DataSource</code> must be present in the test&#8217;s <code>ApplicationContext</code>.</p>
</div>
<div class="paragraph">
<p>If the algorithms used by <code>SqlScriptsTestExecutionListener</code> to detect a <code>DataSource</code> and
<code>PlatformTransactionManager</code> and infer the transaction semantics do not suit your needs,
you can specify explicit names by setting the <code>dataSource</code> and <code>transactionManager</code>
attributes of <code>@SqlConfig</code>. Furthermore, you can control the transaction propagation
behavior by setting the <code>transactionMode</code> attribute of <code>@SqlConfig</code> (for example, whether
scripts should be run in an isolated transaction). Although a thorough discussion of all
supported options for transaction management with <code>@Sql</code> is beyond the scope of this
reference manual, the javadoc for
<a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/context/jdbc/SqlConfig.html"><code>@SqlConfig</code></a> and
<a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/context/jdbc/SqlScriptsTestExecutionListener.html"><code>SqlScriptsTestExecutionListener</code></a>
provide detailed information, and the following example shows a typical testing scenario
that uses JUnit Jupiter and transactional tests with <code>@Sql</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(TestDatabaseConfig.class)
@Transactional
class TransactionalSqlScriptsTests {

    final JdbcTemplate jdbcTemplate;

    @Autowired
    TransactionalSqlScriptsTests(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Test
    @Sql("/test-data.sql")
    void usersTest() {
        // verify state in test database:
        assertNumUsers(2);
        // run code that uses the test data...
    }

    int countRowsInTable(String tableName) {
        return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);
    }

    void assertNumUsers(int expected) {
        assertEquals(expected, countRowsInTable("user"),
            "Number of rows in the [user] table.");
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(TestDatabaseConfig::class)
@Transactional
class TransactionalSqlScriptsTests @Autowired constructor(dataSource: DataSource) {

    val jdbcTemplate: JdbcTemplate = JdbcTemplate(dataSource)

    @Test
    @Sql("/test-data.sql")
    fun usersTest() {
        // verify state in test database:
        assertNumUsers(2)
        // run code that uses the test data...
    }

    fun countRowsInTable(tableName: String): Int {
        return JdbcTestUtils.countRowsInTable(jdbcTemplate, tableName)
    }

    fun assertNumUsers(expected: Int) {
        assertEquals(expected, countRowsInTable("user"),
                "Number of rows in the [user] table.")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that there is no need to clean up the database after the <code>usersTest()</code> method is
run, since any changes made to the database (either within the test method or within the
<code>/test-data.sql</code> script) are automatically rolled back by the
<code>TransactionalTestExecutionListener</code> (see <a href="#testcontext-tx">transaction management</a> for
details).</p>
</div>
</div>
<div class="sect5">
<h6 id="testcontext-executing-sql-declaratively-script-merging">Merging and Overriding Configuration with <code>@SqlMergeMode</code></h6>
<div class="paragraph">
<p>As of Spring Framework 5.2, it is possible to merge method-level <code>@Sql</code> declarations with
class-level declarations. For example, this allows you to provide the configuration for a
database schema or some common test data once per test class and then provide additional,
use case specific test data per test method. To enable <code>@Sql</code> merging, annotate either
your test class or test method with <code>@SqlMergeMode(MERGE)</code>. To disable merging for a
specific test method (or specific test subclass), you can switch back to the default mode
via <code>@SqlMergeMode(OVERRIDE)</code>. Consult the <a href="#spring-testing-annotation-sqlmergemode"><code>@SqlMergeMode</code> annotation documentation section</a> for examples and further details.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-parallel-test-execution">Parallel Test Execution</h4>
<div class="paragraph">
<p>Spring Framework 5.0 introduced basic support for executing tests in parallel within a
single JVM when using the Spring TestContext Framework. In general, this means that most
test classes or test methods can be run in parallel without any changes to test code
or configuration.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For details on how to set up parallel test execution, see the documentation for your
testing framework, build tool, or IDE.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Keep in mind that the introduction of concurrency into your test suite can result in
unexpected side effects, strange runtime behavior, and tests that fail intermittently or
seemingly randomly. The Spring Team therefore provides the following general guidelines
for when not to run tests in parallel.</p>
</div>
<div class="paragraph">
<p>Do not run tests in parallel if the tests:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use Spring Framework&#8217;s <code>@DirtiesContext</code> support.</p>
</li>
<li>
<p>Use Spring Boot&#8217;s <code>@MockBean</code> or <code>@SpyBean</code> support.</p>
</li>
<li>
<p>Use JUnit 4&#8217;s <code>@FixMethodOrder</code> support or any testing framework feature
that is designed to ensure that test methods run in a particular order. Note,
however, that this does not apply if entire test classes are run in parallel.</p>
</li>
<li>
<p>Change the state of shared services or systems such as a database, message broker,
filesystem, and others. This applies to both embedded and external systems.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If parallel test execution fails with an exception stating that the <code>ApplicationContext</code>
for the current test is no longer active, this typically means that the
<code>ApplicationContext</code> was removed from the <code>ContextCache</code> in a different thread.</p>
</div>
<div class="paragraph">
<p>This may be due to the use of <code>@DirtiesContext</code> or due to automatic eviction from the
<code>ContextCache</code>. If <code>@DirtiesContext</code> is the culprit, you either need to find a way to
avoid using <code>@DirtiesContext</code> or exclude such tests from parallel execution. If the
maximum size of the <code>ContextCache</code> has been exceeded, you can increase the maximum size
of the cache. See the discussion on <a href="#testcontext-ctx-management-caching">context caching</a>
for details.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Parallel test execution in the Spring TestContext Framework is only possible if
the underlying <code>TestContext</code> implementation provides a copy constructor, as explained in
the javadoc for <a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/context/TestContext.html"><code>TestContext</code></a>. The
<code>DefaultTestContext</code> used in Spring provides such a constructor. However, if you use a
third-party library that provides a custom <code>TestContext</code> implementation, you need to
verify that it is suitable for parallel test execution.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-support-classes">TestContext Framework Support Classes</h4>
<div class="paragraph">
<p>This section describes the various classes that support the Spring TestContext Framework.</p>
</div>
<div class="sect4">
<h5 id="testcontext-junit4-runner">Spring JUnit 4 Runner</h5>
<div class="paragraph">
<p>The Spring TestContext Framework offers full integration with JUnit 4 through a custom
runner (supported on JUnit 4.12 or higher). By annotating test classes with
<code>@RunWith(SpringJUnit4ClassRunner.class)</code> or the shorter <code>@RunWith(SpringRunner.class)</code>
variant, developers can implement standard JUnit 4-based unit and integration tests and
simultaneously reap the benefits of the TestContext framework, such as support for
loading application contexts, dependency injection of test instances, transactional test
method execution, and so on. If you want to use the Spring TestContext Framework with an
alternative runner (such as JUnit 4&#8217;s <code>Parameterized</code> runner) or third-party runners
(such as the <code>MockitoJUnitRunner</code>), you can, optionally, use
<a href="#testcontext-junit4-rules">Spring&#8217;s support for JUnit rules</a> instead.</p>
</div>
<div class="paragraph">
<p>The following code listing shows the minimal requirements for configuring a test class to
run with the custom Spring <code>Runner</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RunWith(SpringRunner.class)
@TestExecutionListeners({})
public class SimpleTest {

    @Test
    public void testMethod() {
        // test logic...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@RunWith(SpringRunner::class)
@TestExecutionListeners
class SimpleTest {

    @Test
    fun testMethod() {
        // test logic...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, <code>@TestExecutionListeners</code> is configured with an empty list, to
disable the default listeners, which otherwise would require an <code>ApplicationContext</code> to
be configured through <code>@ContextConfiguration</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-junit4-rules">Spring JUnit 4 Rules</h5>
<div class="paragraph">
<p>The <code>org.springframework.test.context.junit4.rules</code> package provides the following JUnit
4 rules (supported on JUnit 4.12 or higher):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SpringClassRule</code></p>
</li>
<li>
<p><code>SpringMethodRule</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>SpringClassRule</code> is a JUnit <code>TestRule</code> that supports class-level features of the Spring
TestContext Framework, whereas <code>SpringMethodRule</code> is a JUnit <code>MethodRule</code> that supports
instance-level and method-level features of the Spring TestContext Framework.</p>
</div>
<div class="paragraph">
<p>In contrast to the <code>SpringRunner</code>, Spring&#8217;s rule-based JUnit support has the advantage of
being independent of any <code>org.junit.runner.Runner</code> implementation and can, therefore, be
combined with existing alternative runners (such as JUnit 4&#8217;s <code>Parameterized</code>) or
third-party runners (such as the <code>MockitoJUnitRunner</code>).</p>
</div>
<div class="paragraph">
<p>To support the full functionality of the TestContext framework, you must combine a
<code>SpringClassRule</code> with a <code>SpringMethodRule</code>. The following example shows the proper way
to declare these rules in an integration test:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// Optionally specify a non-Spring Runner via @RunWith(...)
@ContextConfiguration
public class IntegrationTest {

    @ClassRule
    public static final SpringClassRule springClassRule = new SpringClassRule();

    @Rule
    public final SpringMethodRule springMethodRule = new SpringMethodRule();

    @Test
    public void testMethod() {
        // test logic...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Optionally specify a non-Spring Runner via @RunWith(...)
@ContextConfiguration
class IntegrationTest {

    @Rule
    val springMethodRule = SpringMethodRule()

    @Test
    fun testMethod() {
        // test logic...
    }

    companion object {
        @ClassRule
        val springClassRule = SpringClassRule()
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-support-classes-junit4">JUnit 4 Support Classes</h5>
<div class="paragraph">
<p>The <code>org.springframework.test.context.junit4</code> package provides the following support
classes for JUnit 4-based test cases (supported on JUnit 4.12 or higher):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>AbstractJUnit4SpringContextTests</code></p>
</li>
<li>
<p><code>AbstractTransactionalJUnit4SpringContextTests</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>AbstractJUnit4SpringContextTests</code> is an abstract base test class that integrates the
Spring TestContext Framework with explicit <code>ApplicationContext</code> testing support in a
JUnit 4 environment. When you extend <code>AbstractJUnit4SpringContextTests</code>, you can access a
<code>protected</code> <code>applicationContext</code> instance variable that you can use to perform explicit
bean lookups or to test the state of the context as a whole.</p>
</div>
<div class="paragraph">
<p><code>AbstractTransactionalJUnit4SpringContextTests</code> is an abstract transactional extension of
<code>AbstractJUnit4SpringContextTests</code> that adds some convenience functionality for JDBC
access. This class expects a <code>javax.sql.DataSource</code> bean and a
<code>PlatformTransactionManager</code> bean to be defined in the <code>ApplicationContext</code>. When you
extend <code>AbstractTransactionalJUnit4SpringContextTests</code>, you can access a <code>protected</code>
<code>jdbcTemplate</code> instance variable that you can use to run SQL statements to query the
database. You can use such queries to confirm database state both before and after
running database-related application code, and Spring ensures that such queries run in
the scope of the same transaction as the application code. When used in conjunction with
an ORM tool, be sure to avoid <a href="#testcontext-tx-false-positives">false positives</a>.
As mentioned in <a href="#integration-testing-support-jdbc">JDBC Testing Support</a>,
<code>AbstractTransactionalJUnit4SpringContextTests</code> also provides convenience methods that
delegate to methods in <code>JdbcTestUtils</code> by using the aforementioned <code>jdbcTemplate</code>.
Furthermore, <code>AbstractTransactionalJUnit4SpringContextTests</code> provides an
<code>executeSqlScript(..)</code> method for running SQL scripts against the configured <code>DataSource</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
These classes are a convenience for extension. If you do not want your test classes
to be tied to a Spring-specific class hierarchy, you can configure your own custom test
classes by using <code>@RunWith(SpringRunner.class)</code> or <a href="#testcontext-junit4-rules">Spring&#8217;s
JUnit rules</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-junit-jupiter-extension">SpringExtension for JUnit Jupiter</h5>
<div class="paragraph">
<p>The Spring TestContext Framework offers full integration with the JUnit Jupiter testing
framework, introduced in JUnit 5. By annotating test classes with
<code>@ExtendWith(SpringExtension.class)</code>, you can implement standard JUnit Jupiter-based unit
and integration tests and simultaneously reap the benefits of the TestContext framework,
such as support for loading application contexts, dependency injection of test instances,
transactional test method execution, and so on.</p>
</div>
<div class="paragraph">
<p>Furthermore, thanks to the rich extension API in JUnit Jupiter, Spring provides the
following features above and beyond the feature set that Spring supports for JUnit 4 and
TestNG:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Dependency injection for test constructors, test methods, and test lifecycle callback
methods. See <a href="#testcontext-junit-jupiter-di">Dependency Injection with <code>SpringExtension</code></a> for further details.</p>
</li>
<li>
<p>Powerful support for <a href="https://junit.org/junit5/docs/current/user-guide/#extensions-conditions">conditional
test execution</a> based on SpEL expressions, environment variables, system properties,
and so on. See the documentation for <code>@EnabledIf</code> and <code>@DisabledIf</code> in
<a href="#integration-testing-annotations-junit-jupiter">Spring JUnit Jupiter Testing Annotations</a> for further details and examples.</p>
</li>
<li>
<p>Custom composed annotations that combine annotations from Spring and JUnit Jupiter. See
the <code>@TransactionalDevTestConfig</code> and <code>@TransactionalIntegrationTest</code> examples in
<a href="#integration-testing-annotations-meta">Meta-Annotation Support for Testing</a> for further details.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following code listing shows how to configure a test class to use the
<code>SpringExtension</code> in conjunction with <code>@ContextConfiguration</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// Instructs JUnit Jupiter to extend the test with Spring support.
@ExtendWith(SpringExtension.class)
// Instructs Spring to load an ApplicationContext from TestConfig.class
@ContextConfiguration(classes = TestConfig.class)
class SimpleTests {

    @Test
    void testMethod() {
        // test logic...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Instructs JUnit Jupiter to extend the test with Spring support.
@ExtendWith(SpringExtension::class)
// Instructs Spring to load an ApplicationContext from TestConfig::class
@ContextConfiguration(classes = [TestConfig::class])
class SimpleTests {

    @Test
    fun testMethod() {
        // test logic...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since you can also use annotations in JUnit 5 as meta-annotations, Spring provides the
<code>@SpringJUnitConfig</code> and <code>@SpringJUnitWebConfig</code> composed annotations to simplify the
configuration of the test <code>ApplicationContext</code> and JUnit Jupiter.</p>
</div>
<div class="paragraph">
<p>The following example uses <code>@SpringJUnitConfig</code> to reduce the amount of configuration
used in the previous example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load an ApplicationContext from TestConfig.class
@SpringJUnitConfig(TestConfig.class)
class SimpleTests {

    @Test
    void testMethod() {
        // test logic...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load an ApplicationContext from TestConfig.class
@SpringJUnitConfig(TestConfig::class)
class SimpleTests {

    @Test
    fun testMethod() {
        // test logic...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, the following example uses <code>@SpringJUnitWebConfig</code> to create a
<code>WebApplicationContext</code> for use with JUnit Jupiter:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load a WebApplicationContext from TestWebConfig.class
@SpringJUnitWebConfig(TestWebConfig.class)
class SimpleWebTests {

    @Test
    void testMethod() {
        // test logic...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load a WebApplicationContext from TestWebConfig::class
@SpringJUnitWebConfig(TestWebConfig::class)
class SimpleWebTests {

    @Test
    fun testMethod() {
        // test logic...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the documentation for <code>@SpringJUnitConfig</code> and <code>@SpringJUnitWebConfig</code> in
<a href="#integration-testing-annotations-junit-jupiter">Spring JUnit Jupiter Testing Annotations</a> for further details.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-junit-jupiter-di">Dependency Injection with <code>SpringExtension</code></h5>
<div class="paragraph">
<p><code>SpringExtension</code> implements the
<a href="https://junit.org/junit5/docs/current/user-guide/#extensions-parameter-resolution"><code>ParameterResolver</code></a>
extension API from JUnit Jupiter, which lets Spring provide dependency injection for test
constructors, test methods, and test lifecycle callback methods.</p>
</div>
<div class="paragraph">
<p>Specifically, <code>SpringExtension</code> can inject dependencies from the test&#8217;s
<code>ApplicationContext</code> into test constructors and methods that are annotated with
<code>@BeforeAll</code>, <code>@AfterAll</code>, <code>@BeforeEach</code>, <code>@AfterEach</code>, <code>@Test</code>, <code>@RepeatedTest</code>,
<code>@ParameterizedTest</code>, and others.</p>
</div>
<div class="sect5">
<h6 id="testcontext-junit-jupiter-di-constructor">Constructor Injection</h6>
<div class="paragraph">
<p>If a specific parameter in a constructor for a JUnit Jupiter test class is of type
<code>ApplicationContext</code> (or a sub-type thereof) or is annotated or meta-annotated with
<code>@Autowired</code>, <code>@Qualifier</code>, or <code>@Value</code>, Spring injects the value for that specific
parameter with the corresponding bean or value from the test&#8217;s <code>ApplicationContext</code>.</p>
</div>
<div class="paragraph">
<p>Spring can also be configured to autowire all arguments for a test class constructor if
the constructor is considered to be <em>autowirable</em>. A constructor is considered to be
autowirable if one of the following conditions is met (in order of precedence).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The constructor is annotated with <code>@Autowired</code>.</p>
</li>
<li>
<p><code>@TestConstructor</code> is present or meta-present on the test class with the <code>autowireMode</code>
attribute set to <code>ALL</code>.</p>
</li>
<li>
<p>The default <em>test constructor autowire mode</em> has been changed to <code>ALL</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See <a href="#integration-testing-annotations-testconstructor"><code>@TestConstructor</code></a> for details on the use of
<code>@TestConstructor</code> and how to change the global <em>test constructor autowire mode</em>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
If the constructor for a test class is considered to be <em>autowirable</em>, Spring
assumes the responsibility for resolving arguments for all parameters in the constructor.
Consequently, no other <code>ParameterResolver</code> registered with JUnit Jupiter can resolve
parameters for such a constructor.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Constructor injection for test classes must not be used in conjunction with JUnit
Jupiter&#8217;s <code>@TestInstance(PER_CLASS)</code> support if <code>@DirtiesContext</code> is used to close the
test&#8217;s <code>ApplicationContext</code> before or after test methods.</p>
</div>
<div class="paragraph">
<p>The reason is that <code>@TestInstance(PER_CLASS)</code> instructs JUnit Jupiter to cache the test
instance between test method invocations. Consequently, the test instance will retain
references to beans that were originally injected from an <code>ApplicationContext</code> that has
been subsequently closed. Since the constructor for the test class will only be invoked
once in such scenarios, dependency injection will not occur again, and subsequent tests
will interact with beans from the closed <code>ApplicationContext</code> which may result in errors.</p>
</div>
<div class="paragraph">
<p>To use <code>@DirtiesContext</code> with "before test method" or "after test method" modes in
conjunction with <code>@TestInstance(PER_CLASS)</code>, one must configure dependencies from Spring
to be supplied via field or setter injection so that they can be re-injected between test
method invocations.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the following example, Spring injects the <code>OrderService</code> bean from the
<code>ApplicationContext</code> loaded from <code>TestConfig.class</code> into the
<code>OrderServiceIntegrationTests</code> constructor.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    private final OrderService orderService;

    @Autowired
    OrderServiceIntegrationTests(OrderService orderService) {
        this.orderService = orderService;
    }

    // tests that use the injected OrderService
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(TestConfig::class)
class OrderServiceIntegrationTests @Autowired constructor(private val orderService: OrderService){
    // tests that use the injected OrderService
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that this feature lets test dependencies be <code>final</code> and therefore immutable.</p>
</div>
<div class="paragraph">
<p>If the <code>spring.test.constructor.autowire.mode</code> property is to <code>all</code> (see
<a href="#integration-testing-annotations-testconstructor"><code>@TestConstructor</code></a>), we can omit the declaration of
<code>@Autowired</code> on the constructor in the previous example, resulting in the following.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    private final OrderService orderService;

    OrderServiceIntegrationTests(OrderService orderService) {
        this.orderService = orderService;
    }

    // tests that use the injected OrderService
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(TestConfig::class)
class OrderServiceIntegrationTests(val orderService:OrderService) {
    // tests that use the injected OrderService
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testcontext-junit-jupiter-di-method">Method Injection</h6>
<div class="paragraph">
<p>If a parameter in a JUnit Jupiter test method or test lifecycle callback method is of
type <code>ApplicationContext</code> (or a sub-type thereof) or is annotated or meta-annotated with
<code>@Autowired</code>, <code>@Qualifier</code>, or <code>@Value</code>, Spring injects the value for that specific
parameter with the corresponding bean from the test&#8217;s <code>ApplicationContext</code>.</p>
</div>
<div class="paragraph">
<p>In the following example, Spring injects the <code>OrderService</code> from the <code>ApplicationContext</code>
loaded from <code>TestConfig.class</code> into the <code>deleteOrder()</code> test method:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    @Test
    void deleteOrder(@Autowired OrderService orderService) {
        // use orderService from the test's ApplicationContext
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(TestConfig::class)
class OrderServiceIntegrationTests {

    @Test
    fun deleteOrder(@Autowired orderService: OrderService) {
        // use orderService from the test's ApplicationContext
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Due to the robustness of the <code>ParameterResolver</code> support in JUnit Jupiter, you can also
have multiple dependencies injected into a single method, not only from Spring but also
from JUnit Jupiter itself or other third-party extensions.</p>
</div>
<div class="paragraph">
<p>The following example shows how to have both Spring and JUnit Jupiter inject dependencies
into the <code>placeOrderRepeatedly()</code> test method simultaneously.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    @RepeatedTest(10)
    void placeOrderRepeatedly(RepetitionInfo repetitionInfo,
            @Autowired OrderService orderService) {

        // use orderService from the test's ApplicationContext
        // and repetitionInfo from JUnit Jupiter
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(TestConfig::class)
class OrderServiceIntegrationTests {

    @RepeatedTest(10)
    fun placeOrderRepeatedly(repetitionInfo:RepetitionInfo, @Autowired orderService:OrderService) {

        // use orderService from the test's ApplicationContext
        // and repetitionInfo from JUnit Jupiter
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the use of <code>@RepeatedTest</code> from JUnit Jupiter lets the test method gain access
to the <code>RepetitionInfo</code>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-junit-jupiter-nested-test-configuration"><code>@Nested</code> test class configuration</h5>
<div class="paragraph">
<p>The <em>Spring TestContext Framework</em> has supported the use of test-related annotations on
<code>@Nested</code> test classes in JUnit Jupiter since Spring Framework 5.0; however, until Spring
Framework 5.3 class-level test configuration annotations were not <em>inherited</em> from
enclosing classes like they are from superclasses.</p>
</div>
<div class="paragraph">
<p>Spring Framework 5.3 introduces first-class support for inheriting test class
configuration from enclosing classes, and such configuration will be inherited by
default. To change from the default <code>INHERIT</code> mode to <code>OVERRIDE</code> mode, you may annotate
an individual <code>@Nested</code> test class with
<code>@NestedTestConfiguration(EnclosingConfiguration.OVERRIDE)</code>. An explicit
<code>@NestedTestConfiguration</code> declaration will apply to the annotated test class as well as
any of its subclasses and nested classes. Thus, you may annotate a top-level test class
with <code>@NestedTestConfiguration</code>, and that will apply to all of its nested test classes
recursively.</p>
</div>
<div class="paragraph">
<p>In order to allow development teams to change the default to <code>OVERRIDE</code> – for example,
for compatibility with Spring Framework 5.0 through 5.2 – the default mode can be changed
globally via a JVM system property or a <code>spring.properties</code> file in the root of the
classpath. See the <a href="#integration-testing-annotations-nestedtestconfiguration">"Changing
the default enclosing configuration inheritance mode"</a> note for details.</p>
</div>
<div class="paragraph">
<p>Although the following "Hello World" example is very simplistic, it shows how to declare
common configuration on a top-level class that is inherited by its <code>@Nested</code> test
classes. In this particular example, only the <code>TestConfig</code> configuration class is
inherited. Each nested test class provides its own set of active profiles, resulting in a
distinct <code>ApplicationContext</code> for each nested test class (see
<a href="#testcontext-ctx-management-caching">Context Caching</a> for details). Consult the list of
<a href="#integration-testing-annotations-nestedtestconfiguration">supported annotations</a> to see
which annotations can be inherited in <code>@Nested</code> test classes.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitConfig(TestConfig.class)
class GreetingServiceTests {

    @Nested
    @ActiveProfiles("lang_en")
    class EnglishGreetings {

        @Test
        void hello(@Autowired GreetingService service) {
            assertThat(service.greetWorld()).isEqualTo("Hello World");
        }
    }

    @Nested
    @ActiveProfiles("lang_de")
    class GermanGreetings {

        @Test
        void hello(@Autowired GreetingService service) {
            assertThat(service.greetWorld()).isEqualTo("Hallo Welt");
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitConfig(TestConfig::class)
class GreetingServiceTests {

    @Nested
    @ActiveProfiles("lang_en")
    inner class EnglishGreetings {

        @Test
        fun hello(@Autowired service:GreetingService) {
            assertThat(service.greetWorld()).isEqualTo("Hello World")
        }
    }

    @Nested
    @ActiveProfiles("lang_de")
    inner class GermanGreetings {

        @Test
        fun hello(@Autowired service:GreetingService) {
            assertThat(service.greetWorld()).isEqualTo("Hallo Welt")
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-support-classes-testng">TestNG Support Classes</h5>
<div class="paragraph">
<p>The <code>org.springframework.test.context.testng</code> package provides the following support
classes for TestNG based test cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>AbstractTestNGSpringContextTests</code></p>
</li>
<li>
<p><code>AbstractTransactionalTestNGSpringContextTests</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>AbstractTestNGSpringContextTests</code> is an abstract base test class that integrates the
Spring TestContext Framework with explicit <code>ApplicationContext</code> testing support in a
TestNG environment. When you extend <code>AbstractTestNGSpringContextTests</code>, you can access a
<code>protected</code> <code>applicationContext</code> instance variable that you can use to perform explicit
bean lookups or to test the state of the context as a whole.</p>
</div>
<div class="paragraph">
<p><code>AbstractTransactionalTestNGSpringContextTests</code> is an abstract transactional extension of
<code>AbstractTestNGSpringContextTests</code> that adds some convenience functionality for JDBC
access. This class expects a <code>javax.sql.DataSource</code> bean and a
<code>PlatformTransactionManager</code> bean to be defined in the <code>ApplicationContext</code>. When you
extend <code>AbstractTransactionalTestNGSpringContextTests</code>, you can access a <code>protected</code>
<code>jdbcTemplate</code> instance variable that you can use to run SQL statements to query the
database. You can use such queries to confirm database state both before and after
running database-related application code, and Spring ensures that such queries run in
the scope of the same transaction as the application code. When used in conjunction with
an ORM tool, be sure to avoid <a href="#testcontext-tx-false-positives">false positives</a>.
As mentioned in <a href="#integration-testing-support-jdbc">JDBC Testing Support</a>,
<code>AbstractTransactionalTestNGSpringContextTests</code> also provides convenience methods that
delegate to methods in <code>JdbcTestUtils</code> by using the aforementioned <code>jdbcTemplate</code>.
Furthermore, <code>AbstractTransactionalTestNGSpringContextTests</code> provides an
<code>executeSqlScript(..)</code> method for running SQL scripts against the configured <code>DataSource</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
These classes are a convenience for extension. If you do not want your test classes
to be tied to a Spring-specific class hierarchy, you can configure your own custom test
classes by using <code>@ContextConfiguration</code>, <code>@TestExecutionListeners</code>, and so on and by
manually instrumenting your test class with a <code>TestContextManager</code>. See the source code
of <code>AbstractTestNGSpringContextTests</code> for an example of how to instrument your test class.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Unresolved directive in testing.adoc - include::testing/testing-webtestclient.adoc[leveloffset=+2]</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-mvc-test-framework">MockMvc</h3>
<div class="paragraph">
<p>The Spring MVC Test framework, also known as MockMvc, provides support for testing Spring
MVC applications. It performs full Spring MVC request handling but via mock request and
response objects instead of a running server.</p>
</div>
<div class="paragraph">
<p>MockMvc can be used on its own to perform requests and verify responses. It can also be
used through the <a href="#webtestclient">[webtestclient]</a> where MockMvc is plugged in as the server to handle
requests with. The advantage of <code>WebTestClient</code> is the option to work with higher level
objects instead of raw data as well as the ability to switch to full, end-to-end HTTP
tests against a live server and use the same test API.</p>
</div>
<div class="sect3">
<h4 id="spring-mvc-test-server">Overview</h4>
<div class="paragraph">
<p>You can write plain unit tests for Spring MVC by instantiating a controller, injecting it
with dependencies, and calling its methods. However such tests do not verify request
mappings, data binding, message conversion, type conversion, validation, and nor
do they involve any of the supporting <code>@InitBinder</code>, <code>@ModelAttribute</code>, or
<code>@ExceptionHandler</code> methods.</p>
</div>
<div class="paragraph">
<p>The Spring MVC Test framework, also known as <code>MockMvc</code>, aims to provide more complete
testing for Spring MVC controllers without a running server. It does that by invoking
the <code>DispacherServlet</code> and passing
<a href="#mock-objects-servlet">&#8220;mock&#8221; implementations of the Servlet API</a> from the
<code>spring-test</code> module which replicates the full Spring MVC request handling without
a running server.</p>
</div>
<div class="paragraph">
<p>MockMvc is a server side test framework that lets you verify most of the functionality
of a Spring MVC application using lightweight and targeted tests. You can use it on
its own to perform requests and to verify responses, or you can also use it through
the <a href="#webtestclient">[webtestclient]</a> API with MockMvc plugged in as the server to handle requests
with.</p>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-static-imports">Static Imports</h5>
<div class="paragraph">
<p>When using MockMvc directly to perform requests, you&#8217;ll need static imports for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MockMvcBuilders.*</code></p>
</li>
<li>
<p><code>MockMvcRequestBuilders.*</code></p>
</li>
<li>
<p><code>MockMvcResultMatchers.*</code></p>
</li>
<li>
<p><code>MockMvcResultHandlers.*</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An easy way to remember that is search for <code>MockMvc*</code>. If using Eclipse be sure to also
add the above as &#8220;favorite static members&#8221; in the Eclipse preferences.</p>
</div>
<div class="paragraph">
<p>When using MockMvc through the <a href="#webtestclient">[webtestclient]</a> you do not need static imports.
The <code>WebTestClient</code> provides a fluent API without static imports.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-setup-options">Setup Choices</h5>
<div class="paragraph">
<p>MockMvc can be setup in one of two ways. One is to point directly to the controllers you
want to test and programmatically configure Spring MVC infrastructure. The second is to
point to Spring configuration with Spring MVC and controller infrastructure in it.</p>
</div>
<div class="paragraph">
<p>To set up MockMvc for testing a specific controller, use the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">class MyWebTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup() {
        this.mockMvc = MockMvcBuilders.standaloneSetup(new AccountController()).build();
    }

    // ...

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MyWebTests {

    lateinit var mockMvc : MockMvc

    @BeforeEach
    fun setup() {
        mockMvc = MockMvcBuilders.standaloneSetup(AccountController()).build()
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or you can also use this setup when testing through the
<a href="#webtestclient-controller-config">WebTestClient</a> which delegates to the same builder
as shown above.</p>
</div>
<div class="paragraph">
<p>To set up MockMvc through Spring configuration, use the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitWebConfig(locations = "my-servlet-context.xml")
class MyWebTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup(WebApplicationContext wac) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
    }

    // ...

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitWebConfig(locations = ["my-servlet-context.xml"])
class MyWebTests {

    lateinit var mockMvc: MockMvc

    @BeforeEach
    fun setup(wac: WebApplicationContext) {
        mockMvc = MockMvcBuilders.webAppContextSetup(wac).build()
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or you can also use this setup when testing through the
<a href="#webtestclient-context-config">WebTestClient</a> which delegates to the same builder
as shown above.</p>
</div>
<div class="paragraph">
<p>Which setup option should you use?</p>
</div>
<div class="paragraph">
<p>The <code>webAppContextSetup</code> loads your actual Spring MVC configuration, resulting in a more
complete integration test. Since the TestContext framework caches the loaded Spring
configuration, it helps keep tests running fast, even as you introduce more tests in your
test suite. Furthermore, you can inject mock services into controllers through Spring
configuration to remain focused on testing the web layer. The following example declares
a mock service with Mockito:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="accountService" class="org.mockito.Mockito" factory-method="mock"&gt;
    &lt;constructor-arg value="org.example.AccountService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then inject the mock service into the test to set up and verify your
expectations, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringJUnitWebConfig(locations = "test-servlet-context.xml")
class AccountTests {

    @Autowired
    AccountService accountService;

    MockMvc mockMvc;

    @BeforeEach
    void setup(WebApplicationContext wac) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
    }

    // ...

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SpringJUnitWebConfig(locations = ["test-servlet-context.xml"])
class AccountTests {

    @Autowired
    lateinit var accountService: AccountService

    lateinit mockMvc: MockMvc

    @BeforeEach
    fun setup(wac: WebApplicationContext) {
        mockMvc = MockMvcBuilders.webAppContextSetup(wac).build()
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>standaloneSetup</code>, on the other hand, is a little closer to a unit test. It tests one
controller at a time. You can manually inject the controller with mock dependencies, and
it does not involve loading Spring configuration. Such tests are more focused on style
and make it easier to see which controller is being tested, whether any specific Spring
MVC configuration is required to work, and so on. The <code>standaloneSetup</code> is also a very
convenient way to write ad-hoc tests to verify specific behavior or to debug an issue.</p>
</div>
<div class="paragraph">
<p>As with most &#8220;integration versus unit testing&#8221; debates, there is no right or wrong
answer. However, using the <code>standaloneSetup</code> does imply the need for additional
<code>webAppContextSetup</code> tests in order to verify your Spring MVC configuration.
Alternatively, you can write all your tests with <code>webAppContextSetup</code>, in order to always
test against your actual Spring MVC configuration.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-setup-steps">Setup Features</h5>
<div class="paragraph">
<p>No matter which MockMvc builder you use, all <code>MockMvcBuilder</code> implementations provide
some common and very useful features. For example, you can declare an <code>Accept</code> header for
all requests and expect a status of 200 as well as a <code>Content-Type</code> header in all
responses, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// static import of MockMvcBuilders.standaloneSetup

MockMvc mockMvc = standaloneSetup(new MusicController())
    .defaultRequest(get("/").accept(MediaType.APPLICATION_JSON))
    .alwaysExpect(status().isOk())
    .alwaysExpect(content().contentType("application/json;charset=UTF-8"))
    .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition, third-party frameworks (and applications) can pre-package setup
instructions, such as those in a <code>MockMvcConfigurer</code>. The Spring Framework has one such
built-in implementation that helps to save and re-use the HTTP session across requests.
You can use it as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// static import of SharedHttpSessionConfigurer.sharedHttpSession

MockMvc mockMvc = MockMvcBuilders.standaloneSetup(new TestController())
        .apply(sharedHttpSession())
        .build();

// Use mockMvc to perform requests...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the javadoc for
<a href="https://docs.spring.io/spring-framework/docs/{spring-version}/javadoc-api/org/springframework/test/web/servlet/setup/ConfigurableMockMvcBuilder.html"><code>ConfigurableMockMvcBuilder</code></a>
for a list of all MockMvc builder features or use the IDE to explore the available options.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-performing-requests">Performing Requests</h5>
<div class="paragraph">
<p>This section shows how to use MockMvc on its own to perform requests and verify responses.
If using MockMvc through the <code>WebTestClient</code> please see the corresponding section on
<a href="#webtestclient-tests">[webtestclient-tests]</a> instead.</p>
</div>
<div class="paragraph">
<p>To perform requests that use any HTTP method, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// static import of MockMvcRequestBuilders.*

mockMvc.perform(post("/hotels/{id}", 42).accept(MediaType.APPLICATION_JSON));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.test.web.servlet.post

mockMvc.post("/hotels/{id}", 42) {
    accept = MediaType.APPLICATION_JSON
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also perform file upload requests that internally use
<code>MockMultipartHttpServletRequest</code> so that there is no actual parsing of a multipart
request. Rather, you have to set it up to be similar to the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">mockMvc.perform(multipart("/doc").file("a1", "ABC".getBytes("UTF-8")));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.test.web.servlet.multipart

mockMvc.multipart("/doc") {
    file("a1", "ABC".toByteArray(charset("UTF8")))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can specify query parameters in URI template style, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">mockMvc.perform(get("/hotels?thing={thing}", "somewhere"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">mockMvc.get("/hotels?thing={thing}", "somewhere")</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also add Servlet request parameters that represent either query or form
parameters, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">mockMvc.perform(get("/hotels").param("thing", "somewhere"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.test.web.servlet.get

mockMvc.get("/hotels") {
    param("thing", "somewhere")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If application code relies on Servlet request parameters and does not check the query
string explicitly (as is most often the case), it does not matter which option you use.
Keep in mind, however, that query parameters provided with the URI template are decoded
while request parameters provided through the <code>param(&#8230;&#8203;)</code> method are expected to already
be decoded.</p>
</div>
<div class="paragraph">
<p>In most cases, it is preferable to leave the context path and the Servlet path out of the
request URI. If you must test with the full request URI, be sure to set the <code>contextPath</code>
and <code>servletPath</code> accordingly so that request mappings work, as the following example
shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">mockMvc.perform(get("/app/main/hotels/{id}").contextPath("/app").servletPath("/main"))</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.test.web.servlet.get

mockMvc.get("/app/main/hotels/{id}") {
    contextPath = "/app"
    servletPath = "/main"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, it would be cumbersome to set the <code>contextPath</code> and
<code>servletPath</code> with every performed request. Instead, you can set up default request
properties, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">class MyWebTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup() {
        mockMvc = standaloneSetup(new AccountController())
            .defaultRequest(get("/")
            .contextPath("/app").servletPath("/main")
            .accept(MediaType.APPLICATION_JSON)).build();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding properties affect every request performed through the <code>MockMvc</code> instance.
If the same property is also specified on a given request, it overrides the default
value. That is why the HTTP method and URI in the default request do not matter, since
they must be specified on every request.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-defining-expectations">Defining Expectations</h5>
<div class="paragraph">
<p>You can define expectations by appending one or more <code>.andExpect(..)</code> calls after
performing a request, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// static import of MockMvcRequestBuilders.* and MockMvcResultMatchers.*

mockMvc.perform(get("/accounts/1")).andExpect(status().isOk());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.test.web.servlet.get

mockMvc.get("/accounts/1").andExpect {
    status().isOk()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>MockMvcResultMatchers.*</code> provides a number of expectations, some of which are further
nested with more detailed expectations.</p>
</div>
<div class="paragraph">
<p>Expectations fall in two general categories. The first category of assertions verifies
properties of the response (for example, the response status, headers, and content).
These are the most important results to assert.</p>
</div>
<div class="paragraph">
<p>The second category of assertions goes beyond the response. These assertions let you
inspect Spring MVC specific aspects, such as which controller method processed the
request, whether an exception was raised and handled, what the content of the model is,
what view was selected, what flash attributes were added, and so on. They also let you
inspect Servlet specific aspects, such as request and session attributes.</p>
</div>
<div class="paragraph">
<p>The following test asserts that binding or validation failed:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">mockMvc.perform(post("/persons"))
    .andExpect(status().isOk())
    .andExpect(model().attributeHasErrors("person"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.test.web.servlet.post

mockMvc.post("/persons").andExpect {
    status().isOk()
    model {
        attributeHasErrors("person")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Many times, when writing tests, it is useful to dump the results of the performed
request. You can do so as follows, where <code>print()</code> is a static import from
<code>MockMvcResultHandlers</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">mockMvc.perform(post("/persons"))
    .andDo(print())
    .andExpect(status().isOk())
    .andExpect(model().attributeHasErrors("person"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.test.web.servlet.post

mockMvc.post("/persons").andDo {
        print()
    }.andExpect {
        status().isOk()
        model {
            attributeHasErrors("person")
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>As long as request processing does not cause an unhandled exception, the <code>print()</code> method
prints all the available result data to <code>System.out</code>. There is also a <code>log()</code> method and
two additional variants of the <code>print()</code> method, one that accepts an <code>OutputStream</code> and
one that accepts a <code>Writer</code>. For example, invoking <code>print(System.err)</code> prints the result
data to <code>System.err</code>, while invoking <code>print(myWriter)</code> prints the result data to a custom
writer. If you want to have the result data logged instead of printed, you can invoke the
<code>log()</code> method, which logs the result data as a single <code>DEBUG</code> message under the
<code>org.springframework.test.web.servlet.result</code> logging category.</p>
</div>
<div class="paragraph">
<p>In some cases, you may want to get direct access to the result and verify something that
cannot be verified otherwise. This can be achieved by appending <code>.andReturn()</code> after all
other expectations, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">MvcResult mvcResult = mockMvc.perform(post("/persons")).andExpect(status().isOk()).andReturn();
// ...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">var mvcResult = mockMvc.post("/persons").andExpect { status().isOk() }.andReturn()
// ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>If all tests repeat the same expectations, you can set up common expectations once when
building the <code>MockMvc</code> instance, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">standaloneSetup(new SimpleController())
    .alwaysExpect(status().isOk())
    .alwaysExpect(content().contentType("application/json;charset=UTF-8"))
    .build()</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that common expectations are always applied and cannot be overridden without
creating a separate <code>MockMvc</code> instance.</p>
</div>
<div class="paragraph">
<p>When a JSON response content contains hypermedia links created with
<a href="https://github.com/spring-projects/spring-hateoas">Spring HATEOAS</a>, you can verify the
resulting links by using JsonPath expressions, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">mockMvc.perform(get("/people").accept(MediaType.APPLICATION_JSON))
    .andExpect(jsonPath("$.links[?(@.rel == 'self')].href").value("http://localhost:8080/people"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">mockMvc.get("/people") {
    accept(MediaType.APPLICATION_JSON)
}.andExpect {
    jsonPath("$.links[?(@.rel == 'self')].href") {
        value("http://localhost:8080/people")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When XML response content contains hypermedia links created with
<a href="https://github.com/spring-projects/spring-hateoas">Spring HATEOAS</a>, you can verify the
resulting links by using XPath expressions:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Map&lt;String, String&gt; ns = Collections.singletonMap("ns", "http://www.w3.org/2005/Atom");
mockMvc.perform(get("/handle").accept(MediaType.APPLICATION_XML))
    .andExpect(xpath("/person/ns:link[@rel='self']/@href", ns).string("http://localhost:8080/people"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val ns = mapOf("ns" to "http://www.w3.org/2005/Atom")
mockMvc.get("/handle") {
    accept(MediaType.APPLICATION_XML)
}.andExpect {
    xpath("/person/ns:link[@rel='self']/@href", ns) {
        string("http://localhost:8080/people")
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-async-requests">Async Requests</h5>
<div class="paragraph">
<p>This section shows how to use MockMvc on its own to test asynchronous request handling.
If using MockMvc through the <a href="#webtestclient">[webtestclient]</a>, there is nothing special to do to make
asynchronous requests work as the <code>WebTestClient</code> automatically does what is described
in this section.</p>
</div>
<div class="paragraph">
<p>Servlet 3.0 asynchronous requests,
<a href="web.html#mvc-ann-async">supported in Spring MVC</a>, work by exiting the Servlet container
thread and allowing the application to compute the response asynchronously, after which
an async dispatch is made to complete processing on a Servlet container thread.</p>
</div>
<div class="paragraph">
<p>In Spring MVC Test, async requests can be tested by asserting the produced async value
first, then manually performing the async dispatch, and finally verifying the response.
Below is an example test for controller methods that return <code>DeferredResult</code>, <code>Callable</code>,
or reactive type such as Reactor <code>Mono</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// static import of MockMvcRequestBuilders.* and MockMvcResultMatchers.*

@Test
void test() throws Exception {
    MvcResult mvcResult = this.mockMvc.perform(get("/path"))
            .andExpect(status().isOk()) <i class="conum" data-value="1"></i><b>(1)</b>
            .andExpect(request().asyncStarted()) <i class="conum" data-value="2"></i><b>(2)</b>
            .andExpect(request().asyncResult("body")) <i class="conum" data-value="3"></i><b>(3)</b>
            .andReturn();

    this.mockMvc.perform(asyncDispatch(mvcResult)) <i class="conum" data-value="4"></i><b>(4)</b>
            .andExpect(status().isOk()) <i class="conum" data-value="5"></i><b>(5)</b>
            .andExpect(content().string("body"));
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Check response status is still unchanged</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Async processing must have started</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Wait and assert the async result</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Manually perform an ASYNC dispatch (as there is no running container)</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Verify the final response</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Test
fun test() {
    var mvcResult = mockMvc.get("/path").andExpect {
        status().isOk() <i class="conum" data-value="1"></i><b>(1)</b>
        request { asyncStarted() } <i class="conum" data-value="2"></i><b>(2)</b>
        // TODO Remove unused generic parameter
        request { asyncResult&lt;Nothing&gt;("body") } <i class="conum" data-value="3"></i><b>(3)</b>
    }.andReturn()


    mockMvc.perform(asyncDispatch(mvcResult)) <i class="conum" data-value="4"></i><b>(4)</b>
            .andExpect {
                status().isOk() <i class="conum" data-value="5"></i><b>(5)</b>
                content().string("body")
            }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Check response status is still unchanged</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Async processing must have started</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Wait and assert the async result</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Manually perform an ASYNC dispatch (as there is no running container)</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Verify the final response</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-vs-streaming-response">Streaming Responses</h5>
<div class="paragraph">
<p>The best way to test streaming responses such as Server-Sent Events is through the
<a href="#WebTestClient">[WebTestClient]</a> which can be used as a test client to connect to a <code>MockMvc</code> instance
to perform tests on Spring MVC controllers without a running server. For example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">WebTestClient client = MockMvcWebTestClient.bindToController(new SseController()).build();

FluxExchangeResult&lt;Person&gt; exchangeResult = client.get()
        .uri("/persons")
        .exchange()
        .expectStatus().isOk()
        .expectHeader().contentType("text/event-stream")
        .returnResult(Person.class);

// Use StepVerifier from Project Reactor to test the streaming response

StepVerifier.create(exchangeResult.getResponseBody())
        .expectNext(new Person("N0"), new Person("N1"), new Person("N2"))
        .expectNextCount(4)
        .consumeNextWith(person -&gt; assertThat(person.getName()).endsWith("7"))
        .thenCancel()
        .verify();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>WebTestClient</code> can also connect to a live server and perform full end-to-end integration
tests. This is also supported in Spring Boot where you can
<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-with-running-server">test a running server</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-filters">Filter Registrations</h5>
<div class="paragraph">
<p>When setting up a <code>MockMvc</code> instance, you can register one or more Servlet <code>Filter</code>
instances, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">mockMvc = standaloneSetup(new PersonController()).addFilters(new CharacterEncodingFilter()).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>Registered filters are invoked through the <code>MockFilterChain</code> from <code>spring-test</code>, and the
last filter delegates to the <code>DispatcherServlet</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-vs-end-to-end-integration-tests">MockMvc vs End-to-End Tests</h5>
<div class="paragraph">
<p>MockMVc is built on Servlet API mock implementations from the
<code>spring-test</code> module and does not rely on a running container. Therefore, there are
some differences when compared to full end-to-end integration tests with an actual
client and a live server running.</p>
</div>
<div class="paragraph">
<p>The easiest way to think about this is by starting with a blank <code>MockHttpServletRequest</code>.
Whatever you add to it is what the request becomes. Things that may catch you by surprise
are that there is no context path by default; no <code>jsessionid</code> cookie; no forwarding,
error, or async dispatches; and, therefore, no actual JSP rendering. Instead,
&#8220;forwarded&#8221; and &#8220;redirected&#8221; URLs are saved in the <code>MockHttpServletResponse</code> and can
be asserted with expectations.</p>
</div>
<div class="paragraph">
<p>This means that, if you use JSPs, you can verify the JSP page to which the request was
forwarded, but no HTML is rendered. In other words, the JSP is not invoked. Note,
however, that all other rendering technologies that do not rely on forwarding, such as
Thymeleaf and Freemarker, render HTML to the response body as expected. The same is true
for rendering JSON, XML, and other formats through <code>@ResponseBody</code> methods.</p>
</div>
<div class="paragraph">
<p>Alternatively, you may consider the full end-to-end integration testing support from
Spring Boot with <code>@SpringBootTest</code>. See the
<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing">Spring Boot Reference Guide</a>.</p>
</div>
<div class="paragraph">
<p>There are pros and cons for each approach. The options provided in Spring MVC Test are
different stops on the scale from classic unit testing to full integration testing. To be
certain, none of the options in Spring MVC Test fall under the category of classic unit
testing, but they are a little closer to it. For example, you can isolate the web layer
by injecting mocked services into controllers, in which case you are testing the web
layer only through the <code>DispatcherServlet</code> but with actual Spring configuration, as you
might test the data access layer in isolation from the layers above it. Also, you can use
the stand-alone setup, focusing on one controller at a time and manually providing the
configuration required to make it work.</p>
</div>
<div class="paragraph">
<p>Another important distinction when using Spring MVC Test is that, conceptually, such
tests are the server-side, so you can check what handler was used, if an exception was
handled with a HandlerExceptionResolver, what the content of the model is, what binding
errors there were, and other details. That means that it is easier to write expectations,
since the server is not an opaque box, as it is when testing it through an actual HTTP
client. This is generally an advantage of classic unit testing: It is easier to write,
reason about, and debug but does not replace the need for full integration tests. At the
same time, it is important not to lose sight of the fact that the response is the most
important thing to check. In short, there is room here for multiple styles and strategies
of testing even within the same project.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-resources">Further Examples</h5>
<div class="paragraph">
<p>The framework&#8217;s own tests include
<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples">
many sample tests</a> intended to show how to use MockMvc on its own or through the
<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples/client">
WebTestClient</a>. Browse these examples for further ideas.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-mvc-test-server-htmlunit">HtmlUnit Integration</h4>
<div class="paragraph">
<p>Spring provides integration between <a href="#spring-mvc-test-server">MockMvc</a> and
<a href="http://htmlunit.sourceforge.net/">HtmlUnit</a>. This simplifies performing end-to-end testing
when using HTML-based views. This integration lets you:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Easily test HTML pages by using tools such as
<a href="http://htmlunit.sourceforge.net/">HtmlUnit</a>,
<a href="https://www.seleniumhq.org">WebDriver</a>, and
<a href="http://www.gebish.org/manual/current/#spock-junit-testng">Geb</a> without the need to
deploy to a Servlet container.</p>
</li>
<li>
<p>Test JavaScript within pages.</p>
</li>
<li>
<p>Optionally, test using mock services to speed up testing.</p>
</li>
<li>
<p>Share logic between in-container end-to-end tests and out-of-container integration tests.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
MockMvc works with templating technologies that do not rely on a Servlet Container
(for example, Thymeleaf, FreeMarker, and others), but it does not work with JSPs, since
they rely on the Servlet container.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-htmlunit-why">Why HtmlUnit Integration?</h5>
<div class="paragraph">
<p>The most obvious question that comes to mind is &#8220;Why do I need this?&#8221; The answer is
best found by exploring a very basic sample application. Assume you have a Spring MVC web
application that supports CRUD operations on a <code>Message</code> object. The application also
supports paging through all messages. How would you go about testing it?</p>
</div>
<div class="paragraph">
<p>With Spring MVC Test, we can easily test if we are able to create a <code>Message</code>, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">MockHttpServletRequestBuilder createMessage = post("/messages/")
        .param("summary", "Spring Rocks")
        .param("text", "In case you didn't know, Spring Rocks!");

mockMvc.perform(createMessage)
        .andExpect(status().is3xxRedirection())
        .andExpect(redirectedUrl("/messages/123"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Test
fun test() {
    mockMvc.post("/messages/") {
        param("summary", "Spring Rocks")
        param("text", "In case you didn't know, Spring Rocks!")
    }.andExpect {
        status().is3xxRedirection()
        redirectedUrl("/messages/123")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>What if we want to test the form view that lets us create the message? For example,
assume our form looks like the following snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;form id="messageForm" action="/messages/" method="post"&gt;
    &lt;div class="pull-right"&gt;&lt;a href="/messages/"&gt;Messages&lt;/a&gt;&lt;/div&gt;

    &lt;label for="summary"&gt;Summary&lt;/label&gt;
    &lt;input type="text" class="required" id="summary" name="summary" value="" /&gt;

    &lt;label for="text"&gt;Message&lt;/label&gt;
    &lt;textarea id="text" name="text"&gt;&lt;/textarea&gt;

    &lt;div class="form-actions"&gt;
        &lt;input type="submit" value="Create" /&gt;
    &lt;/div&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>How do we ensure that our form produce the correct request to create a new message? A
naive attempt might resemble the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">mockMvc.perform(get("/messages/form"))
        .andExpect(xpath("//input[@name='summary']").exists())
        .andExpect(xpath("//textarea[@name='text']").exists());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">mockMvc.get("/messages/form").andExpect {
    xpath("//input[@name='summary']") { exists() }
    xpath("//textarea[@name='text']") { exists() }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This test has some obvious drawbacks. If we update our controller to use the parameter
<code>message</code> instead of <code>text</code>, our form test continues to pass, even though the HTML form
is out of synch with the controller. To resolve this we can combine our two tests, as
follows:</p>
</div>
<div id="spring-mvc-test-server-htmlunit-mock-mvc-test" class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">String summaryParamName = "summary";
String textParamName = "text";
mockMvc.perform(get("/messages/form"))
        .andExpect(xpath("//input[@name='" + summaryParamName + "']").exists())
        .andExpect(xpath("//textarea[@name='" + textParamName + "']").exists());

MockHttpServletRequestBuilder createMessage = post("/messages/")
        .param(summaryParamName, "Spring Rocks")
        .param(textParamName, "In case you didn't know, Spring Rocks!");

mockMvc.perform(createMessage)
        .andExpect(status().is3xxRedirection())
        .andExpect(redirectedUrl("/messages/123"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val summaryParamName = "summary";
val textParamName = "text";
mockMvc.get("/messages/form").andExpect {
    xpath("//input[@name='$summaryParamName']") { exists() }
    xpath("//textarea[@name='$textParamName']") { exists() }
}
mockMvc.post("/messages/") {
    param(summaryParamName, "Spring Rocks")
    param(textParamName, "In case you didn't know, Spring Rocks!")
}.andExpect {
    status().is3xxRedirection()
    redirectedUrl("/messages/123")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This would reduce the risk of our test incorrectly passing, but there are still some
problems:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>What if we have multiple forms on our page? Admittedly, we could update our XPath
expressions, but they get more complicated as we take more factors into account: Are
the fields the correct type? Are the fields enabled? And so on.</p>
</li>
<li>
<p>Another issue is that we are doing double the work we would expect. We must first
verify the view, and then we submit the view with the same parameters we just verified.
Ideally, this could be done all at once.</p>
</li>
<li>
<p>Finally, we still cannot account for some things. For example, what if the form has
JavaScript validation that we wish to test as well?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The overall problem is that testing a web page does not involve a single interaction.
Instead, it is a combination of how the user interacts with a web page and how that web
page interacts with other resources. For example, the result of a form view is used as
the input to a user for creating a message. In addition, our form view can potentially
use additional resources that impact the behavior of the page, such as JavaScript
validation.</p>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-why-integration">Integration Testing to the Rescue?</h6>
<div class="paragraph">
<p>To resolve the issues mentioned earlier, we could perform end-to-end integration testing,
but this has some drawbacks. Consider testing the view that lets us page through the
messages. We might need the following tests:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Does our page display a notification to the user to indicate that no results are
available when the messages are empty?</p>
</li>
<li>
<p>Does our page properly display a single message?</p>
</li>
<li>
<p>Does our page properly support paging?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To set up these tests, we need to ensure our database contains the proper messages. This
leads to a number of additional challenges:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ensuring the proper messages are in the database can be tedious. (Consider foreign key
constraints.)</p>
</li>
<li>
<p>Testing can become slow, since each test would need to ensure that the database is in
the correct state.</p>
</li>
<li>
<p>Since our database needs to be in a specific state, we cannot run tests in parallel.</p>
</li>
<li>
<p>Performing assertions on such items as auto-generated ids, timestamps, and others can
be difficult.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These challenges do not mean that we should abandon end-to-end integration testing
altogether. Instead, we can reduce the number of end-to-end integration tests by
refactoring our detailed tests to use mock services that run much faster, more reliably,
and without side effects. We can then implement a small number of true end-to-end
integration tests that validate simple workflows to ensure that everything works together
properly.</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-why-mockmvc">Enter HtmlUnit Integration</h6>
<div class="paragraph">
<p>So how can we achieve a balance between testing the interactions of our pages and still
retain good performance within our test suite? The answer is: &#8220;By integrating MockMvc
with HtmlUnit.&#8221;</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-options">HtmlUnit Integration Options</h6>
<div class="paragraph">
<p>You have a number of options when you want to integrate MockMvc with HtmlUnit:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#spring-mvc-test-server-htmlunit-mah">MockMvc and HtmlUnit</a>: Use this option if you
want to use the raw HtmlUnit libraries.</p>
</li>
<li>
<p><a href="#spring-mvc-test-server-htmlunit-webdriver">MockMvc and WebDriver</a>: Use this option to
ease development and reuse code between integration and end-to-end testing.</p>
</li>
<li>
<p><a href="#spring-mvc-test-server-htmlunit-geb">MockMvc and Geb</a>: Use this option if you want to
use Groovy for testing, ease development, and reuse code between integration and
end-to-end testing.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-htmlunit-mah">MockMvc and HtmlUnit</h5>
<div class="paragraph">
<p>This section describes how to integrate MockMvc and HtmlUnit. Use this option if you want
to use the raw HtmlUnit libraries.</p>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-mah-setup">MockMvc and HtmlUnit Setup</h6>
<div class="paragraph">
<p>First, make sure that you have included a test dependency on
<code>net.sourceforge.htmlunit:htmlunit</code>. In order to use HtmlUnit with Apache HttpComponents
4.5+, you need to use HtmlUnit 2.18 or higher.</p>
</div>
<div class="paragraph">
<p>We can easily create an HtmlUnit <code>WebClient</code> that integrates with MockMvc by using the
<code>MockMvcWebClientBuilder</code>, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">WebClient webClient;

@BeforeEach
void setup(WebApplicationContext context) {
    webClient = MockMvcWebClientBuilder
            .webAppContextSetup(context)
            .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">lateinit var webClient: WebClient

@BeforeEach
fun setup(context: WebApplicationContext) {
    webClient = MockMvcWebClientBuilder
            .webAppContextSetup(context)
            .build()
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is a simple example of using <code>MockMvcWebClientBuilder</code>. For advanced usage,
see <a href="#spring-mvc-test-server-htmlunit-mah-advanced-builder">Advanced <code>MockMvcWebClientBuilder</code></a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This ensures that any URL that references <code>localhost</code> as the server is directed to our
<code>MockMvc</code> instance without the need for a real HTTP connection. Any other URL is
requested by using a network connection, as normal. This lets us easily test the use of
CDNs.</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-mah-usage">MockMvc and HtmlUnit Usage</h6>
<div class="paragraph">
<p>Now we can use HtmlUnit as we normally would but without the need to deploy our
application to a Servlet container. For example, we can request the view to create a
message with the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">HtmlPage createMsgFormPage = webClient.getPage("http://localhost/messages/form");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val createMsgFormPage = webClient.getPage("http://localhost/messages/form")</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The default context path is <code>""</code>. Alternatively, we can specify the context path,
as described in <a href="#spring-mvc-test-server-htmlunit-mah-advanced-builder">Advanced <code>MockMvcWebClientBuilder</code></a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once we have a reference to the <code>HtmlPage</code>, we can then fill out the form and submit it
to create a message, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">HtmlForm form = createMsgFormPage.getHtmlElementById("messageForm");
HtmlTextInput summaryInput = createMsgFormPage.getHtmlElementById("summary");
summaryInput.setValueAttribute("Spring Rocks");
HtmlTextArea textInput = createMsgFormPage.getHtmlElementById("text");
textInput.setText("In case you didn't know, Spring Rocks!");
HtmlSubmitInput submit = form.getOneHtmlElementByAttribute("input", "type", "submit");
HtmlPage newMessagePage = submit.click();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val form = createMsgFormPage.getHtmlElementById("messageForm")
val summaryInput = createMsgFormPage.getHtmlElementById("summary")
summaryInput.setValueAttribute("Spring Rocks")
val textInput = createMsgFormPage.getHtmlElementById("text")
textInput.setText("In case you didn't know, Spring Rocks!")
val submit = form.getOneHtmlElementByAttribute("input", "type", "submit")
val newMessagePage = submit.click()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, we can verify that a new message was created successfully. The following
assertions use the <a href="https://assertj.github.io/doc/">AssertJ</a> library:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">assertThat(newMessagePage.getUrl().toString()).endsWith("/messages/123");
String id = newMessagePage.getHtmlElementById("id").getTextContent();
assertThat(id).isEqualTo("123");
String summary = newMessagePage.getHtmlElementById("summary").getTextContent();
assertThat(summary).isEqualTo("Spring Rocks");
String text = newMessagePage.getHtmlElementById("text").getTextContent();
assertThat(text).isEqualTo("In case you didn't know, Spring Rocks!");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">assertThat(newMessagePage.getUrl().toString()).endsWith("/messages/123")
val id = newMessagePage.getHtmlElementById("id").getTextContent()
assertThat(id).isEqualTo("123")
val summary = newMessagePage.getHtmlElementById("summary").getTextContent()
assertThat(summary).isEqualTo("Spring Rocks")
val text = newMessagePage.getHtmlElementById("text").getTextContent()
assertThat(text).isEqualTo("In case you didn't know, Spring Rocks!")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding code improves on our
<a href="#spring-mvc-test-server-htmlunit-mock-mvc-test">MockMvc test</a> in a number of ways.
First, we no longer have to explicitly verify our form and then create a request that
looks like the form. Instead, we request the form, fill it out, and submit it, thereby
significantly reducing the overhead.</p>
</div>
<div class="paragraph">
<p>Another important factor is that <a href="http://htmlunit.sourceforge.net/javascript.html">HtmlUnit
uses the Mozilla Rhino engine</a> to evaluate JavaScript. This means that we can also test
the behavior of JavaScript within our pages.</p>
</div>
<div class="paragraph">
<p>See the <a href="http://htmlunit.sourceforge.net/gettingStarted.html">HtmlUnit documentation</a> for
additional information about using HtmlUnit.</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-mah-advanced-builder">Advanced <code>MockMvcWebClientBuilder</code></h6>
<div class="paragraph">
<p>In the examples so far, we have used <code>MockMvcWebClientBuilder</code> in the simplest way
possible, by building a <code>WebClient</code> based on the <code>WebApplicationContext</code> loaded for us by
the Spring TestContext Framework. This approach is repeated in the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">WebClient webClient;

@BeforeEach
void setup(WebApplicationContext context) {
    webClient = MockMvcWebClientBuilder
            .webAppContextSetup(context)
            .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">lateinit var webClient: WebClient

@BeforeEach
fun setup(context: WebApplicationContext) {
    webClient = MockMvcWebClientBuilder
            .webAppContextSetup(context)
            .build()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also specify additional configuration options, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">WebClient webClient;

@BeforeEach
void setup() {
    webClient = MockMvcWebClientBuilder
        // demonstrates applying a MockMvcConfigurer (Spring Security)
        .webAppContextSetup(context, springSecurity())
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">lateinit var webClient: WebClient

@BeforeEach
fun setup() {
    webClient = MockMvcWebClientBuilder
        // demonstrates applying a MockMvcConfigurer (Spring Security)
        .webAppContextSetup(context, springSecurity())
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As an alternative, we can perform the exact same setup by configuring the <code>MockMvc</code>
instance separately and supplying it to the <code>MockMvcWebClientBuilder</code>, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">MockMvc mockMvc = MockMvcBuilders
        .webAppContextSetup(context)
        .apply(springSecurity())
        .build();

webClient = MockMvcWebClientBuilder
        .mockMvcSetup(mockMvc)
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is more verbose, but, by building the <code>WebClient</code> with a <code>MockMvc</code> instance, we have
the full power of MockMvc at our fingertips.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For additional information on creating a <code>MockMvc</code> instance, see
<a href="#spring-mvc-test-server-setup-options">Setup Choices</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-htmlunit-webdriver">MockMvc and WebDriver</h5>
<div class="paragraph">
<p>In the previous sections, we have seen how to use MockMvc in conjunction with the raw
HtmlUnit APIs. In this section, we use additional abstractions within the Selenium
<a href="https://docs.seleniumhq.org/projects/webdriver/">WebDriver</a> to make things even easier.</p>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-webdriver-why">Why WebDriver and MockMvc?</h6>
<div class="paragraph">
<p>We can already use HtmlUnit and MockMvc, so why would we want to use WebDriver? The
Selenium WebDriver provides a very elegant API that lets us easily organize our code. To
better show how it works, we explore an example in this section.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Despite being a part of <a href="https://docs.seleniumhq.org/">Selenium</a>, WebDriver does not
require a Selenium Server to run your tests.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Suppose we need to ensure that a message is created properly. The tests involve finding
the HTML form input elements, filling them out, and making various assertions.</p>
</div>
<div class="paragraph">
<p>This approach results in numerous separate tests because we want to test error conditions
as well. For example, we want to ensure that we get an error if we fill out only part of
the form. If we fill out the entire form, the newly created message should be displayed
afterwards.</p>
</div>
<div class="paragraph">
<p>If one of the fields were named &#8220;summary&#8221;, we might have something that resembles the
following repeated in multiple places within our tests:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">HtmlTextInput summaryInput = currentPage.getHtmlElementById("summary");
summaryInput.setValueAttribute(summary);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val summaryInput = currentPage.getHtmlElementById("summary")
summaryInput.setValueAttribute(summary)</code></pre>
</div>
</div>
<div class="paragraph">
<p>So what happens if we change the <code>id</code> to <code>smmry</code>? Doing so would force us to update all
of our tests to incorporate this change. This violates the DRY principle, so we should
ideally extract this code into its own method, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public HtmlPage createMessage(HtmlPage currentPage, String summary, String text) {
    setSummary(currentPage, summary);
    // ...
}

public void setSummary(HtmlPage currentPage, String summary) {
    HtmlTextInput summaryInput = currentPage.getHtmlElementById("summary");
    summaryInput.setValueAttribute(summary);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun createMessage(currentPage: HtmlPage, summary:String, text:String) :HtmlPage{
    setSummary(currentPage, summary);
    // ...
}

fun setSummary(currentPage:HtmlPage , summary: String) {
    val summaryInput = currentPage.getHtmlElementById("summary")
    summaryInput.setValueAttribute(summary)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Doing so ensures that we do not have to update all of our tests if we change the UI.</p>
</div>
<div class="paragraph">
<p>We might even take this a step further and place this logic within an <code>Object</code> that
represents the <code>HtmlPage</code> we are currently on, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class CreateMessagePage {

    final HtmlPage currentPage;

    final HtmlTextInput summaryInput;

    final HtmlSubmitInput submit;

    public CreateMessagePage(HtmlPage currentPage) {
        this.currentPage = currentPage;
        this.summaryInput = currentPage.getHtmlElementById("summary");
        this.submit = currentPage.getHtmlElementById("submit");
    }

    public &lt;T&gt; T createMessage(String summary, String text) throws Exception {
        setSummary(summary);

        HtmlPage result = submit.click();
        boolean error = CreateMessagePage.at(result);

        return (T) (error ? new CreateMessagePage(result) : new ViewMessagePage(result));
    }

    public void setSummary(String summary) throws Exception {
        summaryInput.setValueAttribute(summary);
    }

    public static boolean at(HtmlPage page) {
        return "Create Message".equals(page.getTitleText());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">    class CreateMessagePage(private val currentPage: HtmlPage) {

        val summaryInput: HtmlTextInput = currentPage.getHtmlElementById("summary")

        val submit: HtmlSubmitInput = currentPage.getHtmlElementById("submit")

        fun &lt;T&gt; createMessage(summary: String, text: String): T {
            setSummary(summary)

            val result = submit.click()
            val error = at(result)

            return (if (error) CreateMessagePage(result) else ViewMessagePage(result)) as T
        }

        fun setSummary(summary: String) {
            summaryInput.setValueAttribute(summary)
        }

        fun at(page: HtmlPage): Boolean {
            return "Create Message" == page.getTitleText()
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Formerly, this pattern was known as the
<a href="https://github.com/SeleniumHQ/selenium/wiki/PageObjects">Page Object Pattern</a>. While we
can certainly do this with HtmlUnit, WebDriver provides some tools that we explore in the
following sections to make this pattern much easier to implement.</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-webdriver-setup">MockMvc and WebDriver Setup</h6>
<div class="paragraph">
<p>To use Selenium WebDriver with the Spring MVC Test framework, make sure that your project
includes a test dependency on <code>org.seleniumhq.selenium:selenium-htmlunit-driver</code>.</p>
</div>
<div class="paragraph">
<p>We can easily create a Selenium WebDriver that integrates with MockMvc by using the
<code>MockMvcHtmlUnitDriverBuilder</code> as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">WebDriver driver;

@BeforeEach
void setup(WebApplicationContext context) {
    driver = MockMvcHtmlUnitDriverBuilder
            .webAppContextSetup(context)
            .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">lateinit var driver: WebDriver

@BeforeEach
fun setup(context: WebApplicationContext) {
    driver = MockMvcHtmlUnitDriverBuilder
            .webAppContextSetup(context)
            .build()
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is a simple example of using <code>MockMvcHtmlUnitDriverBuilder</code>. For more advanced
usage, see <a href="#spring-mvc-test-server-htmlunit-webdriver-advanced-builder">Advanced <code>MockMvcHtmlUnitDriverBuilder</code></a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The preceding example ensures that any URL that references <code>localhost</code> as the server is
directed to our <code>MockMvc</code> instance without the need for a real HTTP connection. Any other
URL is requested by using a network connection, as normal. This lets us easily test the
use of CDNs.</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-webdriver-usage">MockMvc and WebDriver Usage</h6>
<div class="paragraph">
<p>Now we can use WebDriver as we normally would but without the need to deploy our
application to a Servlet container. For example, we can request the view to create a
message with the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">CreateMessagePage page = CreateMessagePage.to(driver);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val page = CreateMessagePage.to(driver)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can then fill out the form and submit it to create a message, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ViewMessagePage viewMessagePage =
        page.createMessage(ViewMessagePage.class, expectedSummary, expectedText);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val viewMessagePage =
    page.createMessage(ViewMessagePage::class, expectedSummary, expectedText)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This improves on the design of our <a href="#spring-mvc-test-server-htmlunit-mah-usage">HtmlUnit test</a>
by leveraging the Page Object Pattern. As we mentioned in
<a href="#spring-mvc-test-server-htmlunit-webdriver-why">Why WebDriver and MockMvc?</a>, we can use the Page Object Pattern
with HtmlUnit, but it is much easier with WebDriver. Consider the following
<code>CreateMessagePage</code> implementation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class CreateMessagePage
        extends AbstractPage { <i class="conum" data-value="1"></i><b>(1)</b>

    <i class="conum" data-value="2"></i><b>(2)</b>
    private WebElement summary;
    private WebElement text;

    <i class="conum" data-value="3"></i><b>(3)</b>
    @FindBy(css = "input[type=submit]")
    private WebElement submit;

    public CreateMessagePage(WebDriver driver) {
        super(driver);
    }

    public &lt;T&gt; T createMessage(Class&lt;T&gt; resultPage, String summary, String details) {
        this.summary.sendKeys(summary);
        this.text.sendKeys(details);
        this.submit.click();
        return PageFactory.initElements(driver, resultPage);
    }

    public static CreateMessagePage to(WebDriver driver) {
        driver.get("http://localhost:9990/mail/messages/form");
        return PageFactory.initElements(driver, CreateMessagePage.class);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>CreateMessagePage</code> extends the <code>AbstractPage</code>. We do not go over the details of
<code>AbstractPage</code>, but, in summary, it contains common functionality for all of our pages.
For example, if our application has a navigational bar, global error messages, and other
features, we can place this logic in a shared location.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We have a member variable for each of the parts of the HTML page in which we are
interested. These are of type <code>WebElement</code>. WebDriver&#8217;s
<a href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory"><code>PageFactory</code></a> lets us remove a
lot of code from the HtmlUnit version of <code>CreateMessagePage</code> by automatically resolving
each <code>WebElement</code>. The
<a href="https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/PageFactory.html#initElements-org.openqa.selenium.WebDriver-java.lang.Class-"><code>PageFactory#initElements(WebDriver,Class&lt;T&gt;)</code></a>
method automatically resolves each <code>WebElement</code> by using the field name and looking it up
by the <code>id</code> or <code>name</code> of the element within the HTML page.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We can use the
<a href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory#making-the-example-work-using-annotations"><code>@FindBy</code> annotation</a>
to override the default lookup behavior. Our example shows how to use the <code>@FindBy</code>
annotation to look up our submit button with a <code>css</code> selector (<strong>input[type=submit]</strong>).</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class CreateMessagePage(private val driver: WebDriver) : AbstractPage(driver) { <i class="conum" data-value="1"></i><b>(1)</b>

    <i class="conum" data-value="2"></i><b>(2)</b>
    private lateinit var summary: WebElement
    private lateinit var text: WebElement

    <i class="conum" data-value="3"></i><b>(3)</b>
    @FindBy(css = "input[type=submit]")
    private lateinit var submit: WebElement

    fun &lt;T&gt; createMessage(resultPage: Class&lt;T&gt;, summary: String, details: String): T {
        this.summary.sendKeys(summary)
        text.sendKeys(details)
        submit.click()
        return PageFactory.initElements(driver, resultPage)
    }
    companion object {
        fun to(driver: WebDriver): CreateMessagePage {
            driver.get("http://localhost:9990/mail/messages/form")
            return PageFactory.initElements(driver, CreateMessagePage::class.java)
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>CreateMessagePage</code> extends the <code>AbstractPage</code>. We do not go over the details of
<code>AbstractPage</code>, but, in summary, it contains common functionality for all of our pages.
For example, if our application has a navigational bar, global error messages, and other
features, we can place this logic in a shared location.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We have a member variable for each of the parts of the HTML page in which we are
interested. These are of type <code>WebElement</code>. WebDriver&#8217;s
<a href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory"><code>PageFactory</code></a> lets us remove a
lot of code from the HtmlUnit version of <code>CreateMessagePage</code> by automatically resolving
each <code>WebElement</code>. The
<a href="https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/PageFactory.html#initElements-org.openqa.selenium.WebDriver-java.lang.Class-"><code>PageFactory#initElements(WebDriver,Class&lt;T&gt;)</code></a>
method automatically resolves each <code>WebElement</code> by using the field name and looking it up
by the <code>id</code> or <code>name</code> of the element within the HTML page.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We can use the
<a href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory#making-the-example-work-using-annotations"><code>@FindBy</code> annotation</a>
to override the default lookup behavior. Our example shows how to use the <code>@FindBy</code>
annotation to look up our submit button with a <code>css</code> selector (<strong>input[type=submit]</strong>).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, we can verify that a new message was created successfully. The following
assertions use the <a href="https://assertj.github.io/doc/">AssertJ</a> assertion library:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">assertThat(viewMessagePage.getMessage()).isEqualTo(expectedMessage);
assertThat(viewMessagePage.getSuccess()).isEqualTo("Successfully created a new message");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">assertThat(viewMessagePage.message).isEqualTo(expectedMessage)
assertThat(viewMessagePage.success).isEqualTo("Successfully created a new message")</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can see that our <code>ViewMessagePage</code> lets us interact with our custom domain model. For
example, it exposes a method that returns a <code>Message</code> object:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public Message getMessage() throws ParseException {
    Message message = new Message();
    message.setId(getId());
    message.setCreated(getCreated());
    message.setSummary(getSummary());
    message.setText(getText());
    return message;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun getMessage() = Message(getId(), getCreated(), getSummary(), getText())</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can then use the rich domain objects in our assertions.</p>
</div>
<div class="paragraph">
<p>Lastly, we must not forget to close the <code>WebDriver</code> instance when the test is complete,
as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@AfterEach
void destroy() {
    if (driver != null) {
        driver.close();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@AfterEach
fun destroy() {
    if (driver != null) {
        driver.close()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For additional information on using WebDriver, see the Selenium
<a href="https://github.com/SeleniumHQ/selenium/wiki/Getting-Started">WebDriver documentation</a>.</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-webdriver-advanced-builder">Advanced <code>MockMvcHtmlUnitDriverBuilder</code></h6>
<div class="paragraph">
<p>In the examples so far, we have used <code>MockMvcHtmlUnitDriverBuilder</code> in the simplest way
possible, by building a <code>WebDriver</code> based on the <code>WebApplicationContext</code> loaded for us by
the Spring TestContext Framework. This approach is repeated here, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">WebDriver driver;

@BeforeEach
void setup(WebApplicationContext context) {
    driver = MockMvcHtmlUnitDriverBuilder
            .webAppContextSetup(context)
            .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">lateinit var driver: WebDriver

@BeforeEach
fun setup(context: WebApplicationContext) {
    driver = MockMvcHtmlUnitDriverBuilder
            .webAppContextSetup(context)
            .build()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also specify additional configuration options, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">WebDriver driver;

@BeforeEach
void setup() {
    driver = MockMvcHtmlUnitDriverBuilder
            // demonstrates applying a MockMvcConfigurer (Spring Security)
            .webAppContextSetup(context, springSecurity())
            // for illustration only - defaults to ""
            .contextPath("")
            // By default MockMvc is used for localhost only;
            // the following will use MockMvc for example.com and example.org as well
            .useMockMvcForHosts("example.com","example.org")
            .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">lateinit var driver: WebDriver

@BeforeEach
fun setup() {
    driver = MockMvcHtmlUnitDriverBuilder
            // demonstrates applying a MockMvcConfigurer (Spring Security)
            .webAppContextSetup(context, springSecurity())
            // for illustration only - defaults to ""
            .contextPath("")
            // By default MockMvc is used for localhost only;
            // the following will use MockMvc for example.com and example.org as well
            .useMockMvcForHosts("example.com","example.org")
            .build()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As an alternative, we can perform the exact same setup by configuring the <code>MockMvc</code>
instance separately and supplying it to the <code>MockMvcHtmlUnitDriverBuilder</code>, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">MockMvc mockMvc = MockMvcBuilders
        .webAppContextSetup(context)
        .apply(springSecurity())
        .build();

driver = MockMvcHtmlUnitDriverBuilder
        .mockMvcSetup(mockMvc)
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is more verbose, but, by building the <code>WebDriver</code> with a <code>MockMvc</code> instance, we have
the full power of MockMvc at our fingertips.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For additional information on creating a <code>MockMvc</code> instance, see
<a href="#spring-mvc-test-server-setup-options">Setup Choices</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-htmlunit-geb">MockMvc and Geb</h5>
<div class="paragraph">
<p>In the previous section, we saw how to use MockMvc with WebDriver. In this section, we
use <a href="http://www.gebish.org/">Geb</a> to make our tests even Groovy-er.</p>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-geb-why">Why Geb and MockMvc?</h6>
<div class="paragraph">
<p>Geb is backed by WebDriver, so it offers many of the
<a href="#spring-mvc-test-server-htmlunit-webdriver-why">same benefits</a> that we get from
WebDriver. However, Geb makes things even easier by taking care of some of the
boilerplate code for us.</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-geb-setup">MockMvc and Geb Setup</h6>
<div class="paragraph">
<p>We can easily initialize a Geb <code>Browser</code> with a Selenium WebDriver that uses MockMvc, as
follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">def setup() {
    browser.driver = MockMvcHtmlUnitDriverBuilder
        .webAppContextSetup(context)
        .build()
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is a simple example of using <code>MockMvcHtmlUnitDriverBuilder</code>. For more advanced
usage, see <a href="#spring-mvc-test-server-htmlunit-webdriver-advanced-builder">Advanced <code>MockMvcHtmlUnitDriverBuilder</code></a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This ensures that any URL referencing <code>localhost</code> as the server is directed to our
<code>MockMvc</code> instance without the need for a real HTTP connection. Any other URL is
requested by using a network connection as normal. This lets us easily test the use of
CDNs.</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-geb-usage">MockMvc and Geb Usage</h6>
<div class="paragraph">
<p>Now we can use Geb as we normally would but without the need to deploy our application to
a Servlet container. For example, we can request the view to create a message with the
following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">to CreateMessagePage</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can then fill out the form and submit it to create a message, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">when:
form.summary = expectedSummary
form.text = expectedMessage
submit.click(ViewMessagePage)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any unrecognized method calls or property accesses or references that are not found are
forwarded to the current page object. This removes a lot of the boilerplate code we
needed when using WebDriver directly.</p>
</div>
<div class="paragraph">
<p>As with direct WebDriver usage, this improves on the design of our
<a href="#spring-mvc-test-server-htmlunit-mah-usage">HtmlUnit test</a> by using the Page Object
Pattern. As mentioned previously, we can use the Page Object Pattern with HtmlUnit and
WebDriver, but it is even easier with Geb. Consider our new Groovy-based
<code>CreateMessagePage</code> implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">class CreateMessagePage extends Page {
    static url = 'messages/form'
    static at = { assert title == 'Messages : Create'; true }
    static content =  {
        submit { $('input[type=submit]') }
        form { $('form') }
        errors(required:false) { $('label.error, .alert-error')?.text() }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our <code>CreateMessagePage</code> extends <code>Page</code>. We do not go over the details of <code>Page</code>, but, in
summary, it contains common functionality for all of our pages. We define a URL in which
this page can be found. This lets us navigate to the page, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">to CreateMessagePage</code></pre>
</div>
</div>
<div class="paragraph">
<p>We also have an <code>at</code> closure that determines if we are at the specified page. It should
return <code>true</code> if we are on the correct page. This is why we can assert that we are on the
correct page, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">then:
at CreateMessagePage
errors.contains('This field is required.')</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We use an assertion in the closure so that we can determine where things went wrong
if we were at the wrong page.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Next, we create a <code>content</code> closure that specifies all the areas of interest within the
page. We can use a
<a href="http://www.gebish.org/manual/current/#the-jquery-ish-navigator-api">jQuery-ish Navigator
API</a> to select the content in which we are interested.</p>
</div>
<div class="paragraph">
<p>Finally, we can verify that a new message was created successfully, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">then:
at ViewMessagePage
success == 'Successfully created a new message'
id
date
summary == expectedSummary
message == expectedMessage</code></pre>
</div>
</div>
<div class="paragraph">
<p>For further details on how to get the most out of Geb, see
<a href="http://www.gebish.org/manual/current/">The Book of Geb</a> user&#8217;s manual.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-mvc-test-client">Testing Client Applications</h3>
<div class="paragraph">
<p>You can use client-side tests to test code that internally uses the <code>RestTemplate</code>. The
idea is to declare expected requests and to provide &#8220;stub&#8221; responses so that you can
focus on testing the code in isolation (that is, without running a server). The following
example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">RestTemplate restTemplate = new RestTemplate();

MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();
mockServer.expect(requestTo("/greeting")).andRespond(withSuccess());

// Test code that uses the above RestTemplate ...

mockServer.verify();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val restTemplate = RestTemplate()

val mockServer = MockRestServiceServer.bindTo(restTemplate).build()
mockServer.expect(requestTo("/greeting")).andRespond(withSuccess())

// Test code that uses the above RestTemplate ...

mockServer.verify()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, <code>MockRestServiceServer</code> (the central class for client-side REST
tests) configures the <code>RestTemplate</code> with a custom <code>ClientHttpRequestFactory</code> that
asserts actual requests against expectations and returns &#8220;stub&#8221; responses. In this
case, we expect a request to <code>/greeting</code> and want to return a 200 response with
<code>text/plain</code> content. We can define additional expected requests and stub responses as
needed. When we define expected requests and stub responses, the <code>RestTemplate</code> can be
used in client-side code as usual. At the end of testing, <code>mockServer.verify()</code> can be
used to verify that all expectations have been satisfied.</p>
</div>
<div class="paragraph">
<p>By default, requests are expected in the order in which expectations were declared. You
can set the <code>ignoreExpectOrder</code> option when building the server, in which case all
expectations are checked (in order) to find a match for a given request. That means
requests are allowed to come in any order. The following example uses <code>ignoreExpectOrder</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">server = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">server = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even with unordered requests by default, each request is allowed to run once only.
The <code>expect</code> method provides an overloaded variant that accepts an <code>ExpectedCount</code>
argument that specifies a count range (for example, <code>once</code>, <code>manyTimes</code>, <code>max</code>, <code>min</code>,
<code>between</code>, and so on). The following example uses <code>times</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">RestTemplate restTemplate = new RestTemplate();

MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();
mockServer.expect(times(2), requestTo("/something")).andRespond(withSuccess());
mockServer.expect(times(3), requestTo("/somewhere")).andRespond(withSuccess());

// ...

mockServer.verify();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val restTemplate = RestTemplate()

val mockServer = MockRestServiceServer.bindTo(restTemplate).build()
mockServer.expect(times(2), requestTo("/something")).andRespond(withSuccess())
mockServer.expect(times(3), requestTo("/somewhere")).andRespond(withSuccess())

// ...

mockServer.verify()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that, when <code>ignoreExpectOrder</code> is not set (the default), and, therefore, requests
are expected in order of declaration, then that order applies only to the first of any
expected request. For example if "/something" is expected two times followed by
"/somewhere" three times, then there should be a request to "/something" before there is
a request to "/somewhere", but, aside from that subsequent "/something" and "/somewhere",
requests can come at any time.</p>
</div>
<div class="paragraph">
<p>As an alternative to all of the above, the client-side test support also provides a
<code>ClientHttpRequestFactory</code> implementation that you can configure into a <code>RestTemplate</code> to
bind it to a <code>MockMvc</code> instance. That allows processing requests using actual server-side
logic but without running a server. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
this.restTemplate = new RestTemplate(new MockMvcClientHttpRequestFactory(mockMvc));

// Test code that uses the above RestTemplate ...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build()
restTemplate = RestTemplate(MockMvcClientHttpRequestFactory(mockMvc))

// Test code that uses the above RestTemplate ...</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="spring-mvc-test-client-static-imports">Static Imports</h4>
<div class="paragraph">
<p>As with server-side tests, the fluent API for client-side tests requires a few static
imports. Those are easy to find by searching for <code>MockRest*</code>. Eclipse users should add
<code>MockRestRequestMatchers.*</code> and <code>MockRestResponseCreators.*</code> as
&#8220;favorite static members&#8221; in the Eclipse preferences under Java &#8594; Editor &#8594; Content
Assist &#8594; Favorites. That allows using content assist after typing the first character of
the static method name. Other IDEs (such IntelliJ) may not require any additional
configuration. Check for the support for code completion on static members.</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-mvc-test-client-resources">Further Examples of Client-side REST Tests</h4>
<div class="paragraph">
<p>Spring MVC Test&#8217;s own tests include
<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/client/samples">example
tests</a> of client-side REST tests.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing-resources">Further Resources</h2>
<div class="sectionbody">
<div class="paragraph">
<p>See the following resources for more information about testing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.junit.org/">JUnit</a>: &#8220;A programmer-friendly testing framework for Java&#8221;.
Used by the Spring Framework in its test suite and supported in the
<a href="#testcontext-framework">Spring TestContext Framework</a>.</p>
</li>
<li>
<p><a href="https://testng.org/">TestNG</a>: A testing framework inspired by JUnit with added support
for test groups, data-driven testing, distributed testing, and other features. Supported
in the <a href="#testcontext-framework">Spring TestContext Framework</a></p>
</li>
<li>
<p><a href="https://assertj.github.io/doc/">AssertJ</a>: &#8220;Fluent assertions for Java&#8221;,
including support for Java 8 lambdas, streams, and other features.</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Mock_Object">Mock Objects</a>: Article in Wikipedia.</p>
</li>
<li>
<p><a href="http://www.mockobjects.com/">MockObjects.com</a>: Web site dedicated to mock objects, a
technique for improving the design of code within test-driven development.</p>
</li>
<li>
<p><a href="https://mockito.github.io">Mockito</a>: Java mock library based on the
<a href="http://xunitpatterns.com/Test%20Spy.html">Test Spy</a> pattern. Used by the Spring Framework
in its test suite.</p>
</li>
<li>
<p><a href="https://easymock.org/">EasyMock</a>: Java library &#8220;that provides Mock Objects for
interfaces (and objects through the class extension) by generating them on the fly using
Java&#8217;s proxy mechanism.&#8221;</p>
</li>
<li>
<p><a href="https://jmock.org/">JMock</a>: Library that supports test-driven development of Java code
with mock objects.</p>
</li>
<li>
<p><a href="https://www.dbunit.org/">DbUnit</a>: JUnit extension (also usable with Ant and Maven) that
is targeted at database-driven projects and, among other things, puts your database into
a known state between test runs.</p>
</li>
<li>
<p><a href="https://www.testcontainers.org/">Testcontainers</a>: Java library that supports JUnit
tests, providing lightweight, throwaway instances of common databases, Selenium web
browsers, or anything else that can run in a Docker container.</p>
</li>
<li>
<p><a href="https://sourceforge.net/projects/grinder/">The Grinder</a>: Java load testing framework.</p>
</li>
<li>
<p><a href="https://github.com/Ninja-Squad/springmockk">SpringMockK</a>: Support for Spring Boot
integration tests written in Kotlin using <a href="https://mockk.io/">MockK</a> instead of Mockito.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-04-14 05:21:31 +0900
</div>
</div>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
</body>
</html>